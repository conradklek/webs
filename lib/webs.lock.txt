========== PROJECT STRUCTURE ==========
 ./lib
├─ client
│  ├─ ai.client.js
│  ├─ db.client.js
│  ├─ fs.client.js
│  ├─ hooks.js
│  ├─ runtime.js
│  ├─ service-worker.js
│  ├─ session.js
│  └─ sync-engine.js
├─ engine
│  ├─ compiler.js
│  ├─ component.js
│  ├─ core.js
│  ├─ expression-evaluator.js
│  ├─ reactivity.js
│  ├─ renderer.js
│  ├─ ssr.js
│  ├─ template-parser.js
│  └─ vdom.js
├─ native
│  ├─ src
│  │  ├─ api
│  │  │  ├─ webs_api.c
│  │  │  ├─ webs_api.h
│  │  │  └─ webs_api.o
│  │  ├─ codecs
│  │  │  ├─ webs_codec_json.c
│  │  │  ├─ webs_codec_json.h
│  │  │  └─ webs_codec_json.o
│  │  └─ core
│  │     ├─ webs_hash.c
│  │     ├─ webs_hash.h
│  │     ├─ webs_hash.o
│  │     ├─ webs_value.c
│  │     ├─ webs_value.h
│  │     └─ webs_value.o
│  ├─ test
│  │  ├─ json.parse.test.js
│  │  └─ json.stringify.test.js
│  ├─ .webs.dylib
│  ├─ Makefile
│  └─ webs.js
├─ server
│  ├─ ai.server.js
│  ├─ api.js
│  ├─ authentication.js
│  ├─ bundler.js
│  ├─ cli.js
│  ├─ db.server.js
│  ├─ fs.server.js
│  ├─ profiler.js
│  ├─ router.js
│  ├─ server-config.js
│  ├─ server-setup.js
│  ├─ server.js
│  └─ shell.js
├─ shared
│  ├─ devtools.js
│  ├─ logger.js
│  └─ utils.js
└─ webs.lock.txt

========== SOURCE FILES ==========

---------- START: client/ai.client.js ----------
import { state } from '../engine/reactivity.js';
import { db } from './db.client.js';
import { fs } from './fs.client.js';
import { onMounted, onUnmounted } from '../engine/component.js';
import { session } from './session.js';
import { createLogger } from '../shared/logger.js';

const errorLogger = createLogger('[Errors]');

/**
 * A base error class for all AI-related operations, providing a consistent
 * structure for error handling and serialization across client and server boundaries.
 * @class AIError
 * @extends {Error}
 * @property {Error | null} originalError - The original error that was caught, if any.
 */
export class AIError extends Error {
  /**
   * Creates an instance of AIError.
   * @param {string} message - The error message.
   * @param {Error | null} [originalError=null] - The original error object.
   */
  constructor(message, originalError = null) {
    const detailedMessage = originalError?.message
      ? `${message} -> ${originalError.message}`
      : message;
    super(detailedMessage);
    this.name = this.constructor.name;
    this.originalError = originalError;
    errorLogger.error(`[AIError] ${detailedMessage}`);
  }

  /**
   * Serializes the error to a plain object for transport.
   * @returns {{name: string, message: string}}
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
    };
  }
}

/** Error for timed-out operations. */
export class TimeoutError extends AIError {}
/** Error related to generating embeddings. */
export class EmbeddingError extends AIError {}
/** Error during a chat session. */
export class ChatError extends AIError {}
/** Error related to the vector store. */
export class StoreError extends AIError {}

/**
 * A namespace containing all specialized AI error classes, allowing for
 * precise error identification and handling.
 */
export const AIErrors = {
  AIError,
  TimeoutError,
  EmbeddingError,
  ChatError,
  StoreError,
};

/**
 * @typedef {keyof typeof AIErrors} AIErrorName
 */

/**
 * A map of error names to their corresponding classes for client-side reconstruction.
 * @internal
 * @type {Record<AIErrorName, typeof AIError>}
 */
const errorNameToClassMap = {
  AIError,
  TimeoutError,
  EmbeddingError,
  ChatError,
  StoreError,
};

/**
 * Reconstructs a specific AIError instance from a plain object received from the server.
 * @param {{name: string, message: string}} errorData - The plain object representing the error.
 * @returns {AIError} An instance of the appropriate AIError subclass.
 */
export function createErrorFromServer(errorData) {
  const ErrorClass =
    errorNameToClassMap[/** @type {AIErrorName} */ (errorData.name)] || AIError;
  return new ErrorClass(errorData.message);
}

/**
 * @file Defines the core types and interfaces for interacting with the AI client service.
 * This service provides a comprehensive API for text generation, stateful chat, semantic search,
 * and running server-side agents, forming the primary entry point for all client-side AI capabilities.
 */

/**
 * Represents a tool call requested by the AI model. The client is expected
 * to execute the specified function with the given arguments and return the result.
 * @typedef {object} ToolCall
 * @property {string} id - A unique identifier for this specific tool call. This ID is used to link the tool's result back to the initial request.
 * @property {object} function - The function to be executed.
 * @property {string} function.name - The name of the function to call (e.g., 'calculator', 'listFiles').
 * @property {object} function.arguments - A JSON object containing the arguments for the function, structured as defined in the tool's parameter schema.
 */

/**
 * @typedef {object} ChatAttachment
 * @property {string} path - The path to the file in the user's virtual file system.
 * @property {string} type - The MIME type of the file.
 */

/**
 * Represents a single message in a chat conversation. This is the fundamental unit
 * of communication with the AI models.
 * @typedef {object} ChatMessage
 * @property {'user' | 'assistant' | 'system' | 'tool'} role - The role of the message sender.
 * @property {string} content - The textual content of the message. For the 'tool' role, this is often a JSON string representing the tool's output.
 * @property {string | number} [user_id] - Optional user ID for filtering or context, particularly in multi-user scenarios.
 * @property {ToolCall[]} [tool_calls] - An array of tool calls requested by the assistant. This is present only when `role` is 'assistant'.
 * @property {string} [tool_call_id] - The ID of the tool call this message is a response to. Required when `role` is 'tool'.
 * @property {string} [tool_name] - The name of the tool that was executed. Used for context when `role` is 'tool'.
 * @property {string[]} [images] - An array of base64-encoded images to send to the model.
 * @property {ChatAttachment[]} [attachments] - An array of file attachments associated with the message.
 */

/**
 * Represents a chat session.
 * @typedef {object} Chat
 * @property {string} id - The unique ID of the chat.
 * @property {string} name - The user-facing name or title of the chat.
 * @property {string} [topic] - A brief topic or summary of the chat.
 * @property {number} owner_id - The ID of the user who owns the chat.
 * @property {string} created_at - An ISO 8601 timestamp of when the chat was created.
 */

/**
 * Describes the metadata associated with a semantic search result,
 * providing context about where the matched text was found.
 * @typedef {object} SearchResultMetadata
 * @property {string} filePath - The path to the source file of the result.
 * @property {number} startLine - The starting line number of the relevant text chunk in the file.
 * @property {number} endLine - The ending line number of the text chunk.
 * @property {string} [className] - If applicable, the name of the class containing the code chunk.
 * @property {string} [functionName] - If applicable, the name of the function or method.
 * @property {string} [summary] - An AI-generated summary of the text chunk, useful for quick previews.
 */

/**
 * Represents a single item returned from a semantic search query.
 * @typedef {object} SearchResult
 * @property {string} text - The actual text content of the search result.
 * @property {number} score - The relevance score of the result.
 * @property {SearchResultMetadata} metadata - Detailed metadata about the source of the text.
 */

/**
 * Provides an API for managing local AI models (e.g., via Ollama).
 * @typedef {object} AIModelService
 * @property {() => Promise<AIModel[]>} list - Retrieves a list of all locally available models.
 * @property {(modelName: string) => Promise<ReadableStream | null>} pull - Downloads a model from the registry. Returns a stream of progress events (JSON objects).
 * @property {(modelName: string) => Promise<any>} delete - Deletes a local model from the disk.
 */

/**
 * Defines the full API surface of the client-side AI service.
 * @typedef {object} AIService
 * @property {(prompt: string, options?: { model?: string }) => Promise<ReadableStream | null>} generate - Sends a single prompt for text generation and returns a `ReadableStream`.
 * @property {(prompt: string, options?: { onChunk?: (chunk: string) => void, model?: string }) => Promise<string>} stream - A convenience wrapper around `generate`.
 * @property {(messages: ChatMessage[], options?: { model?: string }) => Promise<ReadableStream | null>} chat - Sends a conversation history to the AI and returns a streaming response.
 * @property {(message: ChatMessage, options?: { model?: string }) => Promise<void>} createChat - Initiates a new, persistent chat, automatically titles it, and redirects.
 * @property {() => Promise<Chat[]>} getChats - Retrieves a list of all chats for the current user.
 * @property {(id: string, updates: Partial<Pick<Chat, 'name' | 'topic'>>) => Promise<Chat>} updateChat - Updates the details of a chat.
 * @property {(id: string) => Promise<{ success: boolean }>} deleteChat - Deletes a chat and all its messages.
 * @property {(query: string, limit?: number) => Promise<SearchResult[]>} search - Performs a semantic search over indexed files.
 * @property {(agentName: string, messages: ChatMessage[], options?: object) => Promise<ReadableStream | null>} agent - Executes a server-side agent.
 * @property {AIModelService} models - An object for managing local AI models.
 */

/**
 * Represents a single message within the context of the `useChat` composable,
 * stored in the client-side IndexedDB.
 * @typedef {object} StoredChatMessage
 * @property {string} id - A unique ID for the message.
 * @property {string} chat_id - The ID of the chat this message belongs to.
 * @property {string} username - The username of the sender ('assistant' for AI messages).
 * @property {string} message - The text content of the message.
 * @property {ChatAttachment[]} [attachments] - An array of file attachments associated with the message.
 * @property {number | null} user_id - The ID of the user who sent the message, or null for the AI assistant.
 * @property {string} created_at - An ISO 8601 timestamp of when the message was created.
 */

/**
 * Defines the reactive state for the `useChat` composable.
 * @typedef {object} ChatState
 * @property {StoredChatMessage[]} messages - An array of all messages in the chat, sorted chronologically.
 * @property {boolean} isLoading - True when fetching history or waiting for an AI response.
 * @property {Error | null} error - Any error that occurred.
 * @property {string} streamingResponse - The current AI response being streamed in real-time.
 */

/**
 * Configuration options for the `useChat` composable.
 * @typedef {object} UseChatOptions
 * @property {StoredChatMessage[]} [initialMessages] - Messages to hydrate the state with, from SSR.
 */

/**
 * The return type of the `useChat` composable.
 * @typedef {object} UseChatReturn
 * @property {import('../engine/reactivity.js').ReactiveProxy<ChatState>} state - The reactive state of the chat.
 * @property {(content: string, attachments?: File[]) => Promise<void>} send - Sends a new message from the user to the chat.
 */

/**
 * Represents a locally available AI model that can be managed by the client,
 * typically interacting with a local Ollama instance.
 * @typedef {object} AIModel
 * @property {string} name - The unique name of the model (e.g., 'gemma3:latest').
 * @property {string} [license] - The license under which the model is distributed.
 * @property {string} [size] - The size of the model on disk (e.g., '4.5GB').
 * @property {string} [modified_at] - The ISO 8601 timestamp of when the model was last modified.
 */

/**
 * Represents a tool call event during an agent's execution run.
 * @typedef {object} ToolEvent
 * @property {string} name - The name of the tool being called.
 * @property {object} args - The arguments passed to the tool.
 * @property {any} [result] - The result returned by the tool after execution.
 * @property {'pending' | 'complete'} status - The current status of the tool call.
 */

/**
 * Defines the reactive state for the `useAgent` composable.
 * @typedef {object} AgentState
 * @property {ChatMessage[]} messages - The complete history of messages in the agent conversation.
 * @property {boolean} isLoading - True when the agent is processing a request.
 * @property {Error | null} error - Any error that occurred during the agent's run.
 * @property {string} streamingResponse - The current text being streamed by the agent.
 * @property {ToolEvent[]} toolEvents - A log of tool calls for the current run.
 */

/**
 * Configuration options for the `useAgent` composable.
 * @typedef {object} UseAgentOptions
 * @property {ChatMessage[]} [initialMessages] - Messages to hydrate the state with, useful for SSR.
 */

/**
 * The return type of the `useAgent` composable.
 * @typedef {object} UseAgentReturn
 * @property {import('../engine/reactivity.js').ReactiveProxy<AgentState>} state - The reactive state of the agent interaction.
 * @property {(messages: ChatMessage[]) => Promise<void>} run - Executes the agent with a given set of messages.
 */

/** @type {AIService | undefined} */
let aiServiceInstance;

/**
 * @param {ReadableStream} stream
 * @param {(chunk: string) => void} [onChunk]
 */
async function readTextStream(stream, onChunk) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  let fullText = '';
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    const chunk = decoder.decode(value, { stream: true });
    fullText += chunk;
    if (onChunk) {
      onChunk(chunk);
    }
  }
  return fullText;
}

function createAIService() {
  /**
   * @param {string} url
   * @param {any} body
   * @param {string} errorContext
   * @param {string} [method='POST']
   */
  const handleRequest = async (url, body, errorContext, method = 'POST') => {
    const response = await fetch(url, {
      method,
      headers: body ? { 'Content-Type': 'application/json' } : {},
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!response.ok) {
      if (response.status === 302 && response.headers.get('Location')) {
        const location = response.headers.get('Location');
        if (location) {
          window.location.href = location;
        }
        return new Response(null, { status: 200 });
      }
      const errorText = await response.text();
      try {
        const errorData = JSON.parse(errorText);
        throw createErrorFromServer(errorData);
      } catch (e) {
        if (e instanceof AIError) throw e;
        throw new AIError(`${errorContext} failed: ${errorText}`);
      }
    }

    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    }
    return response.body;
  };

  /**
   * @param {string} prompt
   * @param {{ model?: string }} [options={}]
   */
  const generate = (prompt, options = {}) =>
    handleRequest('/api/ai/generate', { prompt, options }, 'AI generation');

  /**
   * @param {string} prompt
   * @param {{ onChunk?: (chunk: string) => void, model?: string }} [options={}]
   */
  const stream = async (prompt, options = {}) => {
    const stream = await generate(prompt, options);
    if (!stream) return '';
    return readTextStream(stream, options.onChunk);
  };

  /**
   * @param {string} query
   * @param {number} [limit=5]
   */
  const search = (query, limit = 5) =>
    handleRequest('/api/ai/search/files', { query, limit }, 'AI search');

  /**
   * @param {ChatMessage[]} messages
   * @param {{ model?: string }} [options={}]
   */
  const chat = (messages, options = {}) =>
    handleRequest('/api/ai/chat', { messages, options }, 'AI chat');

  /**
   * @param {ChatMessage} message
   * @param {{ model?: string }} [options={}]
   */
  const createChat = async (message, options = {}) => {
    await handleRequest(
      '/api/ai/chats/new',
      { message, options },
      'AI create chat',
    );
  };

  const getChats = () =>
    handleRequest('/api/ai/chats', undefined, 'Get chats', 'GET');

  /**
   * @param {string} id
   * @param {Partial<Pick<Chat, 'name' | 'topic'>>} updates
   */
  const updateChat = (id, updates) =>
    handleRequest(`/api/ai/chats/${id}`, updates, 'Update chat', 'PATCH');

  /** @param {string} id */
  const deleteChat = (id) =>
    handleRequest(`/api/ai/chats/${id}`, undefined, 'Delete chat', 'DELETE');

  /**
   * @param {string} agentName
   * @param {ChatMessage[]} messages
   * @param {object} [options={}]
   */
  const agent = (agentName, messages, options = {}) =>
    handleRequest(
      `/api/ai/agent/${agentName}`,
      { messages, options },
      `Agent execution for '${agentName}'`,
    );

  const models = {
    list: async () =>
      handleRequest('/api/ai/models/list', undefined, 'List models', 'GET'),
    /** @param {string} modelName */
    pull: async (modelName) =>
      handleRequest('/api/ai/models/pull', { model: modelName }, 'Pull model'),
    /** @param {string} modelName */
    delete: async (modelName) =>
      handleRequest(
        '/api/ai/models/delete',
        { model: modelName },
        'Delete model',
      ),
  };

  return {
    generate,
    stream,
    chat,
    createChat,
    getChats,
    updateChat,
    deleteChat,
    models,
    search,
    agent,
  };
}

function getAiServiceInstance() {
  if (!aiServiceInstance) {
    aiServiceInstance = createAIService();
  }
  return aiServiceInstance;
}

const aiProxy = new Proxy(function () {}, {
  apply(_, __, args) {
    const instance = getAiServiceInstance();
    if (args.length > 0) {
      const [prompt, options] = args;
      return instance.generate(prompt, options);
    }
    return instance;
  },
  get(_, prop) {
    const instance = getAiServiceInstance();
    return instance[/** @type {keyof AIService} */ (prop)];
  },
});

export const ai =
  /** @type {AIService & ((prompt?: string, options?: object) => (Promise<ReadableStream | null> | AIService))} */ (
    aiProxy
  );

/**
 * @param {string} agentName
 * @param {UseAgentOptions} [options={}]
 */
export function useAgent(agentName, options = {}) {
  /** @type {AgentState} */
  const initialState = {
    messages: options.initialMessages || [],
    isLoading: false,
    error: null,
    streamingResponse: '',
    toolEvents: [],
  };

  if (typeof window === 'undefined') {
    return { state: state(initialState), run: async () => {} };
  }

  const s =
    /** @type {import('../engine/reactivity.js').ReactiveProxy<AgentState>} */ (
      state(initialState)
    );

  /** @param {ChatMessage[]} messages */
  const run = async (messages) => {
    s.isLoading = true;
    s.error = null;
    s.streamingResponse = '';
    s.toolEvents = [];
    s.messages = [...messages];

    try {
      const stream = await ai.agent(agentName, messages);
      if (!stream) return;

      let buffer = '';
      await readTextStream(stream, (/** @type {string} */ chunk) => {
        buffer += chunk;
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim() === '') continue;
          try {
            const event = JSON.parse(line);
            switch (event.type) {
              case 'chunk':
                s.streamingResponse += event.content || '';
                break;
              case 'tool_start':
                s.toolEvents.push({
                  name: event.name,
                  args: event.args,
                  status: 'pending',
                });
                break;
              case 'tool_end': {
                const toolEvent = s.toolEvents.find(
                  (e) => e.name === event.name && e.status === 'pending',
                );
                if (toolEvent) {
                  toolEvent.result = event.result;
                  toolEvent.status = 'complete';
                }
                break;
              }
            }
          } catch (e) {
            console.error('Failed to parse agent stream event:', line, e);
          }
        }
      });
    } catch (e) {
      s.error = e instanceof Error ? e : new Error(String(e));
    } finally {
      if (s.streamingResponse) {
        s.messages.push({
          role: 'assistant',
          content: s.streamingResponse,
        });
      }
      s.isLoading = false;
    }
  };

  return { state: s, run };
}

/**
 * Reads a File or Blob and returns its base64 encoded string representation.
 * @param {File} file The file to read.
 * @returns {Promise<string>} A promise that resolves with the base64 string.
 */
function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      if (typeof reader.result === 'string') {
        const parts = reader.result.split(',');
        if (parts.length === 2 && parts[1]) {
          resolve(parts[1]);
        } else {
          reject(new Error('Invalid data URI format.'));
        }
      } else {
        reject(new Error('Failed to read file as base64 string.'));
      }
    };
    reader.onerror = (error) => reject(error);
    reader.readAsDataURL(file);
  });
}

/**
 * Reads a File or Blob and returns its text content.
 * @param {File} file The file to read.
 * @returns {Promise<string>} A promise that resolves with the text content.
 */
function fileToText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result);
      } else {
        reject(new Error('Failed to read file as text.'));
      }
    };
    reader.onerror = (error) => reject(error);
    reader.readAsText(file);
  });
}

/**
 * A composable for creating a persistent, real-time AI chat that syncs across devices.
 * It automatically handles message history from IndexedDB and real-time updates.
 *
 * @param {string | null} chatId - A unique identifier for the chat. If null, a new chat will be created on the first `send`.
 * @param {UseChatOptions} [options={}] - Options for initialization.
 * @returns {UseChatReturn} An object containing the reactive `state` and the `send` function.
 */
export function useChat(chatId, options = {}) {
  /** @type {ChatState} */
  const initialState = {
    messages: options.initialMessages || [],
    isLoading: !options.initialMessages,
    error: null,
    streamingResponse: '',
  };

  if (typeof window === 'undefined') {
    return { state: state(initialState), send: async () => {} };
  }

  const s = state(initialState);
  const chatDb = db('chat_messages');

  const fetchHistory = async () => {
    if (!chatId) {
      s.isLoading = false;
      return;
    }
    if (s.messages.length > 0) {
      s.isLoading = false;
      return;
    }
    try {
      s.isLoading = true;
      const allMessages = await chatDb.query('by-chat', chatId);
      if (allMessages) {
        s.messages = allMessages.sort(
          (a, b) =>
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime(),
        );
      }
    } catch (e) {
      s.error = e instanceof Error ? e : new Error(String(e));
    } finally {
      s.isLoading = false;
    }
  };

  if (chatId) {
    onMounted(fetchHistory);
    const unsubscribe = chatDb.subscribe(fetchHistory);
    onUnmounted(unsubscribe);
  }

  /** * @param {string} content
   * @param {File[]} [attachments]
   */
  const send = async (content, attachments = []) => {
    if (!session.user) {
      s.error = new AIError('User not logged in.');
      return;
    }

    if (!chatId) {
      /** @type {ChatMessage} */
      const createMessage = { role: 'user', content, attachments: [] };
      await ai.createChat(createMessage);
      return;
    }

    s.isLoading = true;
    s.error = null;
    s.streamingResponse = '';

    try {
      /** @type {ChatAttachment[]} */
      const processedAttachments = [];
      /** @type {string[]} */
      const imageBase64s = [];
      let inlinedFileContent = '';

      const inlinableMimeTypes = [
        'text/plain',
        'text/markdown',
        'text/csv',
        'application/json',
        'application/javascript',
        'text/html',
        'text/css',
      ];

      for (const file of attachments) {
        const filePath = `attachments/${chatId}/${crypto.randomUUID()}-${file.name}`;
        await fs(filePath).write(file, { access: 'private' });
        processedAttachments.push({ path: filePath, type: file.type });

        if (file.type.startsWith('image/')) {
          const base64 = await fileToBase64(file);
          imageBase64s.push(base64);
        } else if (inlinableMimeTypes.includes(file.type)) {
          const fileText = await fileToText(file);
          inlinedFileContent += `\n\n--- Attached file: ${file.name} ---\n${fileText}\n--- End of file ---`;
        }
      }

      const finalContentForApi = (content + inlinedFileContent).trim();

      const userMessage = {
        id: crypto.randomUUID(),
        chat_id: chatId,
        username: session.user.username,
        message: content,
        attachments: processedAttachments,
        user_id: session.user.id,
        created_at: new Date().toISOString(),
      };
      await chatDb.put(userMessage);

      const allMessages = (await chatDb.query('by-chat', chatId)) || [];
      const historyForApi = allMessages
        .sort(
          (a, b) =>
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime(),
        )
        .map((msg) => {
          /** @type {ChatMessage['role']} */
          const role =
            msg.username === session.user?.username ? 'user' : 'assistant';

          /** @type {ChatMessage} */
          const apiMsg = { role, content: '' };

          if (msg.id === userMessage.id) {
            apiMsg.content = finalContentForApi;
            if (imageBase64s.length > 0) {
              apiMsg.images = imageBase64s;
            }
          } else {
            apiMsg.content = msg.message;
          }

          return apiMsg;
        });

      const stream = await ai.chat(historyForApi);
      if (!stream) return;

      const fullResponse = await readTextStream(
        stream,
        (/** @type {string} */ chunk) => {
          s.streamingResponse += chunk;
        },
      );

      if (fullResponse) {
        const aiMessage = {
          id: crypto.randomUUID(),
          chat_id: chatId,
          username: 'assistant',
          message: fullResponse,
          user_id: null,
          created_at: new Date().toISOString(),
        };
        await chatDb.put(aiMessage);
      }
    } catch (e) {
      s.error = e instanceof Error ? e : new AIError(String(e));
      if (e instanceof ChatError) {
        console.error('A chat-specific error occurred:', e.message);
      }
    } finally {
      s.isLoading = false;
      s.streamingResponse = '';
    }
  };

  return { state: s, send };
}

---------- END: client/ai.client.js ----------

---------- START: client/db.client.js ----------
/**
 * @file Orchestrates the client-side IndexedDB instance, providing a high-level API for schema management, transactional operations, and data access.
 */

import { createLogger } from '../shared/logger.js';
import { session } from './runtime.js';

/**
 * @typedef {object} IndexSchema
 * @property {string} name - The name of the index.
 * @property {string | string[]} keyPath - The key path for the index.
 * @property {IDBIndexParameters} [options] - Options for the index (e.g., unique, multiEntry).
 */

/**
 * @typedef {object} TableSchema
 * @property {string} name - The name of the object store.
 * @property {string | string[]} keyPath - The key path for the object store.
 * @property {boolean} [autoIncrement] - Whether the key should be auto-incrementing.
 * @property {IndexSchema[]} [indexes] - An array of index definitions for the object store.
 * @property {boolean} [sync] - Whether the table should be synchronized with the server.
 */

/**
 * @typedef {object} DbConfig
 * @property {number} version - The version of the database schema.
 * @property {TableSchema[]} clientTables - An array of table schemas for the client-side database.
 */

/**
 * @typedef {object} DbTableApi
 * @property {(key: IDBValidKey) => Promise<any | null | undefined>} get - Retrieves a single record by its primary key.
 * @property {() => Promise<any[] | undefined>} getAll - Retrieves all records from the table.
 * @property {(prefix: string) => Promise<any[] | undefined>} findByPrefix - Retrieves records whose primary key starts with a given prefix.
 * @property {(indexName: string, query: IDBValidKey | IDBKeyRange) => Promise<any[] | undefined>} query - Queries the table using a specified index.
 * @property {(record: object) => Promise<void>} put - Adds or updates a record in the table.
 * @property {(records: object[]) => Promise<void>} bulkPut - Adds or updates multiple records in the table.
 * @property {(key: IDBValidKey) => Promise<void>} delete - Deletes a record by its primary key.
 * @property {(callback: () => void) => () => void} subscribe - Subscribes to changes in the table.
 * @property {() => Promise<void | undefined>} clear - Clears all records from the table.
 */

const logger = createLogger('[DB]');

const DB_NAME = 'webs-local-db';

/**
 * @internal
 * @type {Promise<IDBDatabase | null> | null}
 * A promise that resolves with the database instance.
 */
let dbPromise = null;

/**
 * @internal
 * @type {import('./sync-engine.js').SyncEngine | null} A reference to the synchronization engine.
 */
let syncEngineRef = null;

/**
 * @internal
 * Promisifies an IDBRequest, providing a modern async/await-compatible interface for IndexedDB's event-based operations.
 * @template T
 * @param {IDBRequest<T>} request The IndexedDB request.
 * @returns {Promise<T>} A promise that resolves with the request's result or rejects with its error.
 */
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

/**
 * @internal
 * Opens and initializes the IndexedDB database.
 * @param {DbConfig} config The database configuration.
 * @returns {Promise<IDBDatabase | null>} A promise that resolves with the database instance.
 */
function openDB(config) {
  if (typeof window === 'undefined' || !window.indexedDB) {
    return Promise.resolve(null);
  }
  if (dbPromise) return dbPromise;
  logger.log('Opening IndexedDB...');
  dbPromise = new Promise((resolve, reject) => {
    const version = config?.version || 1;
    const request = window.indexedDB.open(DB_NAME, version);

    request.onerror = (e) => {
      logger.error('IndexedDB error:', /** @type {any} */ (e.target).error);
      reject(/** @type {any} */ (e.target).error);
    };
    request.onsuccess = () => {
      logger.log('IndexedDB opened successfully.');
      resolve(request.result);
    };

    request.onupgradeneeded = (e) => {
      logger.log('IndexedDB upgrade needed.', {
        oldVersion: e.oldVersion,
        newVersion: e.newVersion,
      });
      const db = /** @type {IDBDatabase} */ (
        /** @type {any} */ (e.target).result
      );
      const tx = /** @type {IDBTransaction} */ (
        /** @type {any} */ (e.target).transaction
      );

      if (!db.objectStoreNames.contains('outbox')) {
        logger.debug("Creating 'outbox' object store.");
        db.createObjectStore('outbox', { keyPath: 'opId' });
      }

      config?.clientTables?.forEach((tableSchema) => {
        if (!db.objectStoreNames.contains(tableSchema.name)) {
          logger.debug(`Creating '${tableSchema.name}' object store.`);
          const store = db.createObjectStore(tableSchema.name, {
            keyPath: tableSchema.keyPath,
            autoIncrement: tableSchema.autoIncrement,
          });
          tableSchema.indexes?.forEach((index) =>
            store.createIndex(index.name, index.keyPath, index.options),
          );
        } else {
          logger.debug(
            `Checking indexes for '${tableSchema.name}' object store.`,
          );
          if (tx) {
            const store = tx.objectStore(tableSchema.name);
            const existingIndices = new Set(store.indexNames);
            tableSchema.indexes?.forEach((index) => {
              if (!existingIndices.has(index.name)) {
                logger.debug(
                  `Creating index '${index.name}' on '${tableSchema.name}'.`,
                );
                store.createIndex(index.name, index.keyPath, index.options);
              }
            });
          }
        }
      });
    };
  });
  return dbPromise;
}

/**
 * @internal
 * @type {Map<string, Set<() => void>>}
 * A map of table names to their subscriber callback functions.
 */
const tableSubscribers = new Map();

/**
 * Notifies all subscribers for a given table that its data has changed.
 * @param {string} tableName The name of the table that was updated.
 */
export function notify(tableName) {
  logger.debug(`Notifying subscribers for table: ${tableName}`);
  tableSubscribers.get(tableName)?.forEach((callback) => callback());
}

/**
 * The core database object containing low-level methods.
 * @internal
 */
export const coreDB = {
  /** @type {Promise<IDBDatabase | null> | null} */
  db: null,
  _getDB() {
    if (!this.db) {
      this.db = openDB(/** @type {any} */ (window).__WEBS_DB_CONFIG__);
    }
    return this.db;
  },

  /**
   * Sets a reference to the sync engine for push notifications.
   * @param {import('./sync-engine.js').SyncEngine} engine The sync engine instance.
   */
  setSyncEngine(engine) {
    syncEngineRef = engine;
  },

  /**
   * Performs an IndexedDB transaction.
   * @template T
   * @param {string | string[]} tableNames The name(s) of the object stores to include in the transaction.
   * @param {IDBTransactionMode} mode The transaction mode ('readonly' or 'readwrite').
   * @param {(tx: IDBTransaction) => T | Promise<T>} action The function to execute within the transaction context.
   * @returns {Promise<T | undefined>} A promise that resolves with the result of the action.
   */
  async transaction(tableNames, mode, action) {
    const db = await this._getDB();
    if (!db) return undefined;
    const tableNamesArray = Array.isArray(tableNames)
      ? tableNames
      : [tableNames];

    const tx = db.transaction(tableNamesArray, mode);

    const transactionPromise = new Promise((resolve, reject) => {
      tx.oncomplete = () => {
        resolve(undefined);
      };
      tx.onerror = () => {
        reject(tx.error);
      };
      tx.onabort = () => {
        reject(new Error('Transaction aborted'));
      };
    });

    try {
      const actionResult = await action(tx);
      await transactionPromise;
      return actionResult;
    } catch (err) {
      tx.abort();
      throw err;
    }
  },

  /**
   * @param {string} tableName
   * @param {IDBValidKey} key
   */
  get: (tableName, key) =>
    coreDB.transaction(tableName, 'readonly', (tx) =>
      promisifyRequest(tx.objectStore(tableName).get(key)),
    ),

  /** @param {string} tableName */
  getAll: (tableName) =>
    coreDB.transaction(tableName, 'readonly', (tx) =>
      promisifyRequest(tx.objectStore(tableName).getAll()),
    ),

  /**
   * @param {string} tableName
   * @param {string} prefix
   */
  findByPrefix: (tableName, prefix) =>
    coreDB.transaction(tableName, 'readonly', (tx) => {
      const store = tx.objectStore(tableName);
      const range = IDBKeyRange.bound(prefix, prefix + '\uffff');
      return promisifyRequest(store.getAll(range));
    }),

  /**
   * @param {string} tableName
   * @param {string} indexName
   * @param {IDBValidKey | IDBKeyRange} query
   */
  query: (tableName, indexName, query) =>
    coreDB.transaction(tableName, 'readonly', (tx) => {
      const store = tx.objectStore(tableName);
      const index = store.index(indexName);
      return promisifyRequest(index.getAll(query));
    }),

  /**
   * @param {string} tableName
   * @param {any} record
   */
  put: async (tableName, record) => {
    const tableConfig = /** @type {any} */ (
      window
    ).__WEBS_DB_CONFIG__?.clientTables.find(
      (/** @type {TableSchema} */ t) => t.name === tableName,
    );
    const isSynced = tableConfig?.sync;
    const tables = isSynced ? [tableName, 'outbox'] : [tableName];

    const recordWithUser = {
      ...record,
      user_id: record.user_id || session.user?.id,
    };

    await coreDB.transaction(tables, 'readwrite', (tx) => {
      tx.objectStore(tableName).put(recordWithUser);
      if (isSynced) {
        const op = {
          tableName,
          type: 'put',
          data: recordWithUser,
          opId: crypto.randomUUID(),
        };
        tx.objectStore('outbox').add(op);
      }
    });
    if (isSynced && syncEngineRef) syncEngineRef.process();
    notify(tableName);
  },

  /**
   * @param {string} tableName
   * @param {object[]} records
   */
  bulkPut: async (tableName, records) => {
    if (!records || records.length === 0) return;
    await coreDB.transaction(tableName, 'readwrite', (tx) => {
      const store = tx.objectStore(tableName);
      records.forEach((record) => store.put(record));
    });
    notify(tableName);
  },

  /**
   * @param {string} tableName
   * @param {IDBValidKey} key
   */
  delete: async (tableName, key) => {
    const tableConfig = /** @type {any} */ (
      window
    ).__WEBS_DB_CONFIG__?.clientTables.find(
      (/** @type {TableSchema} */ t) => t.name === tableName,
    );
    const isSynced = tableConfig?.sync;
    const tables = isSynced ? [tableName, 'outbox'] : [tableName];

    await coreDB.transaction(tables, 'readwrite', (tx) => {
      tx.objectStore(tableName).delete(key);
      if (isSynced) {
        const op = {
          tableName,
          type: 'delete',
          id: key,
          opId: crypto.randomUUID(),
        };
        tx.objectStore('outbox').add(op);
      }
    });
    if (isSynced && syncEngineRef) syncEngineRef.process();
    notify(tableName);
  },

  /** @param {string} tableName */
  clear: (tableName) =>
    coreDB.transaction(tableName, 'readwrite', async (tx) => {
      await promisifyRequest(tx.objectStore(tableName).clear());
      notify(tableName);
    }),

  /**
   * @param {string} tableName
   * @param {() => void} callback
   * @returns {() => void} An unsubscribe function.
   */
  subscribe: (tableName, callback) => {
    if (!tableSubscribers.has(tableName)) {
      tableSubscribers.set(tableName, new Set());
    }
    tableSubscribers.get(tableName)?.add(callback);
    return () => tableSubscribers.get(tableName)?.delete(callback);
  },

  /**
   * Handles incoming sync messages from the server.
   * @param {object} message
   * @param {string} message.tableName
   * @param {'put' | 'delete'} message.type
   * @param {object} [message.data]
   * @param {IDBValidKey} [message.id]
   */
  handleSyncMessage: async ({ tableName, type, data, id }) => {
    logger.log(`Handling incoming sync message`, { tableName, type, data, id });
    await coreDB.transaction(tableName, 'readwrite', (tx) => {
      const store = tx.objectStore(tableName);
      if (type === 'put' && data) {
        store.put(data);
      } else if (type === 'delete' && id !== undefined) {
        store.delete(id);
      }
    });
    notify(tableName);
  },
};

/**
 * A wrapper around `coreDB.transaction` for external use.
 * @template T
 * @param {string | string[]} tableNames The name(s) of the object stores.
 * @param {IDBTransactionMode} mode The transaction mode.
 * @param {(tx: IDBTransaction) => T | Promise<T>} action The function to execute.
 * @returns {Promise<T | undefined>} A promise that resolves with the result of the action.
 */
export function transaction(tableNames, mode, action) {
  return coreDB.transaction(tableNames, mode, action);
}

/**
 * @internal
 * Creates a no-op stub of the database API for server-side rendering (SSR) environments, ensuring isomorphic code compatibility.
 * @returns {DbTableApi}
 */
function createSsrDbMock() {
  const fn = () => Promise.resolve();
  const getFn = () => Promise.resolve(null);
  const empty = () => Promise.resolve([]);
  return {
    get: getFn,
    getAll: empty,
    findByPrefix: empty,
    query: empty,
    put: fn,
    bulkPut: fn,
    delete: fn,
    subscribe: () => () => {},
    clear: fn,
  };
}

/**
 * Returns a high-level API for interacting with a specific database table.
 * @param {string} tableName The name of the table to interact with.
 * @returns {DbTableApi} An object with methods for interacting with the specified table.
 */
export function db(tableName) {
  if (typeof window === 'undefined') {
    return createSsrDbMock();
  }
  if (!tableName) throw new Error('db() requires a table name.');

  return {
    get: (key) => coreDB.get(tableName, key),
    getAll: () => coreDB.getAll(tableName),
    findByPrefix: (prefix) => coreDB.findByPrefix(tableName, prefix),
    query: (indexName, query) => coreDB.query(tableName, indexName, query),
    put: (record) => coreDB.put(tableName, record),
    bulkPut: (records) => coreDB.bulkPut(tableName, records),
    delete: (key) => coreDB.delete(tableName, key),
    subscribe: (callback) => coreDB.subscribe(tableName, callback),
    clear: () => coreDB.clear(tableName),
  };
}

/**
 * Resets the database state for testing purposes.
 * @internal
 */
export function _resetDBForTests() {
  dbPromise = null;
  coreDB.db = null;
  tableSubscribers.clear();
}

---------- END: client/db.client.js ----------

---------- START: client/fs.client.js ----------
/**
 * @file Client-side file system abstraction over IndexedDB.
 */

import { session } from './runtime.js';
import { db, transaction, notify } from './db.client.js';
import { createLogger } from '../shared/logger.js';

/**
 * @typedef {object} FsOperationOptions
 * @property {'private' | 'public'} [access] - The access level of the file.
 */

/**
 * @typedef {object} DirectoryEntry
 * @property {string} name - The name of the file or directory.
 * @property {boolean} isDirectory - True if the entry is a directory.
 * @property {string} path - The full path of the entry.
 */

/**
 * @typedef {object} FsApi
 * @property {() => Promise<any | null>} read - Reads the content of a file. Throws if used on a directory path.
 * @property {() => Promise<DirectoryEntry[]>} ls - Lists the contents of a directory. Throws if used on a file path.
 * @property {(content: any, options?: FsOperationOptions) => Promise<void>} write - Writes content to a file. Throws if used on a directory path.
 * @property {(options?: FsOperationOptions) => Promise<void>} rm - Removes a file or directory.
 */

const logger = createLogger('[FS]');

/**
 * @internal
 * Core file system logic that directly interacts with the database.
 */
export const coreFS = {
  /**
   * Reads the content of a file.
   * @param {string} path - The path to the file.
   * @returns {Promise<any | null>} A promise that resolves with the file content, or null if not found.
   */
  readFile: (path) =>
    db('files')
      .get(path)
      .then((file) => (file ? file.content : null)),

  /**
   * Lists the contents of a directory.
   * @param {string} path - The path to the directory.
   * @returns {Promise<DirectoryEntry[]>} A promise that resolves with an array of directory entries.
   */
  listDirectory: async (path) => {
    logger.debug(`[FS] Listing directory: "${path}"`);
    const normalizedPath = path.replace(/\/$/, '');
    const prefix = normalizedPath ? `${normalizedPath}/` : '';
    const allFiles = (await db('files').findByPrefix(prefix)) || [];
    const directChildren = new Map();

    for (const file of allFiles) {
      if (!file.path.startsWith(prefix)) continue;

      const relativePath = file.path.substring(prefix.length);
      const segments = relativePath.split('/');
      const childName = segments[0];

      if (!childName) continue;

      if (!directChildren.has(childName)) {
        const isDirectory = segments.length > 1;
        directChildren.set(childName, {
          name: childName,
          isDirectory: isDirectory,
          path: isDirectory ? `${prefix}${childName}` : file.path,
        });
      }
    }
    const result = Array.from(directChildren.values()).sort((a, b) =>
      a.name.localeCompare(b.name),
    );
    logger.debug(`[FS] Directory listing for "${path}" result:`, result);
    return result;
  },

  /**
   * Creates a file system operation and adds it to the outbox for synchronization.
   * @param {object} payload - The operation payload.
   * @param {'fs:write' | 'fs:rm'} payload.type - The type of operation.
   * @param {string} payload.path - The path of the file or directory.
   * @param {any} [payload.data] - The data for a write operation.
   * @param {FsOperationOptions} payload.options - Options for the operation.
   * @returns {Promise<void>}
   */
  async createOperation(payload) {
    if (!session.isLoggedIn || !session.user)
      throw new Error('User not logged in.');
    const op = { ...payload, opId: crypto.randomUUID() };
    logger.log(`[FS] Creating operation:`, op);

    const currentUser = session.user;
    if (!currentUser) {
      throw new Error('User session not found during transaction.');
    }

    await transaction(['files', 'outbox'], 'readwrite', (tx) => {
      const filesStore = tx.objectStore('files');
      const outboxStore = tx.objectStore('outbox');

      if (op.type === 'fs:write') {
        filesStore.put({
          path: op.path,
          content: op.data,
          user_id: currentUser.id,
          access: op.options.access || 'private',
          size: op.data?.length || 0,
          last_modified: new Date().toISOString(),
        });
      } else if (op.type === 'fs:rm') {
        const key =
          typeof op.path === 'string'
            ? { path: op.path, user_id: currentUser.id }
            : op.path;
        filesStore.delete([key.path, key.user_id]);
      }
      outboxStore.add(op);
    });

    notify('files');
  },
};

/**
 * Provides a high-level API for direct, non-reactive interaction with the client-side file system.
 * @param {string | (() => string)} [path=''] - The path to a file or directory. Can be a string or a reactive getter function.
 * @returns {FsApi} An object with methods for file system interaction.
 */
export function fs(path = '') {
  if (typeof window === 'undefined') {
    return {
      read: () => Promise.resolve(null),
      ls: () => Promise.resolve([]),
      write: () => Promise.resolve(),
      rm: () => Promise.resolve(),
    };
  }

  const getIsDirectory = (/** @type {string | (() => string)} */ p) => {
    const currentPath = typeof p === 'function' ? p() : p;
    return currentPath === '' || currentPath.endsWith('/');
  };

  const methods = {
    read: () => {
      if (getIsDirectory(path))
        return Promise.reject(new Error('Cannot call .read() on a directory.'));
      const currentPath = typeof path === 'function' ? path() : path;
      return coreFS.readFile(currentPath);
    },
    ls: () => {
      if (!getIsDirectory(path))
        return Promise.reject(
          new Error(
            'Can only call .ls() on a directory path (ending with "/").',
          ),
        );
      const currentPath = typeof path === 'function' ? path() : path;
      return coreFS.listDirectory(currentPath);
    },
    /**
     * @param {any} content
     * @param {FsOperationOptions} [options]
     */
    write: (content, options = { access: 'private' }) => {
      if (getIsDirectory(path))
        throw new Error('Cannot call .write() on a directory.');
      const currentPath = typeof path === 'function' ? path() : path;
      return coreFS.createOperation({
        type: 'fs:write',
        path: currentPath,
        data: content,
        options,
      });
    },
    /** @param {FsOperationOptions} [options] */
    rm: (options = { access: 'private' }) => {
      const currentPath = typeof path === 'function' ? path() : path;
      return coreFS.createOperation({
        type: 'fs:rm',
        path: currentPath,
        options,
      });
    },
  };

  return methods;
}

---------- END: client/fs.client.js ----------

---------- START: client/hooks.js ----------
import { state } from '../engine/reactivity.js';
import { db } from './db.client.js';
import { onMounted, onUnmounted } from '../engine/component.js';

/**
 * @template T
 * @typedef {import('../engine/reactivity.js').ReactiveProxy<T>} ReactiveProxy
 */

/**
 * @typedef {ReactiveProxy<{data: any[], isLoading: boolean, error: Error | null}> & {
 * hydrate: (serverData: any[]) => Promise<void>,
 * put: (record: any) => Promise<void>,
 * destroy: (key: any) => Promise<void>
 * }} TableState
 */

/**
 * A composable for calling server-side actions on a component.
 * @param {string} actionName - The name of the action function to call.
 * @param {string} [componentName] - The name of the component where the action is defined.
 */
export function action(actionName, componentName) {
  if (typeof window === 'undefined')
    return { call: () => Promise.resolve(null), state: {} };

  /** @type {import('../engine/reactivity.js').ReactiveProxy<{data: any, error: Error | null, isLoading: boolean}>} */
  const s = state({ data: null, error: null, isLoading: false });

  /** @param {any[]} args */
  const call = async (...args) => {
    s.isLoading = true;
    s.error = null;
    s.data = null;
    try {
      const finalCompName =
        componentName ||
        /** @type {any} */ (window).__WEBS_STATE__?.componentName;
      const res = await fetch(`/__actions__/${finalCompName}/${actionName}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(args),
      });
      if (!res.ok)
        throw new Error((await res.text()) || `Action failed: ${res.status}`);
      s.data = await res.json();
    } catch (err) {
      s.error = err instanceof Error ? err : new Error(String(err));
    } finally {
      s.isLoading = false;
    }
  };
  return { call, state: s };
}

/**
 * A composable for interacting with a client-side database table.
 * @param {string} tableName - The name of the database table.
 * @param {any[]} [initialData=[]] - Optional initial data to populate the state.
 * @returns {TableState} A reactive state object with methods to interact with the table.
 */
export function table(tableName, initialData = []) {
  const tableDB = db(tableName);
  if (typeof window === 'undefined') {
    const mock = state({ data: initialData, isLoading: false, error: null });
    const mockWithMethods = /** @type {TableState} */ (
      /** @type {any} */ (mock)
    );
    mockWithMethods.hydrate = async () => {};
    mockWithMethods.put = async () => {};
    mockWithMethods.destroy = async () => {};
    return mockWithMethods;
  }

  const s = state({
    data: initialData || [],
    isLoading: true,
    error: /** @type {Error | null} */ (null),
  });

  const fetchData = async () => {
    try {
      s.isLoading = true;
      s.data = (await tableDB.getAll()) || [];
    } catch (e) {
      s.error = /** @type {Error} */ (e);
    } finally {
      s.isLoading = false;
    }
  };

  const unsubscribe = tableDB.subscribe(fetchData);
  onUnmounted(unsubscribe);

  const sWithMethods = /** @type {TableState} */ (/** @type {any} */ (s));

  /** @param {any[]} serverData */
  sWithMethods.hydrate = async (serverData) => {
    if (serverData && Array.isArray(serverData)) {
      await tableDB.bulkPut(serverData);
    }
    await fetchData();
  };

  sWithMethods.put = tableDB.put;
  sWithMethods.destroy = tableDB.delete;

  onMounted(async () => {
    if (!initialData || initialData.length === 0) {
      await fetchData();
    } else {
      s.isLoading = false;
    }
  });

  return sWithMethods;
}

---------- END: client/hooks.js ----------

---------- START: client/runtime.js ----------
export { createApp, hydrate, router, route } from '../engine/core.js';
export {
  state,
  ref,
  effect,
  computed,
  store,
  isRef,
  RAW_SYMBOL,
} from '../engine/reactivity.js';
export {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onUnmounted,
  onReady,
  onPropsReceived,
  provide,
  inject,
} from '../engine/component.js';
export {
  h,
  Text,
  Comment,
  Fragment,
  Teleport,
  createVnode,
} from '../engine/vdom.js';
export { compile, compileCache } from '../engine/compiler.js';

export { db } from './db.client.js';
export { fs } from './fs.client.js';
export { syncEngine } from './sync-engine.js';
export { session } from './session.js';
export { action, table } from './hooks.js';

export { ai, useAgent, useChat } from '../client/ai.client.js';

/**
 * @file Re-exports all public-facing APIs and type definitions for framework consumers.
 * This serves as the main entry point for the client-side bundle.
 */

/** JSDoc Type Definitions for consumers of the framework **/

/**
 * @template T
 * @typedef {import('../engine/reactivity.js').ReactiveProxy<T>} ReactiveProxy
 */
/** @typedef {import('./session.js').User} User */
/** @typedef {import('./session.js').SessionState} SessionState */
/** @typedef {import('./session.js').SessionGetters} SessionGetters */
/** @typedef {import('./session.js').SessionActions} SessionActions */
/** @typedef {import('./session.js').Session} Session */
/** @typedef {import('./hooks.js').TableState} TableState */
/** @typedef {import('./ai.client.js').UseChatReturn} UseChatReturn */
/** @typedef {import('./ai.client.js').UseAgentReturn} UseAgentReturn */
/** @typedef {import('./ai.client.js').ChatMessage} ChatMessage */
/** @typedef {import('./ai.client.js').ToolCall} ToolCall */
/** @typedef {import('./ai.client.js').Chat} Chat */
/** @typedef {import('./ai.client.js').SearchResult} SearchResult */
/** @typedef {import('./ai.client.js').SearchResultMetadata} SearchResultMetadata */
/** @typedef {import('./ai.client.js').AIModel} AIModel */
/** @typedef {import('./ai.client.js').AIModelService} AIModelService */
/** @typedef {import('./ai.client.js').AIService} AIService */

---------- END: client/runtime.js ----------

---------- START: client/service-worker.js ----------
/**
 * @file Service worker for caching application assets and enabling offline functionality.
 * @global
 * @property {boolean} IS_PROD - A global flag indicating if the environment is production.
 * @property {Array<{url: string}>} __WEBS_MANIFEST - A global variable injected by the build process, containing the list of assets to cache.
 */

/// <reference lib="WebWorker" />

/**
 * @typedef {ServiceWorkerGlobalScope & typeof globalThis & { IS_PROD: boolean; __WEBS_MANIFEST: Array<{url: string}>}} ServiceWorkerWithCustomGlobals
 */

const sw = /** @type {ServiceWorkerWithCustomGlobals} */ (
  /** @type {unknown} */ (self)
);

const CACHE_NAME = 'webs-cache-v1';

const APP_SHELL_URL = '/';

const fullManifest = sw.__WEBS_MANIFEST || [];

const assetUrls = fullManifest
  .filter((entry) => entry.url.includes('.'))
  .map((entry) => entry.url);

const urlsToCache = [APP_SHELL_URL, ...assetUrls];

sw.addEventListener('install', (event) => {
  if (typeof sw.IS_PROD !== 'undefined' && !sw.IS_PROD) {
    console.log('[SW] Development mode: skipping caching on install.');
    return event.waitUntil(sw.skipWaiting());
  }

  console.log('[SW] Production mode: Caching app shell and assets on install.');
  event.waitUntil(
    caches
      .open(CACHE_NAME)
      .then((cache) => {
        console.log('[SW] Caching:', urlsToCache);
        return cache.addAll(urlsToCache);
      })
      .then(() => sw.skipWaiting()),
  );
});

sw.addEventListener('activate', (event) => {
  console.log('[SW] Activating new service worker...');
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((name) => name !== CACHE_NAME)
            .map((name) => {
              console.log(`[SW] Deleting old cache: ${name}`);
              return caches.delete(name);
            }),
        );
      })
      .then(() => sw.clients.claim()),
  );
});

sw.addEventListener('fetch', (event) => {
  if (typeof sw.IS_PROD !== 'undefined' && !sw.IS_PROD) {
    return;
  }

  const { request } = event;
  const url = new URL(request.url);

  if (request.method !== 'GET' || url.origin !== sw.location.origin) {
    return;
  }

  if (request.mode === 'navigate') {
    event.respondWith(
      fetch(request)
        .then((response) => {
          if (response.ok) {
            const resClone = response.clone();
            caches
              .open(CACHE_NAME)
              .then((cache) => cache.put(APP_SHELL_URL, resClone));
          }
          return response;
        })
        .catch(async () => {
          console.warn(
            '[SW] Network unavailable for navigation. Serving app shell from cache.',
          );
          const cachedResponse = await caches.match(APP_SHELL_URL);
          return (
            cachedResponse ||
            new Response('App shell not found in cache', { status: 404 })
          );
        }),
    );
    return;
  }

  event.respondWith(
    caches.open(CACHE_NAME).then(async (cache) => {
      const cachedResponse = await cache.match(request);

      const fetchedResponsePromise = fetch(request)
        .then((networkResponse) => {
          if (networkResponse.ok) {
            cache.put(request, networkResponse.clone());
          }
          return networkResponse;
        })
        .catch((err) => {
          console.warn(`[SW] Network request for ${request.url} failed.`, err);
          return (
            cachedResponse ||
            new Response('Network error', {
              status: 408,
              headers: { 'Content-Type': 'text/plain' },
            })
          );
        });

      return cachedResponse || fetchedResponsePromise;
    }),
  );
});

---------- END: client/service-worker.js ----------

---------- START: client/session.js ----------
import { store } from '../engine/reactivity.js';
import { createLogger } from '../shared/logger.js';

/**
 * @typedef {object} User
 * @property {number} id
 * @property {string} username
 * @property {string} email
 */

/**
 * @typedef {object} SessionState
 * @property {User | null} user
 * @property {string | null} error
 * @property {boolean} isReady
 */

/**
 * @typedef {object} SessionGetters
 * @property {() => boolean} isLoggedIn
 */

/**
 * @typedef {object} SessionActions
 * @property {(credentials: {email: string, username: string, password: string}) => Promise<void>} register
 * @property {(email: string, password: string) => Promise<User | undefined>} login
 * @property {() => Promise<void>} logout
 * @property {(user: User | null) => void} setUser
 */

/**
 * @typedef {import('../engine/reactivity.js').ReactiveProxy<SessionState> & SessionGetters & SessionActions} Session
 */

const sessionLogger = createLogger('[Session]');

/**
 * The session management object.
 * @type {Session}
 */
export const session = store({
  state: () => ({
    user: null,
    error: null,
    isReady: false,
  }),
  getters: {
    /**
     * @this {SessionState}
     * @returns {boolean}
     */
    isLoggedIn() {
      return !!this.user;
    },
  },
  actions: {
    /**
     * @this {SessionState}
     * @param {User | null} user
     */
    setUser(user) {
      this.user = user || null;
      this.isReady = true;
    },
    /**
     * @this {SessionState & SessionActions}
     * @param {{email: string, username: string, password: string}} credentials
     */
    async register({ email, username, password }) {
      this.error = null;
      try {
        const response = await fetch('/api/auth/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, username, password }),
        });
        if (!response.ok)
          throw new Error((await response.text()) || 'Registration failed');
      } catch (err) {
        this.error = /** @type {Error} */ (err).message;
        sessionLogger.error('Registration failed:', err);
        throw err;
      }
    },
    /**
     * @this {SessionState & SessionActions}
     * @param {string} email
     * @param {string} password
     * @returns {Promise<User | undefined>}
     */
    async login(email, password) {
      this.error = null;
      try {
        const response = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password }),
        });
        if (!response.ok)
          throw new Error((await response.text()) || 'Login failed');
        const userData = await response.json();
        this.user = userData;
        return userData;
      } catch (err) {
        this.error = /** @type {Error} */ (err).message;
        sessionLogger.error('Login failed:', err);
        throw err;
      }
    },
    /** @this {SessionState & SessionActions} */
    async logout() {
      try {
        await fetch('/api/auth/logout', { method: 'POST' });
        this.user = null;
        this.error = null;
      } catch (err) {
        sessionLogger.error('Logout failed:', err);
      }
    },
  },
});

---------- END: client/session.js ----------

---------- START: client/sync-engine.js ----------
/**
 * @file Manages data synchronization between the client and server using WebSockets.
 */

import { createLogger } from '../shared/logger.js';
import { effect } from '../engine/reactivity.js';
import { session } from './runtime.js';

/**
 * @typedef {object} SyncEngine
 * @property {(db: import('./db.client.js').coreDB) => void} init - Initializes the sync engine with a reference to the database module.
 * @property {() => void} start - Starts the sync engine, sets up listeners for online/offline events, and user authentication state.
 * @property {() => void} process - Manually triggers the outbox processing logic.
 * @property {(message: any) => void} send - Sends a message directly through the WebSocket connection, bypassing the outbox.
 * @property {(event: 'message', callback: (payload: any) => void) => () => void} addEventListener - Adds an event listener for sync engine events.
 */

const logger = createLogger('[Sync]');

/** @type {WebSocket | null} */
let socket = null;
/** @type {ReturnType<typeof setTimeout> | null} */
let reconnectTimeout = null;
/** @type {number} */
let reconnectAttempts = 0;
/** @type {boolean} */
let isProcessingOutbox = false;
/** @type {import('./db.client.js').coreDB | null} */
let dbModule = null;

/**
 * @internal
 * A lightweight event emitter for handling synchronization events within the engine.
 */
const eventEmitter = {
  /** @type {Map<string, Set<Function>>} */
  listeners: new Map(),
  /**
   * @param {string} event
   * @param {Function} callback
   * @returns {() => void} Unsubscribe function.
   */
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.add(callback);
      return () => eventListeners.delete(callback);
    }
    return () => {};
  },
  /**
   * @param {string} event
   * @param {any} data
   */
  emit(event, data) {
    this.listeners.get(event)?.forEach((cb) => cb(data));
  },
};

/**
 * @internal
 * Establishes a WebSocket connection to the sync server.
 */
function connectToSyncServer() {
  if (socket?.readyState === WebSocket.OPEN) {
    processOutbox();
    return;
  }
  if (typeof navigator !== 'undefined' && !navigator.onLine) {
    logger.log('Offline, cannot connect to sync server.');
    return;
  }
  if (reconnectTimeout) clearTimeout(reconnectTimeout);

  logger.log('Attempting to connect to sync server...');
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const url = `${protocol}//${window.location.host}/api/sync`;
  socket = new WebSocket(url);

  socket.onopen = () => {
    logger.log('Sync server connection established.');
    reconnectAttempts = 0;
    processOutbox();
  };

  socket.onmessage = async (event) => {
    const payload = JSON.parse(event.data);
    logger.debug('Received message from sync server:', payload);
    eventEmitter.emit('message', payload);
    if (payload.type === 'sync' && dbModule) {
      await dbModule.handleSyncMessage(payload.data);
    } else if (payload.type === 'ack' || payload.type === 'sync-error') {
      if (payload.type === 'sync-error') {
        logger.error('Sync error from server:', payload);
      }
      if (dbModule) {
        await dbModule.transaction(
          'outbox',
          'readwrite',
          (/** @type {IDBTransaction} */ tx) => {
            tx.objectStore('outbox').delete(payload.opId);
          },
        );
      }
      processOutbox();
    }
  };

  socket.onclose = (event) => {
    logger.warn('Sync server connection closed.', {
      code: event.code,
      reason: event.reason,
    });
    socket = null;
    if (event.code !== 1000) {
      reconnectAttempts++;
      const delay = Math.min(30000, 1000 * 2 ** reconnectAttempts);
      logger.log(`Will attempt to reconnect in ${delay}ms.`);
      reconnectTimeout = setTimeout(connectToSyncServer, delay);
    }
  };

  socket.onerror = (err) => {
    logger.error('Sync server connection error:', err);
    socket?.close();
  };
}

/**
 * @internal
 * Processes and sends pending operations from the 'outbox' object store.
 * @returns {Promise<void>}
 */
async function processOutbox() {
  if (isProcessingOutbox || socket?.readyState !== WebSocket.OPEN) {
    logger.debug('Skipping outbox processing.', {
      isProcessingOutbox,
      socketState: socket?.readyState,
    });
    return;
  }

  if (!dbModule) return;

  const db = await dbModule._getDB();
  if (!db) return;

  isProcessingOutbox = true;
  try {
    await dbModule.transaction(
      'outbox',
      'readonly',
      async (/** @type {IDBTransaction} */ tx) => {
        const store = tx.objectStore('outbox');
        const request = store.openCursor();

        return new Promise((resolve, reject) => {
          let itemSent = false;
          request.onsuccess = (/** @type {Event} */ e) => {
            const cursor = /** @type {any} */ (e.target).result;
            if (cursor && !itemSent) {
              itemSent = true;
              const op = cursor.value;
              logger.log('Processing and sending operation from outbox:', op);
              socket?.send(JSON.stringify(op));
            }
            resolve(undefined);
          };
          request.onerror = (/** @type {Event} */ e) =>
            reject(/** @type {any} */ (e.target).error);
        });
      },
    );
  } catch (err) {
    logger.error('Error processing outbox:', err);
  } finally {
    isProcessingOutbox = false;
  }
}

/**
 * The main sync engine API.
 * @type {SyncEngine}
 */
export const syncEngine = {
  /**
   * Initializes the sync engine with a reference to the database module.
   * @param {import('./db.client.js').coreDB} db - The core DB module.
   */
  init(db) {
    dbModule = db;
  },
  /**
   * Starts the sync engine, sets up listeners for online/offline events, and user authentication state.
   */
  start() {
    if (typeof window === 'undefined') return;

    effect(
      () => session.user,
      (
        /** @type {import('./runtime.js').User | null} */ newUser,
        /** @type {import('./runtime.js').User | null} */ oldUser,
      ) => {
        if (newUser && !oldUser) {
          logger.log('User logged in, starting sync engine.');
          connectToSyncServer();
        } else if (oldUser && !newUser) {
          logger.log('User logged out, stopping sync engine.');
          if (socket) {
            socket.close(1000, 'User logged out');
          }
        }
      },
    );

    window.addEventListener('online', () => {
      logger.log('Browser is online.');
      if (session.user) connectToSyncServer();
    });
    window.addEventListener('offline', () => {
      logger.log('Browser is offline.');
      if (socket) {
        socket.close(1000, 'Network offline');
      }
    });
  },
  /**
   * Manually triggers the outbox processing logic.
   */
  process: () => {
    setTimeout(() => {
      if (typeof navigator !== 'undefined' && navigator.onLine) processOutbox();
    }, 100);
  },
  /**
   * Sends a message directly through the WebSocket connection, bypassing the outbox.
   * @param {any} message - The message to send.
   */
  send: (message) => {
    if (socket?.readyState === WebSocket.OPEN)
      socket.send(JSON.stringify(message));
  },
  /**
   * Adds an event listener for sync engine events.
   * @param {'message'} event - The event to listen for.\
   * @param {(payload: any) => void} callback - The callback function.
   * @returns {() => void} An unsubscribe function.
   */
  addEventListener: (event, callback) => {
    return eventEmitter.on(event, callback);
  },
};

---------- END: client/sync-engine.js ----------

---------- START: engine/compiler.js ----------
/**
 * @file Type definitions for the compiler.
 */

/** @typedef {import('./vdom.js').VNode} VNode */
/** @typedef {import('./renderer.js').Component<any>} Component */
/** @typedef {import('./expression-evaluator.js').AstNode} JsAstNode */
/** @typedef {import('./template-parser.js').HtmlAstNode} HtmlAstNode */
/** @typedef {import('./template-parser.js').ElementNode} ElementNode */
/** @typedef {import('./template-parser.js').AttributeToken} AttributeToken */

/**
 * @typedef {object} ComponentOptions
 * @property {Record<string, Component>} [globalComponents]
 */

/**
 * @typedef {Window & { __WEBS_DEVELOPER__?: { events: { emit: (event: string, data: any) => void; } } }} DevtoolsWindow
 */

/**
 * Enum for intermediate AST node types used by the compiler.
 * @enum {number}
 */
export const NODE_TYPES = {
  ROOT: 0,
  ELEMENT: 1,
  COMPONENT: 2,
  TEXT: 3,
  INTERPOLATION: 4,
  COMMENT: 5,
  FRAGMENT: 6,
  IF: 7,
  FOR: 8,
  SLOT: 9,
  DYNAMIC_TEXT: 10,
};

/**
 * Enum for intermediate AST attribute types used by the compiler.
 * @enum {number}
 */
export const ATTR_TYPES = {
  STATIC: 10,
  DIRECTIVE: 11,
  EVENT_HANDLER: 12,
};

/**
 * @file Compiles component templates into optimized render functions.
 */

import { parseHtml } from './template-parser.js';
import { parseJs, tokenizeJs } from './expression-evaluator.js';
import * as VDOM from './vdom.js';
import { createLogger } from '../shared/logger.js';

/** @typedef {import('./expression-evaluator.js').JsToken} JsToken */
/** @typedef {import('./expression-evaluator.js').LiteralNode} LiteralNode */
/** @typedef {import('./expression-evaluator.js').IdentifierNode} IdentifierNode */
/** @typedef {import('./expression-evaluator.js').TemplateLiteralNode} TemplateLiteralNode */
/** @typedef {import('./expression-evaluator.js').ObjectExpressionNode} ObjectExpressionNode */
/** @typedef {import('./expression-evaluator.js').ArrayExpressionNode} ArrayExpressionNode */
/** @typedef {import('./expression-evaluator.js').BinaryExpressionNode} BinaryExpressionNode */
/** @typedef {import('./expression-evaluator.js').UnaryExpressionNode} UnaryExpressionNode */
/** @typedef {import('./expression-evaluator.js').MemberExpressionNode} MemberExpressionNode */
/** @typedef {import('./expression-evaluator.js').ComputedMemberExpressionNode} ComputedMemberExpressionNode */
/** @typedef {import('./expression-evaluator.js').CallExpressionNode} CallExpressionNode */
/** @typedef {import('./expression-evaluator.js').ConditionalExpressionNode} ConditionalExpressionNode */
/** @typedef {import('./expression-evaluator.js').AssignmentExpressionNode} AssignmentExpressionNode */
/** @typedef {import('./expression-evaluator.js').ArrowFunctionExpressionNode} ArrowFunctionExpressionNode */
/** @typedef {import('./template-parser.js').IfBlockNode} IfBlockNode */
/** @typedef {import('./template-parser.js').ElseIfBlockNode} ElseIfBlockNode */
/** @typedef {import('./template-parser.js').EachBlockNode} EachBlockNode */
/** @typedef {import('./template-parser.js').TextNode} TextNode */
/** @typedef {import('./template-parser.js').CommentNode} CommentNode */

/**
 * @internal
 * @type {DevtoolsWindow}
 */
const devtools =
  typeof window !== 'undefined' ? window : /** @type {DevtoolsWindow} */ ({});

const logger = createLogger('[Compiler]');

/**
 * @internal
 * Caches the result of a function that takes a string argument.
 * @param {(str: string) => string} fn The function to memoize.
 * @returns {(str: string) => string} The memoized function.
 */
const cacheStringFunction = (fn) => {
  const cache = Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

/**
 * @internal
 * Converts kebab-case to camelCase.
 * @type {(str: string) => string}
 */
const camelize = cacheStringFunction((str) => {
  /**
   * @param {string} _
   * @param {string} character
   */
  return str.replace(/-(\w)/g, (_, character) =>
    character ? character.toUpperCase() : '',
  );
});

/**
 * @internal
 * Generates the body of a render function from a transformed AST.
 * @param {any} ast The transformed Abstract Syntax Tree of the template.
 * @returns {{ fn: (_ctx: object) => VNode | null, source: string }} The generated render function and its source code.
 */
export function generateRenderFn(ast) {
  const ctx = {
    /** @type {Set<string>} */
    scope: new Set(),
    /** @param {JsAstNode | null} expr
     * @returns {string}
     */
    genExpr(expr) {
      if (!expr) return 'null';
      switch (expr.type) {
        case 'Identifier':
          return this.scope.has(/** @type {IdentifierNode} */ (expr).name)
            ? /** @type {IdentifierNode} */ (expr).name
            : `_ctx.${/** @type {IdentifierNode} */ (expr).name}`;
        case 'Literal':
          return JSON.stringify(/** @type {LiteralNode} */ (expr).value);
        case 'TemplateLiteral': {
          let code = '`';
          let i = 0;
          const templateNode = /** @type {TemplateLiteralNode} */ (expr);
          for (const quasi of templateNode.quasis) {
            code += quasi.value.raw.replace(/`/g, '\\`');
            if (!quasi.tail) {
              const expression = templateNode.expressions[i++];
              if (expression) {
                code += `\${${this.genExpr(expression)}}`;
              }
            }
          }
          code += '`';
          return code;
        }
        case 'ObjectExpression': {
          const props = /** @type {ObjectExpressionNode} */ (expr).properties
            .map((p) => {
              const key =
                p.key.type === 'Identifier'
                  ? `'${/** @type {IdentifierNode} */ (p.key).name}'`
                  : this.genExpr(p.key);
              const value = this.genExpr(p.value);
              return `${key}: ${value}`;
            })
            .join(',');
          return `{${props}}`;
        }
        case 'ArrayExpression': {
          return `[${
            /** @type {ArrayExpressionNode} */ (expr).elements
              .map((e) => this.genExpr(e))
              .join(',')
          }]`;
        }
        case 'BinaryExpression':
          const binaryNode = /** @type {BinaryExpressionNode} */ (expr);
          return `(${this.genExpr(binaryNode.left)} ${
            binaryNode.operator
          } ${this.genExpr(binaryNode.right)})`;
        case 'UnaryExpression':
          const unaryNode = /** @type {UnaryExpressionNode} */ (expr);
          return `${unaryNode.operator}${this.genExpr(unaryNode.argument)}`;
        case 'MemberExpression': {
          const memberNode = /** @type {MemberExpressionNode} */ (expr);
          const objectExpr = this.genExpr(memberNode.object);
          const propertyName = memberNode.property.name;
          return `(${objectExpr}?.${propertyName})`;
        }
        case 'ComputedMemberExpression':
          const computedNode = /** @type {ComputedMemberExpressionNode} */ (
            expr
          );
          return `${this.genExpr(computedNode.object)}[${this.genExpr(
            computedNode.property,
          )}]`;
        case 'CallExpression':
          const callNode = /** @type {CallExpressionNode} */ (expr);
          return `${this.genExpr(callNode.callee)}(${callNode.arguments
            .map((a) => this.genExpr(a))
            .join(',')})`;
        case 'ConditionalExpression':
          const conditionalNode = /** @type {ConditionalExpressionNode} */ (
            expr
          );
          return `(${this.genExpr(conditionalNode.test)} ? ${this.genExpr(
            conditionalNode.consequent,
          )} : ${this.genExpr(conditionalNode.alternate)})`;
        case 'AssignmentExpression':
          const assignmentNode = /** @type {AssignmentExpressionNode} */ (expr);
          return `(${this.genExpr(assignmentNode.left)} = ${this.genExpr(
            assignmentNode.right,
          )})`;
        default:
          return 'null';
      }
    },
    /** @param {any[]} props
     * @returns {string}
     */
    genProps(props) {
      /** @param {any} p */
      const genProp = (p) => {
        if (p.type === ATTR_TYPES.STATIC) {
          return `'${p.name}': ${JSON.stringify(p.value)}`;
        }
        if (p.type === ATTR_TYPES.DIRECTIVE)
          return `'${p.name}': ${this.genExpr(p.expression)}`;
        if (p.type === ATTR_TYPES.EVENT_HANDLER) {
          this.scope.add('$event');
          const exprCode = this.genExpr(p.expression);
          this.scope.delete('$event');

          let handlerBody = exprCode;
          if (p.expression && p.expression.type === 'Identifier') {
            handlerBody = `${exprCode}($event)`;
          }
          if (p.modifiers && p.modifiers.has('prevent')) {
            handlerBody = `$event.preventDefault(); ${handlerBody}`;
          }
          if (p.modifiers && p.modifiers.has('stop')) {
            handlerBody = `$event.stopPropagation(); ${handlerBody}`;
          }

          return `'${p.name}': ($event) => { ${handlerBody} }`;
        }
        return '';
      };
      return `{${props
        .map((p) => p && genProp(p))
        .filter(Boolean)
        .join(',')}}`;
    },
    /** @param {Record<string, any[]>} slots
     * @returns {string}
     */
    genSlots(slots) {
      const slotEntries = Object.entries(slots).map(([name, children]) => {
        return `'${name}': () => ${this.genChildren(children)}`;
      });
      return `{ ${slotEntries.join(', ')} }`;
    },
    /** @param {any[] | any} children
     * @returns {string}
     */
    genChildren(children) {
      if (!children || (Array.isArray(children) && children.length === 0)) {
        return '[]';
      }
      const childNodes = (Array.isArray(children) ? children : [children])
        .map((/** @type {HtmlAstNode} */ c) => this.genNode(c))
        .filter((c) => c && c !== 'null');

      if (childNodes.length === 0) return '[]';
      return `[${childNodes.join(',')}]`;
    },
    /** @param {any} node
     * @returns {string}
     */
    genNode(node) {
      if (!node) return 'null';

      switch (node.type) {
        case NODE_TYPES.ROOT: {
          const childrenCode = this.genChildren(node.children);
          if (!node.children || node.children.length === 0) return 'null';
          if (node.children.length === 1) {
            return this.genNode(node.children[0]);
          }
          return `_h(_Fragment, {}, ${childrenCode})`;
        }
        case NODE_TYPES.FRAGMENT:
          const fragmentChildren = (
            Array.isArray(node.children) ? node.children : [node.children]
          )
            .map((/** @type {HtmlAstNode} */ c) => this.genNode(c))
            .filter(Boolean);
          if (fragmentChildren.length === 0) return 'null';
          if (fragmentChildren.length === 1) return fragmentChildren[0];
          return `_h(_Fragment, {}, [${fragmentChildren.join(',')}])`;
        case NODE_TYPES.COMPONENT: {
          const slots = this.genSlots(node.slots);
          let componentAccess;
          if (node.isDynamic) {
            const dynamicNameExpr = this.genExpr(node.tagName);
            componentAccess = `_ctx[${dynamicNameExpr}]`;
          } else {
            componentAccess = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(node.tagName)
              ? `_ctx.${node.tagName}`
              : `_ctx['${node.tagName}']`;
          }

          return `_h(${componentAccess}, ${this.genProps(
            node.properties,
          )}, ${slots})`;
        }
        case NODE_TYPES.ELEMENT: {
          let props = this.genProps(node.properties);
          if (node.key) {
            const keyExpr = this.genExpr(node.key);
            if (props.length > 2) {
              props = `{ 'key': ${keyExpr}, ${props.slice(1, -1)} }`;
            } else {
              props = `{ 'key': ${keyExpr} }`;
            }
          }
          return `_h('${node.tagName}', ${props}, ${this.genChildren(
            node.children,
          )})`;
        }
        case NODE_TYPES.TEXT:
          return `_h(_Text, {}, ${JSON.stringify(node.value)})`;
        case NODE_TYPES.INTERPOLATION:
          return `_h(_Text, { 'w-dynamic': true }, String(${this.genExpr(
            node.expression,
          )}))`;
        case NODE_TYPES.COMMENT:
          return `_h(_Comment, {}, ${JSON.stringify(node.value)})`;
        case NODE_TYPES.SLOT: {
          const slotName = node.name || 'default';
          const fallbackContent = this.genChildren(node.children);
          const slotOutlet = `(_ctx.$slots && typeof _ctx.$slots['${slotName}'] === 'function' && _ctx.$slots['${slotName}']())`;
          const normalizedSlots = `(Array.isArray(${slotOutlet}) ? ${slotOutlet} : (${slotOutlet} ? [${slotOutlet}] : null))`;
          const finalChildren = `${normalizedSlots} || ${fallbackContent}`;

          return `_h(_Fragment, {}, ...(${finalChildren} || []))`;
        }
        case NODE_TYPES.IF: {
          /**
           * @param {any} branch
           * @param {number} index
           * @returns {string}
           */
          const genBranch = (branch, index) => {
            if (!branch) return 'null';
            const alternate = node.branches[index + 1]
              ? genBranch(node.branches[index + 1], index + 1)
              : 'null';
            return `(${this.genExpr(
              branch.condition,
            )}) ? ${this.genNode(branch.node)} : ${alternate}`;
          };
          return genBranch(node.branches[0], 0);
        }
        case NODE_TYPES.FOR: {
          const { source, value, key, keyName } = node;
          const params = key ? `(${value}, ${key})` : value;
          this.scope.add(value);
          if (key) this.scope.add(key);

          const childNode = this.genNode(node.children[0]);

          let childCode = childNode;
          if (keyName) {
            childCode = `(() => {
                const child = ${childNode};
                if (child && child.props) child.props.key = ${this.genExpr(
                  keyName,
                )};
                return child;
            })()`;
          }

          this.scope.delete(value);
          if (key) this.scope.delete(key);
          return `_h(_Fragment, {}, (${this.genExpr(
            source,
          )} || []).map(${params} => ${childCode}))`;
        }
        case NODE_TYPES.DYNAMIC_TEXT: {
          const childrenCode = this.genChildren(node.children);
          return `_h(_DynamicText, {}, ${childrenCode})`;
        }
      }
      return 'null';
    },
  };
  const functionBody = `
const { h: _h, Text: _Text, Fragment: _Fragment, Comment: _Comment, DynamicText: _DynamicText } = VDOM;
return ${ctx.genNode(ast) || 'null'};
`;
  try {
    logger.debug('Generated render function source:', functionBody);
    /** @type {(_ctx: object) => VNode | null} */
    const fn = new Function('VDOM', '_ctx', functionBody).bind(null, VDOM);
    return { fn, source: functionBody };
  } catch (e) {
    logger.error('Render function compilation error', e, functionBody);
    /** @type {() => VNode} */
    const errorFn = () =>
      VDOM.h(VDOM.Comment, {}, 'Render function compile error');
    return {
      fn: errorFn,
      source: `return VDOM.h(VDOM.Comment, {}, 'Render function compile error');`,
    };
  }
}

/** @type {Map<string, JsAstNode | null>} */
const parseExprCache = new Map();

export class Compiler {
  /**
   * @param {Component} componentDef
   * @param {ComponentOptions | null} options
   */
  constructor(componentDef, options = null) {
    this.definition = componentDef;
    /** @type {Map<string, string>} */
    this.componentNameMap = new Map();
    const allComponents = {
      ...(componentDef.components || {}),
      ...(options?.globalComponents || {}),
    };

    /** @param {Record<string, Component> | undefined} comps */
    const collectComponents = (comps) => {
      if (!comps) return;
      for (const key in comps) {
        const compDef = comps[key];
        if (compDef && typeof compDef === 'object') {
          this.componentNameMap.set(key.toLowerCase(), key);
          if (compDef.components) {
            collectComponents(compDef.components);
          }
        }
      }
    };

    collectComponents(allComponents);
    this.options = options;
  }

  /** @param {string} html */
  parseHtml(html) {
    logger.debug('Parsing HTML template:', html);
    const ast = parseHtml(html);
    logger.debug('Parsed HTML AST:', JSON.stringify(ast, null, 2));
    return ast;
  }

  compile() {
    logger.info(`Starting compilation for component: ${this.definition.name}`);
    const rawAst = this.parseHtml(
      /** @type {string} */ (this.definition.template),
    );
    const transformedAst = this._transformNode(rawAst);
    logger.debug('Transformed AST:', JSON.stringify(transformedAst, null, 2));
    const { fn, source } = generateRenderFn(transformedAst);
    logger.info('Compilation finished.');

    devtools?.__WEBS_DEVELOPER__?.events.emit('component:compiled', {
      name: this.definition.name,
      template: this.definition.template,
      source: source,
    });

    return fn;
  }

  /**
   * @param {string | null | undefined} str
   * @returns {JsAstNode | null}
   */
  _parseExpr(str) {
    if (str === null || str === undefined) return null;
    const cleanStr = String(str).replace(/\n/g, ' ').trim();
    if (!cleanStr) return null;
    if (parseExprCache.has(cleanStr)) {
      return parseExprCache.get(cleanStr) || null;
    }

    try {
      const ast = parseJs(tokenizeJs(cleanStr));
      parseExprCache.set(cleanStr, ast);
      return ast;
    } catch (e) {
      logger.error(`Expression parsing error for: \"${cleanStr}\"`, e);
      return null;
    }
  }

  /**
   * @param {HtmlAstNode[]} children
   * @returns {Record<string, any>}
   */
  _processSlots(children) {
    /** @type {Record<string, any>} */
    const slots = {};
    const defaultChildren = [];

    for (const child of children) {
      if (
        child.type === 'element' &&
        /** @type {ElementNode} */ (child).tagName === 'template'
      ) {
        const slotAttr = /** @type {ElementNode} */ (child).attributes.find(
          (/**@type {{name: string}}*/ a) => a.name.startsWith('#'),
        );
        if (slotAttr) {
          const slotName = slotAttr.name.substring(1) || 'default';
          slots[slotName] = this._transformChildren(child.children || []);
          continue;
        }
      }
      if (
        child.type === 'text' &&
        !(/** @type {TextNode} */ (child).content.trim())
      ) {
        continue;
      }
      defaultChildren.push(child);
    }

    if (defaultChildren.length > 0) {
      slots.default = this._transformChildren(defaultChildren);
    }

    return slots;
  }
  /**
   * @param {HtmlAstNode} node
   * @returns {any}
   */
  _transformNode(node) {
    switch (node.type) {
      case 'root':
        return {
          type: NODE_TYPES.ROOT,
          children: this._transformChildren(node.children || []),
        };
      case 'element':
        return this._transformElement(/** @type {ElementNode} */ (node));
      case 'text':
        return this._transformText(node);
      case 'comment':
        return {
          type: NODE_TYPES.COMMENT,
          value: /** @type {CommentNode} */ (node).content,
        };
      case 'ifBlock':
      case 'eachBlock':
        return this._transformBlock(node);
      default:
        return null;
    }
  }

  /**
   * @param {HtmlAstNode} node
   * @returns {any}
   */
  _transformText(node) {
    const text = /** @type {TextNode} */ (node).content;
    if (!text.includes('{{')) {
      return { type: NODE_TYPES.TEXT, value: text };
    }
    const mustacheRegex = /{{([^}]+)}}/g;
    const parts = [];
    let lastIndex = 0;
    let match;

    mustacheRegex.lastIndex = 0;
    while ((match = mustacheRegex.exec(text))) {
      if (match.index > lastIndex) {
        parts.push({
          type: NODE_TYPES.TEXT,
          value: text.substring(lastIndex, match.index),
        });
      }
      const expression = match[1]?.trim();
      if (expression) {
        parts.push({
          type: NODE_TYPES.INTERPOLATION,
          expression: this._parseExpr(expression),
        });
      }
      lastIndex = match.index + match[0].length;
    }

    if (lastIndex < text.length) {
      parts.push({ type: NODE_TYPES.TEXT, value: text.substring(lastIndex) });
    }

    return { type: NODE_TYPES.DYNAMIC_TEXT, children: parts };
  }

  /**
   * @param {HtmlAstNode[]} children
   * @returns {any[]}
   */
  _transformChildren(children) {
    const transformed = [];
    let i = 0;
    while (i < children.length) {
      const child = children[i];
      if (!child) {
        i++;
        continue;
      }
      if (child.type === 'ifBlock') {
        /** @type {{condition: JsAstNode | null, node: any}[]} */
        const branches = [];
        /** @type {HtmlAstNode | undefined} */
        let current = child;
        let nextIndex = i + 1;
        while (current) {
          if (current.type === 'ifBlock' || current.type === 'elseIfBlock') {
            branches.push({
              condition: this._parseExpr(
                /** @type {IfBlockNode | ElseIfBlockNode} */ (current).test,
              ),
              node: {
                type: NODE_TYPES.FRAGMENT,
                children: this._transformChildren(current.children || []),
              },
            });
          } else if (current.type === 'elseBlock') {
            branches.push({
              condition: this._parseExpr('true'),
              node: {
                type: NODE_TYPES.FRAGMENT,
                children: this._transformChildren(current.children || []),
              },
            });
          }

          const next = children[nextIndex];
          if (
            next &&
            (next.type === 'elseIfBlock' || next.type === 'elseBlock')
          ) {
            current = next;
            nextIndex++;
          } else {
            current = undefined;
          }
        }
        transformed.push({ type: NODE_TYPES.IF, branches });
        i = nextIndex;
        continue;
      }

      const transformedNode = this._transformNode(child);
      if (transformedNode) {
        transformed.push(transformedNode);
      }
      i++;
    }
    return transformed;
  }

  /**
   * @param {any} block
   * @returns {any}
   */
  _transformBlock(block) {
    if (block.type === 'eachBlock') {
      let itemStr = String(/** @type {EachBlockNode} */ (block).item).trim();
      let keyExpr = /** @type {EachBlockNode} */ (block).key;

      if (!keyExpr && itemStr.endsWith(')') && !itemStr.startsWith('(')) {
        const parenIndex = itemStr.lastIndexOf('(');
        if (parenIndex !== -1) {
          keyExpr = itemStr.substring(parenIndex + 1, itemStr.length - 1);
          itemStr = itemStr.substring(0, parenIndex).trim();
        }
      }

      const match = itemStr.match(/^\(?\s*(\w+)(?:\s*,\s*(\w+))?\s*\)?$/);

      if (!match) {
        logger.error('Invalid each block item syntax:', itemStr);
        return null;
      }

      const valueMatch = match[1];
      const keyMatch = match[2];

      if (!valueMatch) return null;

      return {
        type: NODE_TYPES.FOR,
        source: this._parseExpr(
          /** @type {EachBlockNode} */ (block).expression,
        ),
        value: valueMatch,
        key: keyMatch,
        keyName: this._parseExpr(keyExpr),
        children: this._transformChildren(block.children),
      };
    }
    return null;
  }

  /**
   * @param {ElementNode} el
   * @returns {any}
   */
  _transformElement(el) {
    if (el.tagName === 'slot') {
      const nameAttr = el.attributes.find(
        (/**@type {{name: string}}*/ a) => a.name === 'name',
      );
      return {
        type: NODE_TYPES.SLOT,
        name: nameAttr ? String(nameAttr.value) : 'default',
        children: this._transformChildren(el.children),
      };
    }

    return this._transformNativeElement(el);
  }

  /**
   * @param {ElementNode} el
   * @returns {any}
   */
  _transformNativeElement(el) {
    if (el.tagName === 'component') {
      const isAttr = el.attributes.find(
        (/**@type {{name: string}}*/ a) => a.name === ':is' || a.name === 'is',
      );
      if (isAttr && typeof isAttr.value === 'string') {
        return {
          type: NODE_TYPES.COMPONENT,
          tagName: this._parseExpr(isAttr.value),
          isDynamic: true,
          properties: this._processAttributes(
            el.attributes.filter(
              (/**@type {{name: string}}*/ a) =>
                a.name !== ':is' && a.name !== 'is',
            ),
          ),
          slots: this._processSlots(el.children),
        };
      }
    }

    const tagName = el.tagName;
    const registeredCompKey = this.componentNameMap.get(tagName.toLowerCase());
    const isComponent = !!registeredCompKey;

    if (isComponent) {
      return {
        type: NODE_TYPES.COMPONENT,
        tagName: registeredCompKey,
        properties: this._processAttributes(el.attributes),
        slots: this._processSlots(el.children),
      };
    } else {
      return {
        type: NODE_TYPES.ELEMENT,
        tagName: tagName,
        properties: this._processAttributes(el.attributes),
        children: this._transformChildren(el.children),
      };
    }
  }

  /**
   * @param {AttributeToken[]} attrs
   * @returns {any[]}
   */
  _processAttributes(attrs) {
    const properties = [];
    /** @type {Set<number>} */
    const consumedIndices = new Set();

    for (let i = 0; i < attrs.length; i++) {
      if (consumedIndices.has(i)) continue;

      const attr = attrs[i];
      if (!attr) continue;
      let name = attr.name;
      let value = attr.value;

      if (name === '@ref' && typeof value === 'string') {
        properties.push({
          type: ATTR_TYPES.DIRECTIVE,
          name: 'ref',
          expression: this._parseExpr(value),
        });
        continue;
      }

      if (name.startsWith('@') && !name.includes('.')) {
        let j = i + 1;
        while (
          j < attrs.length &&
          (attrs[j]?.name === 'prevent' || attrs[j]?.name === 'stop')
        ) {
          const modifierAttr = attrs[j];
          if (modifierAttr) {
            name += `.${modifierAttr.name}`;
            if (modifierAttr.value) {
              value = modifierAttr.value ?? value;
            }
            consumedIndices.add(j);
          }
          j++;
        }
      }

      if (name.startsWith('bind:') && typeof value === 'string') {
        const propToBind = name.split(':')[1];
        if (!propToBind) {
          continue;
        }

        properties.push({
          type: ATTR_TYPES.DIRECTIVE,
          name: propToBind.includes('-') ? propToBind : camelize(propToBind),
          expression: this._parseExpr(value),
        });

        const eventName = propToBind === 'value' ? 'onInput' : 'onChange';
        const valueAccessor = propToBind === 'value' ? 'value' : 'checked';

        properties.push({
          type: ATTR_TYPES.EVENT_HANDLER,
          name: eventName,
          expression: this._parseExpr(
            `${value} = $event.target.${valueAccessor}`,
          ),
        });
        continue;
      }

      if (name.startsWith('@') && typeof value === 'string') {
        const [eventName, ...modifiers] = name.slice(1).split('.');
        if (eventName) {
          const pascalEventName =
            eventName.charAt(0).toUpperCase() + eventName.slice(1);
          const prop = {
            type: ATTR_TYPES.EVENT_HANDLER,
            name: `on${pascalEventName}`,
            expression: this._parseExpr(value),
            modifiers: new Set(modifiers),
          };
          properties.push(prop);
        }
      } else if (name.startsWith(':') && typeof value === 'string') {
        const propName = name.substring(1);
        properties.push({
          type: ATTR_TYPES.DIRECTIVE,
          name: propName.includes('-') ? propName : camelize(propName),
          expression: this._parseExpr(value),
        });
      } else if (!name.startsWith('w-') && !name.startsWith('#')) {
        properties.push({ type: ATTR_TYPES.STATIC, name, value });
      }
    }
    return properties;
  }
}

/**
 * @internal
 * In-memory cache for compiled render functions.
 * @type {Map<string, (_ctx: object) => VNode | null>}
 */
export const compileCache = new Map();

/**
 * The main compile function. Takes a component definition and returns a render function.
 * Caches the result based on the component's name.
 * @param {Component} componentDef The component definition object.
 * @param {ComponentOptions | null} [options] Compiler options, such as global components.
 * @returns {(_ctx: object) => VNode | null} The compiled render function.
 */
export function compile(componentDef, options = null) {
  if (compileCache.has(componentDef.name)) {
    const cachedFn = compileCache.get(componentDef.name);
    logger.info(
      `Using cached render function for component: ${componentDef.name}`,
    );
    if (cachedFn) return cachedFn;
  }

  /** @type {(_ctx: object) => VNode | null} */
  let renderFn;
  if (typeof componentDef.render === 'function') {
    logger.info('Using provided render function.');
    renderFn = componentDef.render;
  } else {
    let templateContent = componentDef.template;
    if (typeof templateContent === 'function') {
      logger.info('Executing dynamic template function.');
      /**
       * A tagged template literal helper function.
       * @param {TemplateStringsArray} strings
       * @param {...any} values
       * @returns {string}
       */
      const html = (strings, ...values) =>
        strings.raw.reduce(
          (
            /** @type {string} */ acc,
            /** @type {string} */ str,
            /** @type {number} */ i,
          ) => acc + str + (values[i] || ''),
          '',
        );
      templateContent = /** @type {(h: typeof html) => string} */ (
        templateContent
      )(html);
    }

    if (typeof templateContent !== 'string') {
      logger.error('Component missing template', {
        componentName: componentDef.name,
      });
      renderFn = () => VDOM.h(VDOM.Comment, {}, 'Component missing template');
    } else {
      const finalComponentDef = { ...componentDef, template: templateContent };
      const compiler = new Compiler(finalComponentDef, options);
      const transformedAst = compiler._transformNode(
        compiler.parseHtml(finalComponentDef.template),
      );
      const { fn, source } = generateRenderFn(transformedAst);

      devtools?.__WEBS_DEVELOPER__?.events.emit('component:compiled', {
        name: finalComponentDef.name,
        template: finalComponentDef.template,
        source: source,
      });
      renderFn = fn;
    }
  }

  compileCache.set(componentDef.name, renderFn);
  return renderFn;
}

---------- END: engine/compiler.js ----------

---------- START: engine/component.js ----------
/**
 * @file Manages the component instance, its lifecycle hooks, and the provide/inject dependency injection system.
 * This is the heart of the framework's component model, defining how components are created, updated, and destroyed.
 */

import { VNode } from './vdom.js';
import { isRef, state } from './reactivity.js';
import { isObject, isFunction, normalizeClass } from '../shared/utils.js';
import { createLogger } from '../shared/logger.js';
import { compile } from './compiler.js';

/**
 * @typedef {import('./vdom.js').Slots} Slots
 * @typedef {import('./vdom.js').Props} Props
 * @typedef {import('../server/server.js').OpenHandler} OpenHandler
 * @typedef {import('../server/server.js').MessageHandler} MessageHandler
 * @typedef {import('../server/server.js').CloseHandler} CloseHandler
 * @typedef {import('../server/server.js').ErrorHandler} ErrorHandler
 */

/**
 * The signature for the `onPropsReceived` lifecycle hook callback.
 * It's called when a component receives new props, before it re-renders.
 * @callback PropsReceivedHook
 * @param {Readonly<Record<string, any>>} newProps - The new props object that the component is receiving.
 * @param {Readonly<Record<string, any>>} oldProps - The previous props object.
 * @returns {void}
 */

/**
 * Defines the context object provided to server-side route handlers (`post`, `patch`, etc.)
 * that are exported from a component file.
 * @typedef {object} RouteHandlerContext
 * @property {Request & { user?: any, db?: any, params?: any }} req - The standard Request object, augmented with user session data, the database instance, and URL parameters.
 * @property {import('bun:sqlite').Database} db - The server-side database instance.
 * @property {import('../server/authentication.js').UserInfo} user - The currently authenticated user, if any.
 * @property {Record<string, string>} params - An object containing URL parameters from a dynamic route (e.g., `{ id: '123' }` for a route like `/users/:id`).
 * @property {import('../server/fs.server.js').ServerFsApi} fs - The file system API, sandboxed to the current user's private storage.
 */

/**
 * A union type representing all possible lifecycle hook names.
 * @typedef {'onBeforeMount' | 'onMounted' | 'onBeforeUpdate' | 'onUpdated' | 'onUnmounted' | 'onReady' | 'onPropsReceived'} LifecycleHook
 */

/**
 * Represents the internal instance of a component at runtime. This object holds all the state,
 * props, and context necessary for the component to render and update. It is created by the
 * renderer for each component in the VDOM tree.
 * @template T
 * @typedef {object} ComponentInstance
 * @property {number} uid - A unique identifier for this specific component instance.
 * @property {VNode} vnode - The virtual node representing this component in the VDOM tree.
 * @property {Component<T>} type - The original component definition object (the export from the `.webs` file).
 * @property {Slots} slots - The slots passed to the component from its parent.
 * @property {Props} attrs - Fallthrough attributes: props passed to the component that were not declared in its `props` definition.
 * @property {import('./reactivity.js').ReactiveProxy<Props>} props - The reactive props object.
 * @property {object} ctx - The public context proxy exposed to the component's render function. It provides access to props, setup state, and globals.
 * @property {object} internalCtx - The internal state returned from the `setup` function. This is not directly exposed to the template.
 * @property {boolean} isMounted - A flag indicating if the component is currently mounted to the DOM.
 * @property {VNode | null} subTree - The root VNode of the component's rendered template.
 * @property {(() => void) | null} update - The reactive effect runner function that triggers component re-renders.
 * @property {((_ctx: object) => VNode | null) | null} render - The compiled render function for the component's template.
 * @property {AppContext} appContext - The application-level context, containing global components and providers.
 * @property {ComponentInstance<any> | null} parent - The parent component instance.
 * @property {Record<string | symbol, any>} provides - Values provided by this component for its descendants via the provide/inject mechanism.
 * @property {Record<LifecycleHook, Function[]>} hooks - A record of registered lifecycle hooks for this instance.
 * @property {Node | null} lastEl - The last DOM element in the component's rendered output, used as an anchor for fragments.
 */

/**
 * Defines the options for a single component prop.
 * @typedef {object} PropOptions
 * @property {any} [default] - The default value for the prop if it is not provided by the parent. Can be a value or a factory function.
 * @example
 * // In a component definition:
 * export const props = {
 * // A simple prop with a default value
 * variant: { default: 'primary' },
 * // A prop with a factory function for a default object
 * config: { default: () => ({ theme: 'dark' }) }
 * };
 */

/**
 * The context object passed to a component's `setup` function.
 * @typedef {object} SetupContext
 * @property {Readonly<Record<string, any>>} attrs - A non-reactive object of fallthrough attributes. These are attributes passed from the parent that are not declared as props.
 * @property {Readonly<Slots>} slots - An object representing the content passed into the component's slots from its parent.
 * @property {Readonly<Record<string, any>>} params - Route parameters from the URL if the component is rendered by the router.
 */

/**
 * The main definition object for a component. This is what you export from a `.webs` file's `<script>` block.
 * @template T
 * @typedef {object} Component
 * @property {string} name - The unique name of the component, automatically derived from its file path.
 * @property {Record<string, PropOptions>} [props] - An object defining the props the component accepts.
 * @property {(props: Readonly<Props>, context: SetupContext) => object | void} [setup] - The composition function where you define reactive state, computed properties, and lifecycle hooks.
 * @property {string | (() => string)} [template] - The HTML template for the component, injected by the compiler.
 * @property {() => VNode | null} [render] - An optional manual render function. If provided, it overrides the `template`.
 * @property {Record<string, Component<any>>} [components] - An object of components to be registered for local use within this component's template.
 * @property {Record<string, (context: object, ...args: any[]) => any>} [actions] - Server-side functions that can be called from the client using the `action()` composable.
 * @property {(context: RouteHandlerContext) => Promise<Response | object | void>} [post] - A server-side handler for POST requests to the component's route.
 * @property {(context: RouteHandlerContext) => Promise<Response | object | void>} [patch] - A server-side handler for PATCH requests.
 * @property {(context: RouteHandlerContext) => Promise<Response | object | void>} [put] - A server-side handler for PUT requests.
 * @property {(context: RouteHandlerContext) => Promise<Response | object | void>} [del] - A server-side handler for DELETE requests.
 * @property {OpenHandler} [onOpen] - A server-side handler for WebSocket open events.
 * @property {MessageHandler} [onMessage] - A server-side handler for WebSocket message events.
 * @property {CloseHandler} [onClose] - A server-side handler for WebSocket close events.
 * @property {ErrorHandler} [onError] - A server-side handler for WebSocket error events.
 */

/**
 * Represents the application-level context that is shared across all components in an app.
 * @typedef {object} AppContext
 * @property {Record<string, Component<any>>} [components] - Globally registered components.
 * @property {object} [globals] - Global properties accessible in all component templates.
 * @property {Record<string | symbol, any>} [provides] - Globally provided values for dependency injection.
 * @property {Record<string, any>} [params] - Route parameters from the current URL.
 * @property {(n1: VNode | null, n2: VNode | null, container: Element, anchor?: Node | null, parentComponent?: ComponentInstance<any> | null) => void} [patch] - The internal DOM patching function.
 * @property {(vnode: VNode, container: Element) => ComponentInstance<any> | undefined | null} [hydrate] - The internal hydration function.
 */

/**
 * @typedef {object} RendererOptions
 * @property {(tag: string) => Element} createElement
 * @property {(text: string) => globalThis.Text} createText
 * @property {(text: string) => globalThis.Comment} createComment
 * @property {(el: Element, text: string) => void} setElementText
 * @property {(child: Node, parent: Element, anchor?: Node | null) => void} insert
 * @property {(child: Node) => void} remove
 * @property {(el: Element, key: string, prevValue: any, nextValue: any) => void} patchProp
 * @property {(selector: string) => Element | null} querySelector
 */

/**
 * @template T
 * @typedef {object} Renderer
 * @property {(n1: VNode | null, n2: VNode | null, container: Element, anchor?: Node | null, parentComponent?: ComponentInstance<any> | null) => void} patch
 * @property {(vnode: VNode, container: Element) => ComponentInstance<any> | undefined | null} hydrate
 */

/**
 * @typedef {Window & { __WEBS_DEVELOPER__?: { events: { emit: (event: string, data: any) => void; } } }} DevtoolsWindow
 */

const logger = createLogger('[Component]');
let instanceIdCounter = 0;

/**
 * @internal
 * @type {ComponentInstance<any> | null}
 */
let currentInstance = null;

/**
 * @internal
 * @type {ComponentInstance<any>[]}
 */
const instanceStack = [];

/**
 * Provides a value that can be injected by any descendant component in the component tree.
 * This is useful for passing data down through multiple levels of components without prop drilling.
 * Must be called within a component's `setup` function.
 *
 * @param {string | symbol} key - The unique injection key. Can be a string or a Symbol.
 * @param {any} value - The value to provide. This can be any value, including reactive state.
 * @example
 * // In a parent component (e.g., TheApp.webs)
 * import { provide, state } from '@conradklek/webs';
 *
 * export function setup() {
 * const theme = state({ color: 'dark' });
 * provide('theme', theme);
 * }
 */
export function provide(key, value) {
  if (!currentInstance) return;

  if (currentInstance.provides === currentInstance.parent?.provides) {
    currentInstance.provides = Object.create(
      currentInstance.parent?.provides || null,
    );
  }
  currentInstance.provides[key] = value;
}

/**
 * Injects a value provided by an ancestor component.
 * Must be called within a component's `setup` function.
 *
 * @template T
 * @param {string | symbol} key - The injection key that matches the key used in `provide`.
 * @param {T} [defaultValue] - An optional default value to return if no matching key is found in the ancestor tree.
 * @returns {T | undefined} The injected value, or the default value if not found.
 * @example
 * // In a child component
 * import { inject } from '@conradklek/webs';
 *
 * export function setup() {
 * const theme = inject('theme'); // Injects the theme object from the parent
 * // Now `theme.value.color` can be used.
 *
 * // With a default value
 * const analyticsId = inject('analyticsId', 'default-id');
 * }
 */
export function inject(key, defaultValue) {
  if (!currentInstance) return defaultValue;

  /** @type {ComponentInstance<any> | null} */
  let instance = currentInstance;
  while (instance) {
    if (instance.provides && key in instance.provides) {
      return instance.provides[key];
    }
    instance = instance.parent;
  }

  return defaultValue;
}

/**
 * @internal
 * Sets the currently active component instance.
 * @param {ComponentInstance<any> | null} instance
 */
export function setCurrentInstance(instance) {
  currentInstance = instance;
}

/**
 * @internal
 * Pushes an instance onto the stack, making it the current instance.
 * @param {ComponentInstance<any>} instance
 */
export function pushInstance(instance) {
  instanceStack.push(instance);
  setCurrentInstance(instance);
}

/**
 * @internal
 * Pops an instance from the stack, restoring the previous instance as current.
 */
export function popInstance() {
  instanceStack.pop();
  setCurrentInstance(instanceStack[instanceStack.length - 1] || null);
}

/**
 * @internal
 * Generic factory function for creating lifecycle hook registration methods.
 * @param {LifecycleHook} name
 * @returns {(hook: Function) => void}
 */
function createLifecycleMethod(name) {
  return (hook) => {
    if (!currentInstance) return;
    const inst = currentInstance;
    if (!inst.hooks[name]) {
      inst.hooks[name] = [];
    }
    /** @type {Function[]} */ (inst.hooks[name]).push(hook);
  };
}

/**
 * Registers a callback to be executed right before the component is mounted to the DOM.
 * @param {() => void} hook - The callback function to execute.
 * @example
 * onBeforeMount(() => {
 * console.log('Component is about to be mounted!');
 * });
 */
export const onBeforeMount = createLifecycleMethod('onBeforeMount');

/**
 * Registers a callback to be executed after the component has been mounted to the DOM.
 * This is the ideal hook for performing DOM manipulations or fetching initial data.
 * @param {() => void} hook - The callback function to execute.
 * @example
 * onMounted(() => {
 * const element = document.getElementById('my-element');
 * console.log('Component has been mounted:', element);
 * });
 */
export const onMounted = createLifecycleMethod('onMounted');

/**
 * Registers a callback to be executed right before the component re-renders due to a reactive state change.
 * @param {() => void} hook - The callback function to execute.
 */
export const onBeforeUpdate = createLifecycleMethod('onBeforeUpdate');

/**
 * Registers a callback to be executed after the component has re-rendered.
 * @param {() => void} hook - The callback function to execute.
 */
export const onUpdated = createLifecycleMethod('onUpdated');

/**
 * Registers a callback to be executed right before the component is unmounted from the DOM.
 * This is the place to clean up subscriptions, timers, or event listeners.
 * @param {() => void} hook - The callback function to execute.
 * @example
 * onUnmounted(() => {
 * console.log('Cleaning up component...');
 * mySubscription.unsubscribe();
 * });
 */
export const onUnmounted = createLifecycleMethod('onUnmounted');

/**
 * Registers a callback to be executed after the component's `setup` function has completed,
 * but before any lifecycle hooks.
 * @param {() => void} hook - The callback function to execute.
 */
export const onReady = createLifecycleMethod('onReady');

/**
 * Registers a callback to be executed when the component receives new props.
 * @param {PropsReceivedHook} hook - The callback function, which receives new and old props.
 */
export const onPropsReceived = createLifecycleMethod('onPropsReceived');

/**
 * @internal
 * Merges props from a VNode with fallthrough attributes.
 * @param {Props} vnodeProps
 * @param {Props} fallthroughAttrs
 * @returns {Props}
 */
export function mergeProps(vnodeProps, fallthroughAttrs) {
  const merged = { ...vnodeProps };
  for (const key in fallthroughAttrs) {
    if (key === 'class' && fallthroughAttrs[key]) {
      merged.class = normalizeClass([vnodeProps.class, fallthroughAttrs.class]);
    } else if (key === 'style' && fallthroughAttrs[key]) {
      merged.style = {
        ...(isObject(vnodeProps.style) ? vnodeProps.style : {}),
        ...(isObject(fallthroughAttrs.style) ? fallthroughAttrs.style : {}),
      };
    } else if (!(key in merged)) {
      merged[key] = fallthroughAttrs[key];
    }
  }
  return merged;
}

/**
 * @internal
 * Recursively applies state from the server to the client-side state during hydration.
 * @param {object} targetState
 * @param {object} serverState
 */
export function applyServerState(targetState, serverState) {
  logger.debug('Applying server state...', {
    targetState: { ...targetState },
    serverState: { ...serverState },
  });
  if (!isObject(targetState) || !isObject(serverState)) return;

  for (const key in serverState) {
    if (!Object.prototype.hasOwnProperty.call(serverState, key)) continue;
    const serverVal = /** @type {any} */ (serverState)[key];
    const existing = /** @type {Record<string, any>} */ (targetState)[key];

    if (isRef(existing)) {
      if (existing.value !== serverVal) {
        logger.debug(`Updating ref for key: ${key}`, {
          from: existing.value,
          to: serverVal,
        });
        if (isObject(existing.value) && isObject(serverVal)) {
          applyServerState(existing.value, serverVal);
        } else {
          existing.value = serverVal;
        }
      }
    } else if (Array.isArray(existing) && Array.isArray(serverVal)) {
      logger.debug(`Updating array for key: ${key}`);
      existing.length = 0;
      existing.push(...serverVal);
    } else if (
      isObject(existing) &&
      isObject(serverVal) &&
      !Array.isArray(existing)
    ) {
      logger.debug(`Recursively applying state for key: ${key}`);
      applyServerState(existing, serverVal);
    } else {
      logger.debug(`Directly setting state for key: ${key}`);
      /** @type {any} */ (targetState)[key] = serverVal;
    }
  }
}

/**
 * @internal
 * Creates a component instance from a VNode.
 * @param {VNode} vnode
 * @param {ComponentInstance<any> | null} parent
 * @param {boolean} isSsr
 * @returns {ComponentInstance<any>}
 */
export function createComponent(vnode, parent, isSsr = false) {
  const parentAppContext = parent ? parent.appContext : {};
  const appContext = vnode.appContext || parentAppContext;
  if (!appContext.globals) appContext.globals = {};
  if (!appContext.provides) appContext.provides = {};

  if (isSsr) {
    logger.debug(
      `SSR: Creating component instance for <${/**@type {Component<any>}*/ (vnode.type).name}>`,
    );
  } else {
    logger.info(
      `Creating component instance for <${/**@type {Component<any>}*/ (vnode.type).name}>`,
    );
  }

  /** @type {ComponentInstance<any>} */
  const instance = {
    uid: instanceIdCounter++,
    vnode,
    type: /**@type {Component<any>}*/ (vnode.type),
    slots: /** @type {Slots} */ (vnode.children) || {},
    attrs: {},
    props: {},
    ctx: {},
    internalCtx: {},
    isMounted: false,
    subTree: null,
    update: null,
    render: null,
    appContext,
    parent,
    provides: parent
      ? parent.provides
      : Object.create(appContext.provides || null),
    hooks: {
      onBeforeMount: [],
      onMounted: [],
      onBeforeUpdate: [],
      onUpdated: [],
      onUnmounted: [],
      onReady: [],
      onPropsReceived: [],
    },
    lastEl: null,
  };

  const { props: propsOptions, setup } = instance.type;
  const vnodeProps = vnode.props || {};
  const resolvedProps = {};

  for (const key in vnodeProps) {
    if (
      propsOptions &&
      Object.prototype.hasOwnProperty.call(propsOptions, key)
    ) {
      /** @type {any} */ (resolvedProps)[key] = vnodeProps[key];
    } else {
      /** @type {any} */ (instance.attrs)[key] = vnodeProps[key];
    }
  }

  if (propsOptions) {
    for (const key in propsOptions) {
      if (!Object.prototype.hasOwnProperty.call(resolvedProps, key)) {
        const options = propsOptions[key];
        const def = options?.hasOwnProperty('default')
          ? options.default
          : undefined;
        /** @type {any} */ (resolvedProps)[key] = isFunction(def) ? def() : def;
      }
    }
  }

  instance.props = state(resolvedProps);

  let setupResult = {};
  if (setup) {
    const setupContext = {
      attrs: instance.attrs,
      slots: instance.slots,
      params: instance.appContext.params || {},
    };
    pushInstance(instance);
    setupResult = setup(instance.props, setupContext) || {};
    popInstance();
  }

  instance.internalCtx = setupResult;

  if (!isSsr) {
    const serverState = (vnode.props || {}).initialState || {};
    const stateForHydration = { ...instance.internalCtx, ...instance.props };
    applyServerState(stateForHydration, serverState);
  }

  instance.ctx = new Proxy(
    {},
    {
      has: (_, key) =>
        !!(
          (instance.internalCtx && key in instance.internalCtx) ||
          (instance.props && key in instance.props) ||
          key === '$attrs' ||
          key === '$slots' ||
          key === '$props' ||
          (instance.appContext.params && key === 'params') ||
          (instance.type.components && key in instance.type.components) ||
          (instance.appContext.components &&
            key in instance.appContext.components) ||
          (instance.appContext.globals && key in instance.appContext.globals)
        ),
      get: (_, key) => {
        if (instance.internalCtx && key in instance.internalCtx) {
          const val = /** @type {any} */ (instance.internalCtx)[key];
          return isRef(val) ? val.value : val;
        }
        if (instance.props && key in instance.props) {
          const val = /** @type {any} */ (instance.props)[key];
          return isRef(val) ? val.value : val;
        }

        if (instance.appContext.params && key === 'params') {
          return instance.appContext.params;
        }
        if (key === '$attrs') {
          return instance.attrs;
        }
        if (key === '$slots') {
          return instance.slots;
        }
        if (key === '$props') {
          return instance.props;
        }

        if (isSsr) {
          const allComponents = {
            ...(instance.type.components || {}),
            ...(instance.appContext.components || {}),
          };
          if (key in allComponents) {
            return allComponents[/** @type {string} */ (key)];
          }
        }

        if (instance.type.components && key in instance.type.components)
          return instance.type.components[/** @type {string} */ (key)];
        if (
          instance.appContext.components &&
          key in instance.appContext.components
        )
          return instance.appContext.components[/** @type {string} */ (key)];
        if (instance.appContext.globals && key in instance.appContext.globals)
          return /** @type {any} */ (instance.appContext.globals)[key];

        return undefined;
      },
      set: (_, key, value) => {
        if (isSsr) return false;
        if (instance.internalCtx && key in instance.internalCtx) {
          const s = /** @type {any} */ (instance.internalCtx)[key];
          if (isRef(s)) {
            s.value = value;
          } else {
            /** @type {any} */ (instance.internalCtx)[key] = value;
          }
          return true;
        }
        if (instance.props && key in instance.props) {
          logger.warn(
            `Attempted to mutate prop "${String(key)}". Props are readonly.`,
          );
        }
        return false;
      },
    },
  );

  instance.render = compile(instance.type, {
    globalComponents: instance.appContext.components,
  });

  return instance;
}

---------- END: engine/component.js ----------

---------- START: engine/core.js ----------
/**
 * @file Core application logic, including app creation, routing, and client-side hydration.
 */

import { createRenderer } from './renderer.js';
import { createVnode } from './vdom.js';
import { ref } from './reactivity.js';
import { createLogger } from '../shared/logger.js';
import { normalizeClass } from '../shared/utils.js';
import { initDevTools } from '../shared/devtools.js';
import { session } from '../client/runtime.js';
import { coreDB } from '../client/db.client.js';
import { syncEngine } from '../client/sync-engine.js';

/**
 * @typedef {import('./vdom.js').VNode} VNode
 * @typedef {import('./renderer.js').Component<any>} Component
 * @typedef {import('./component.js').ComponentInstance<any>} ComponentInstance
 * @typedef {import('./renderer.js').Renderer<any>} Renderer
 */
/**
 * @template T
 * @typedef {import('./reactivity.js').Ref<T>} Ref
 */

/**
 * @typedef {Element & { _vei?: Record<string, any> }} ElementWithVEI
 */

/**
 * @typedef {object} WebsState
 * @property {string} componentName
 * @property {string} [swPath]
 * @property {object} [user]
 * @property {object} [params]
 * @property {object} [componentState]
 * @property {object} [sourceToComponentMap]
 */

/**
 * @internal
 * @typedef {object} AppContext
 * @property {Record<string, Component>} components - Registered components.
 * @property {Record<string | symbol, any>} provides - Dependency injection container.
 * @property {Renderer['patch']} patch - The renderer's patch function.
 * @property {Renderer['hydrate']} hydrate - The renderer's hydrate function.
 * @property {object} params - Route parameters.
 * @property {object} [globals] - Global properties accessible in templates.
 */

/**
 * @internal
 * @typedef {object} App
 * @property {Component} _component - The root component definition.
 * @property {Element | null} _container - The root DOM container.
 * @property {VNode | null} _vnode - The root virtual node.
 * @property {AppContext} _context - The application context.
 * @property {(rootContainer: Element) => ComponentInstance | undefined | null} mount - Mounts the application.
 */

const logger = createLogger('[Core]');

/**
 * @internal
 * @type {App | null}
 * The singleton application instance.
 */
let appInstance = null;

/**
 * @internal
 * @type {Map<string, () => Promise<{default: Component}>> | null}
 * The manifest for dynamically loading components.
 */
let componentManifestInstance = null;

/**
 * @internal
 * @type {Map<string, any>}
 * Cache for pre-fetched page data during navigation.
 */
const prefetchCache = new Map();

/**
 * @internal
 * @type {object | null}
 * A map from source file paths to component names, used in development.
 */
let sourceToComponentMap = null;

/**
 * @description A reactive object representing the current route.
 * @type {Ref<{path: string}>}
 */
export const route = ref({ path: '/' });

/**
 * @internal
 * @description Handles the logic for client-side navigation, fetching data and patching the DOM.
 * @param {URL} url - The URL to navigate to.
 * @param {{isPopState?: boolean, fromClick?: boolean}} [options={}] - Navigation options.
 * @returns {Promise<void>}
 */
async function performNavigation(
  url,
  { isPopState = false, fromClick = false } = {},
) {
  logger.info(`Starting navigation to: ${url.href}`);
  try {
    let data;
    if (!isPopState && fromClick && prefetchCache.has(url.href)) {
      data = prefetchCache.get(url.href);
      prefetchCache.delete(url.href);
      logger.debug('Used prefetched data for navigation.');
    } else {
      logger.debug('Fetching navigation data from server... ');
      const response = await fetch(url.pathname + url.search, {
        headers: { 'X-Webs-Navigate': 'true' },
      });
      if (
        !response.ok ||
        !response.headers.get('content-type')?.includes('application/json')
      ) {
        logger.warn(
          'Navigation fetch failed or returned non-JSON. Full page reload.',
        );
        window.location.assign(url.href);
        return;
      }
      data = deserializeState(await response.json());
      logger.debug('Successfully fetched navigation data:', data);
    }

    if (!componentManifestInstance) {
      throw new Error('Component manifest not available.');
    }

    const { componentName } = data;
    const componentLoader = componentManifestInstance.get(componentName);

    if (!componentLoader) {
      logger.error(
        `Component loader for "${componentName}" not found. Full page reload.`,
      );
      window.location.assign(url.href);
      return;
    }

    const newComponentModule = await componentLoader();
    const newComponentDef = newComponentModule.default;

    if (!appInstance || !appInstance._vnode || !appInstance._container) {
      throw new Error('App instance is not properly initialized.');
    }

    const oldVnode = appInstance._vnode;
    const newProps = {
      params: data.params,
      initialState: data.componentState || {},
      user: data.user || null,
      path: url.pathname,
    };
    logger.debug('New props for component update:', newProps);

    appInstance._context.params = data.params;

    const newVnode = createVnode(newComponentDef, newProps);
    newVnode.appContext = appInstance._context;

    route.value.path = url.pathname;
    if (
      session &&
      typeof (/** @type {any} */ (session).setUser) === 'function'
    ) {
      /** @type {any} */ (session).setUser(data.user);
    }

    logger.info('Patching DOM with new component vnode...');
    appInstance._context.patch(
      oldVnode,
      newVnode,
      appInstance._container,
      null,
      null,
    );
    appInstance._vnode = newVnode;
    logger.info('DOM patching complete.');

    if (!isPopState) {
      window.history.pushState({}, '', url.href);
    }
    document.title = data.title;

    /** @type {any} */ (window).__WEBS_STATE__ = {
      componentName: data.componentName,
      swPath: data.swPath,
      user: data.user,
      params: data.params,
      componentState: data.componentState,
    };
    logger.debug(
      'Updated window.__WEBS_STATE__',
      /** @type {any} */ (window).__WEBS_STATE__,
    );
  } catch (err) {
    logger.error(
      'Error during client-side navigation, falling back to full page reload.',
      err,
    );
    window.location.assign(url.href);
  }
}

/**
 * @description Client-side router for programmatic navigation.
 */
export const router = {
  /**
   * @description Navigates to a new URL.
   * @param {string} href - The destination URL.
   * @param {boolean} [fromClick=false] - Indicates if the navigation was triggered by a user click.
   */
  push(href, fromClick = false) {
    logger.debug(
      `Router push called with href: ${href}, fromClick: ${fromClick}`,
    );
    const url = new URL(href, window.location.origin);
    if (url.origin !== window.location.origin) {
      logger.debug(
        `External URL detected, performing full page load to: ${href}`,
      );
      window.location.assign(href);
      return;
    }
    if (url.href !== window.location.href) {
      logger.debug(`Internal navigation to: ${url.href}`);
      performNavigation(url, { fromClick });
    } else {
      logger.debug('URL is the same, no navigation needed.');
    }
  },
};

/**
 * @description Creates an application instance. This is the main entry point for the framework.
 */
export const createApp = (() => {
  const renderer = createRenderer({
    createElement: (tag) => document.createElement(tag),
    createText: (text) => document.createTextNode(text),
    createComment: (text) => document.createComment(text),
    setElementText: (el, text) => {
      el.textContent = text;
    },
    insert: (child, parent, anchor = null) => {
      parent.insertBefore(child, anchor);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) parent.removeChild(child);
    },
    patchProp: (/** @type {ElementWithVEI} */ el, key, prevVal, nextVal) => {
      if (key === 'ref') {
        if (prevVal && typeof prevVal === 'object' && 'value' in prevVal) {
          prevVal.value = null;
        }
        if (nextVal && typeof nextVal === 'object' && 'value' in nextVal) {
          nextVal.value = el;
        }
        return;
      }

      if (/^on[A-Z]/.test(key)) {
        const eventName = key.slice(2).toLowerCase();
        let invokers = el._vei || (el._vei = {});
        let invoker = invokers[eventName];
        if (nextVal) {
          if (!invoker) {
            invoker = el._vei[eventName] = (
              /** @type {{ timeStamp: number; }} */ e,
            ) => {
              if (e.timeStamp < invoker.attached) return;
              if (Array.isArray(invoker.value)) {
                invoker.value.forEach((/** @type {(arg0: any) => void} */ fn) =>
                  fn(e),
                );
              } else {
                invoker.value(e);
              }
            };
            invoker.value = nextVal;
            invoker.attached = performance.now();
            el.addEventListener(eventName, invoker);
          } else {
            invoker.value = nextVal;
          }
        } else if (invoker) {
          el.removeEventListener(eventName, invoker);
          invokers[eventName] = undefined;
        }
      } else if (key === 'class') {
        const newClassName = normalizeClass(nextVal) || '';
        if (el.className !== newClassName) {
          el.className = newClassName;
        }
      } else if (key === 'style') {
        if (typeof nextVal === 'string') {
          /** @type {HTMLElement} */ (el).style.cssText = nextVal;
        } else if (nextVal && typeof nextVal === 'object') {
          for (const styleKey in nextVal) {
            /** @type {any} */ (/** @type {HTMLElement} */ (el).style)[
              styleKey
            ] = nextVal[styleKey];
          }
          if (prevVal && typeof prevVal === 'object') {
            for (const oldKey in prevVal) {
              if (!(oldKey in nextVal)) {
                /** @type {any} */ (/** @type {HTMLElement} */ (el).style)[
                  oldKey
                ] = '';
              }
            }
          }
        }
      } else if (
        key in el &&
        typeof (/** @type {any} */ (el)[key]) === 'boolean'
      ) {
        /** @type {any} */ (el)[key] = !!nextVal;
      } else if (key in el) {
        if (/** @type {any} */ (el)[key] !== nextVal)
          /** @type {any} */ (el)[key] = nextVal;
      } else {
        if (nextVal === true || nextVal === '') {
          el.setAttribute(key, '');
        } else if (nextVal == null || nextVal === false) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, String(nextVal));
        }
      }
    },
    querySelector: (selector) => document.querySelector(selector),
  });

  /**
   * @param {Component} rootComponent - The root component for the application.
   * @param {object} [rootProps={}] - Initial props for the root component.
   * @param {Record<string, Component>} [globalComponents={}] - Components to register globally.
   * @returns {App} The application instance.
   */
  return function createApp(
    rootComponent,
    rootProps = {},
    globalComponents = {},
  ) {
    /** @type {App} */
    const app = {
      _component: rootComponent,
      _container: null,
      _vnode: null,
      _context: {
        components: { ...rootComponent.components, ...globalComponents },
        provides: {},
        patch: renderer.patch,
        hydrate: renderer.hydrate,
        params: /** @type {any} */ (rootProps).params || {},
      },
      /**
       * @param {Element} rootContainer
       */
      mount(rootContainer) {
        logger.info('Mounting application...', {
          rootComponent: rootComponent.name,
          rootProps,
        });
        const vnode = createVnode(rootComponent, rootProps);
        vnode.appContext = app._context;
        app._vnode = vnode;
        app._container = rootContainer;
        const rootInstance = app._context.hydrate(vnode, rootContainer);
        if (rootInstance) {
          installNavigationHandler(app);
        }
        return rootInstance;
      },
    };
    appInstance = app;
    return app;
  };
})();

/**
 * @description Initializes the application on the client-side by hydrating server-rendered HTML.
 * @param {Map<string, () => Promise<{default: Component}>>} componentManifest - A map of component names to their async loaders.
 * @param {object | null} [dbConfig=null] - Database configuration.
 * @returns {Promise<void>}
 */
export async function hydrate(componentManifest, dbConfig = null) {
  logger.info('Starting client-side hydration... ');
  if (typeof window === 'undefined') {
    logger.info('Not in a browser environment. Aborting hydration.');
    return;
  }
  componentManifestInstance = componentManifest;

  /** @type {WebsState} */
  const websState = deserializeState(
    /** @type {any} */ (window).__WEBS_STATE__ || {},
  );
  logger.debug(
    'Initial __WEBS_STATE__ from server:',
    JSON.parse(JSON.stringify(websState)),
  );

  if (dbConfig) {
    logger.info('Database configuration found. Setting global DB config.');
    /** @type {any} */ (window).__WEBS_DB_CONFIG__ = dbConfig;
  } else {
    logger.info('No database configuration provided.');
  }

  if (websState.sourceToComponentMap) {
    sourceToComponentMap = websState.sourceToComponentMap;
    logger.debug(
      'Source-to-component mapping loaded from server state.',
      sourceToComponentMap,
    );
  }

  coreDB.setSyncEngine(syncEngine);
  syncEngine.init(coreDB);

  logger.info('Starting sync engine...');
  syncEngine.start();

  if ('serviceWorker' in navigator && websState.swPath) {
    logger.info(
      `Attempting to register service worker at: ${websState.swPath}`,
    );
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register(websState.swPath || '')
        .then((registration) => {
          logger.info(
            'Service Worker registered successfully with scope:',
            registration.scope,
          );
        })
        .catch((err) => {
          logger.error('Service Worker registration failed:', err);
        });
    });
  } else {
    logger.info('Service worker not supported or no swPath provided in state.');
  }

  const startHydrationProcess = async () => {
    const root = document.getElementById('root');
    if (!root) {
      logger.error('Root element #root not found. Aborting hydration.');
      return;
    }

    const { componentName, user = {}, params, componentState } = websState;
    if (!componentName) {
      logger.error(
        'No componentName found in __WEBS_STATE__. Aborting hydration.',
      );
      return;
    }

    const rootComponentLoader = componentManifest.get(componentName);

    if (!rootComponentLoader) {
      logger.error(
        `Could not find component loader for "${componentName}". This may be a bundling or routing error on the server.`,
      );
      return;
    }

    try {
      const rootModule = await rootComponentLoader();
      const rootComponent = rootModule.default;

      if (!rootComponent) {
        logger.error('Failed to load root component for hydration.');
        return;
      }

      const props = { params, initialState: componentState || {}, user };
      const rootVnode = createVnode(rootComponent, props);

      logger.info(
        'Creating app instance with props:',
        JSON.parse(JSON.stringify(props)),
      );

      const app = createApp(
        rootComponent,
        props,
        rootComponent.components || {},
      );
      app._vnode = rootVnode;
      app._container = root;

      app._context.hydrate(rootVnode, root);
      logger.info('App mounted successfully.');

      installNavigationHandler(app);

      if (/** @type {any} */ (window).__WEBS_DEVELOPER__) {
        initDevTools();
        /** @type {any} */ (window).__WEBS_DEVELOPER__.registerApp(appInstance);
      }
      if (
        session &&
        typeof (/** @type {any} */ (session).setUser) === 'function'
      ) {
        /** @type {any} */ (session).setUser(websState.user);
      }
      route.value.path = window.location.pathname;
    } catch (err) {
      logger.error('Failed to load components for hydration:', err);
    }
  };

  if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', startHydrationProcess);
  } else {
    setTimeout(startHydrationProcess, 0);
  }
}

/**
 * @internal
 * @description Sets up event listeners on the root container for client-side navigation.
 * @param {App} app - The application instance.
 */
function installNavigationHandler(app) {
  appInstance = app;

  /** @param {URL} url */
  const prefetch = async (url) => {
    const hasExtension = /\.[^/]+$/.test(url.pathname);
    if (hasExtension && !url.pathname.endsWith('.html')) return;

    if (prefetchCache.has(url.href)) return;
    const res = await fetch(url.pathname + url.search, {
      headers: { 'X-Webs-Navigate': 'true' },
    });
    if (
      res.ok &&
      res.headers.get('content-type')?.includes('application/json')
    ) {
      prefetchCache.set(url.href, deserializeState(await res.json()));
    }
  };

  const eventTarget = app._container;
  if (!eventTarget) return;

  eventTarget.addEventListener(
    'mouseover',
    /** @type {EventListener} */ (
      (e) => {
        const event = /** @type {MouseEvent} */ (e);
        if (!(event.target instanceof Element)) return;
        const link = event.target.closest('a');
        if (
          !link ||
          link.target ||
          link.hasAttribute('download') ||
          event.metaKey ||
          event.ctrlKey
        )
          return;
        const href = link.getAttribute('href');
        if (!href || href.startsWith('#')) return;
        const url = new URL(href, window.location.origin);
        if (url.origin === window.location.origin) prefetch(url);
      }
    ),
  );

  eventTarget.addEventListener(
    'click',
    /** @type {EventListener} */ (
      (e) => {
        const event = /** @type {MouseEvent} */ (e);
        if (!(event.target instanceof Element)) return;
        const link = event.target.closest('a');
        if (
          !link ||
          link.target ||
          link.hasAttribute('download') ||
          event.metaKey ||
          event.ctrlKey
        )
          return;
        const href = link.getAttribute('href');
        if (!href || href.startsWith('#')) return;

        event.preventDefault();
        router.push(href, true);
      }
    ),
  );

  window.addEventListener('popstate', () => {
    const url = new URL(window.location.href);
    performNavigation(url, { isPopState: true, fromClick: false });
  });
}

/**
 * @internal
 * @description Safely deserializes a value which may be a JSON string.
 * @param {any} input - The value to deserialize.
 * @returns {any} The deserialized object.
 */
function deserializeState(input) {
  try {
    if (typeof input === 'string') return JSON.parse(input);
    return input;
  } catch (e) {
    logger.error('Failed to deserialize state:', e);
    return input;
  }
}

---------- END: engine/core.js ----------

---------- START: engine/expression-evaluator.js ----------
/**
 * @file Type definitions for the expression evaluator.
 */

/**
 * @typedef {object} JsToken
 * @property {string} type - The type of the token (e.g., 'IDENTIFIER', 'NUMBER', 'OPERATOR').
 * @property {string | number} value - The raw value of the token.
 */

/**
 * @typedef {object} AstNode
 * @property {string} type - The type of the AST node (e.g., 'Literal', 'Identifier').
 */

/** @typedef {AstNode & { value: any }} LiteralNode */
/** @typedef {AstNode & { name: string }} IdentifierNode */
/** @typedef {AstNode & { quasis: {type: 'TemplateElement', value: {raw: string}, tail: boolean}[], expressions: AstNode[] }} TemplateLiteralNode */
/** @typedef {AstNode & { properties: {type: 'Property', key: AstNode, value: AstNode}[] }} ObjectExpressionNode */
/** @typedef {AstNode & { elements: AstNode[] }} ArrayExpressionNode */
/** @typedef {AstNode & { operator: string, left: AstNode, right: AstNode }} BinaryExpressionNode */
/** @typedef {AstNode & { operator: string, argument: AstNode }} UnaryExpressionNode */
/** @typedef {AstNode & { object: AstNode, property: IdentifierNode, optional: boolean }} MemberExpressionNode */
/** @typedef {AstNode & { object: AstNode, property: AstNode, optional: boolean, computed: true }} ComputedMemberExpressionNode */
/** @typedef {AstNode & { callee: AstNode, arguments: AstNode[], optional: boolean }} CallExpressionNode */
/** @typedef {AstNode & { test: AstNode, consequent: AstNode, alternate: AstNode }} ConditionalExpressionNode */
/** @typedef {AstNode & { left: AstNode, right: AstNode }} AssignmentExpressionNode */
/** @typedef {AstNode & { params: AstNode[], body: AstNode, expressions?: AstNode[] }} ArrowFunctionExpressionNode */
/** @typedef {AstNode & {}} EmptyParenthesesNode */

/**
 * @file A secure, non-evaluating JavaScript expression tokenizer and parser, designed for safely executing template logic.
 */

/** @type {Map<string, JsToken[]>} */
const jsTokenCache = new Map();

/** @type {Record<string, string>} */
const JS_ESCAPE_MAP = { n: '\n', t: '\t', r: '\r' };

/** @type {Record<string, string>} */
const JS_KEYWORDS = {
  true: 'BOOLEAN',
  false: 'BOOLEAN',
  null: 'NULL',
  undefined: 'UNDEFINED',
};

/** @param {string | undefined} c */
const jsIsWhitespace = (c) =>
  c === ' ' || c === '\n' || c === '\t' || c === '\r';
/** @param {string | undefined} c */
const isDigit = (c) => c !== undefined && c >= '0' && c <= '9';
/** @param {string | undefined} c */
const isIdentStart = (c) =>
  c !== undefined &&
  ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '$' || c === '_');
/** @param {string | undefined} c */
const isIdentPart = (c) => isIdentStart(c) || isDigit(c);

/**
 * Tokenizes a JavaScript expression string into an array of tokens.
 * Caches results for performance.
 * @param {string} expression - The JavaScript expression to tokenize.
 * @returns {JsToken[]} An array of tokens.
 */
export function tokenizeJs(expression) {
  if (jsTokenCache.has(expression)) {
    const cached = jsTokenCache.get(expression);
    if (cached) return cached;
  }

  const tokens = [];
  let i = 0;
  while (i < expression.length) {
    let char = expression[i];
    if (char === undefined) break;

    if (jsIsWhitespace(char)) {
      i++;
      continue;
    }

    if (char === '`') {
      i++;
      tokens.push({ type: 'BACKTICK', value: '`' });
      let currentQuasi = '';
      while (i < expression.length && expression[i] !== '`') {
        if (expression[i] === '$' && expression[i + 1] === '{') {
          if (currentQuasi) {
            tokens.push({ type: 'TEMPLATE_STRING', value: currentQuasi });
            currentQuasi = '';
          }
          i += 2;
          tokens.push({ type: 'TEMPLATE_EXPR_START', value: '${' });
          let braceCount = 1;
          const exprStart = i;
          while (i < expression.length && braceCount > 0) {
            const c = expression[i];
            if (c === '{') braceCount++;
            else if (c === '}') braceCount--;
            if (braceCount > 0) i++;
          }
          if (braceCount !== 0)
            throw new Error('Unmatched braces in template literal');
          const innerExpression = expression.substring(exprStart, i);
          tokens.push(...tokenizeJs(innerExpression || ''));
          tokens.push({ type: 'RBRACE', value: '}' });
          i++;
        } else {
          if (expression[i] === '\\') {
            const nextChar = expression[i + 1];
            currentQuasi += nextChar ? `\\${nextChar}` : `\\`;
            i += 2;
          } else {
            currentQuasi += expression[i];
            i++;
          }
        }
      }
      if (currentQuasi) {
        tokens.push({ type: 'TEMPLATE_STRING', value: currentQuasi });
      }
      if (i >= expression.length || expression[i] !== '`') {
        throw new Error('Unterminated template literal');
      }
      tokens.push({ type: 'BACKTICK', value: '`' });
      i++;
      continue;
    }

    if (isIdentStart(char)) {
      let ident = char;
      let nextChar = expression[++i];
      while (nextChar && isIdentPart(nextChar)) {
        ident += nextChar;
        nextChar = expression[++i];
      }
      const keywordType = /** @type {string | undefined} */ (
        JS_KEYWORDS[ident]
      );
      tokens.push({ type: keywordType || 'IDENTIFIER', value: ident });
      continue;
    }

    if (isDigit(char)) {
      let numStr = char;
      let nextChar = expression[++i];
      while (nextChar && (isDigit(nextChar) || nextChar === '.')) {
        numStr += nextChar;
        nextChar = expression[++i];
      }
      tokens.push({ type: 'NUMBER', value: parseFloat(numStr) });
      continue;
    }

    if (char === "'" || char === '"') {
      const quote = char;
      let value = '';
      i++;
      while (i < expression.length && expression[i] !== quote) {
        let c = expression[i++];
        if (c === '\\' && i < expression.length) {
          const nextChar = expression[i];
          if (nextChar) {
            const escaped = JS_ESCAPE_MAP[nextChar];
            value += escaped !== undefined ? escaped : nextChar;
          }
          i++;
        } else {
          value += c;
        }
      }
      i++;
      tokens.push({ type: 'STRING', value });
      continue;
    }

    const twoCharOp = expression.slice(i, i + 2);
    const threeCharOp = expression.slice(i, i + 3);

    if (threeCharOp === '===' || threeCharOp === '!==') {
      tokens.push({ type: 'OPERATOR', value: threeCharOp });
      i += 3;
      continue;
    }
    if (
      [
        '==',
        '!=',
        '<=',
        '>=',
        '&&',
        '||',
        '??',
        '?.',
        '=>',
        '++',
        '--',
      ].includes(twoCharOp)
    ) {
      tokens.push({
        type: twoCharOp === '=>' ? 'ARROW' : 'OPERATOR',
        value: twoCharOp,
      });
      i += 2;
      continue;
    }

    if (char && '()[]{},.:'.includes(char)) {
      /** @type {Record<string, string>} */
      const typeMap = {
        '(': 'LPAREN',
        ')': 'RPAREN',
        '[': 'LBRACKET',
        ']': 'RBRACKET',
        '{': 'LBRACE',
        '}': 'RBRACE',
        ',': 'COMMA',
        '.': 'DOT',
        ':': 'COLON',
      };
      const type = typeMap[char];
      if (type) {
        tokens.push({ type, value: char });
      }
      i++;
      continue;
    }

    if (char && '+-*/%<>&|!?='.includes(char)) {
      tokens.push({ type: char === '=' ? 'EQUALS' : 'OPERATOR', value: char });
      i++;
      continue;
    }

    throw new Error(
      `Tokenizer Error: Unrecognized character '${char}' at position ${i}`,
    );
  }

  jsTokenCache.set(expression, tokens);
  return tokens;
}

/**
 * Parses an array of JavaScript tokens into an Abstract Syntax Tree (AST).
 * @param {JsToken[]} tokens - The array of tokens from tokenizeJs.
 * @returns {AstNode} The root node of the generated AST.
 */
export function parseJs(tokens) {
  let i = 0;
  const peek = () => tokens[i];
  const consume = () => tokens[i++];

  /** @type {() => AstNode} */
  let parseAssignment;

  /** @returns {TemplateLiteralNode} */
  const parseTemplateLiteral = () => {
    consume();
    /** @type {{type: 'TemplateElement', value: {raw: string}, tail: boolean}[]} */
    const quasis = [];
    /** @type {AstNode[]} */
    const expressions = [];

    while (peek()?.type !== 'BACKTICK') {
      if (peek()?.type === 'TEMPLATE_STRING') {
        quasis.push({
          type: 'TemplateElement',
          value: { raw: /** @type {string} */ (consume()?.value) ?? '' },
          tail: false,
        });
      }
      if (peek()?.type === 'TEMPLATE_EXPR_START') {
        consume();
        expressions.push(parseAssignment());
        if (peek()?.type !== 'RBRACE')
          throw new Error("Expected '}' after template expression");
        consume();
      }
    }

    if (quasis.length === expressions.length) {
      quasis.push({ type: 'TemplateElement', value: { raw: '' }, tail: true });
    } else if (quasis.length > 0) {
      const lastQuasi = quasis[quasis.length - 1];
      if (lastQuasi) {
        lastQuasi.tail = true;
      }
    }

    if (!peek() || peek()?.type !== 'BACKTICK')
      throw new Error('Unterminated template literal');
    consume();

    return { type: 'TemplateLiteral', quasis, expressions };
  };

  /** @returns {AstNode} */
  const parsePrimary = () => {
    const token = peek();
    if (!token) throw new Error('Unexpected end of expression.');
    switch (token.type) {
      case 'NUMBER':
      case 'STRING':
        return /** @type {LiteralNode} */ ({
          type: 'Literal',
          value: consume()?.value ?? null,
        });
      case 'BOOLEAN':
        return /** @type {LiteralNode} */ ({
          type: 'Literal',
          value: consume()?.value === 'true',
        });
      case 'NULL':
      case 'UNDEFINED':
        consume();
        return /** @type {LiteralNode} */ ({ type: 'Literal', value: null });
      case 'IDENTIFIER':
        return /** @type {IdentifierNode} */ ({
          type: 'Identifier',
          name: /** @type {string} */ (consume()?.value) ?? '',
        });
      case 'LPAREN': {
        consume();
        if (peek()?.type === 'RPAREN') {
          consume();
          return /** @type {EmptyParenthesesNode} */ ({
            type: 'EmptyParentheses',
          });
        }
        const expr = parseAssignment();
        if (peek()?.type !== 'RPAREN') throw new Error("Expected ')'");
        consume();
        return expr;
      }
      case 'LBRACE':
        return parseObjectLiteral();
      case 'LBRACKET':
        return parseArrayLiteral();
      case 'BACKTICK':
        return parseTemplateLiteral();
      default:
        throw new Error(
          `Parser Error: Unexpected token ${token.type} with value ${token.value}`,
        );
    }
  };

  /** @returns {ObjectExpressionNode} */
  const parseObjectLiteral = () => {
    consume();
    /** @type {{type: 'Property', key: AstNode, value: AstNode}[]} */
    const properties = [];
    if (peek()?.type !== 'RBRACE') {
      do {
        const key = parsePrimary();
        if (key.type !== 'Identifier' && key.type !== 'Literal') {
          throw new Error('Invalid property key in object literal.');
        }
        if (peek()?.type !== 'COLON')
          throw new Error("Expected ':' after property key.");
        consume();
        const value = parseAssignment();
        properties.push({ type: 'Property', key, value });
      } while (peek()?.type === 'COMMA' && consume());
    }
    if (peek()?.type !== 'RBRACE')
      throw new Error("Expected '}' to close object literal.");
    consume();
    return { type: 'ObjectExpression', properties };
  };

  /** @returns {ArrayExpressionNode} */
  const parseArrayLiteral = () => {
    consume();
    const elements = [];
    if (peek()?.type !== 'RBRACKET') {
      do {
        elements.push(parseAssignment());
      } while (peek()?.type === 'COMMA' && consume());
    }
    if (peek()?.type !== 'RBRACKET')
      throw new Error("Expected ']' to close array literal.");
    consume();
    return { type: 'ArrayExpression', elements };
  };

  /** @returns {AstNode} */
  const parseAccessors = () => {
    let node = parsePrimary();
    while (peek()) {
      const currentToken = peek();
      if (!currentToken) break;
      if (currentToken.value === '.' || currentToken.value === '?.') {
        const optional = consume()?.value === '?.';
        const prop = consume();
        if (!prop || prop.type !== 'IDENTIFIER')
          throw new Error("Expected identifier after '.'");
        node = /** @type {MemberExpressionNode} */ ({
          type: 'MemberExpression',
          object: node,
          property: {
            type: 'Identifier',
            name: /** @type {string} */ (prop.value) ?? '',
          },
          optional: optional ?? false,
        });
      } else if (currentToken.type === 'LBRACKET') {
        consume();
        const prop = parseAssignment();
        if (peek()?.type !== 'RBRACKET') throw new Error("Expected ']'");
        consume();
        node = /** @type {ComputedMemberExpressionNode} */ ({
          type: 'ComputedMemberExpression',
          object: node,
          property: prop,
          optional: false,
          computed: true,
        });
      } else if (currentToken.type === 'LPAREN') {
        consume();
        const args = [];
        if (peek()?.type !== 'RPAREN') {
          do {
            args.push(parseAssignment());
          } while (peek()?.type === 'COMMA' && consume());
        }
        if (peek()?.type !== 'RPAREN') throw new Error("Expected ')'");
        consume();
        const isOptional =
          node.type === 'MemberExpression' &&
          /** @type {MemberExpressionNode} */ (node).optional;
        node = /** @type {CallExpressionNode} */ ({
          type: 'CallExpression',
          callee: node,
          arguments: args,
          optional: isOptional,
        });
      } else {
        break;
      }
    }
    return node;
  };

  /** @returns {AstNode} */
  const parseUnary = () => {
    const currentToken = peek();
    if (
      currentToken?.type === 'OPERATOR' &&
      (currentToken.value === '!' || currentToken.value === '-')
    ) {
      const op = consume()?.value;
      if (typeof op !== 'string') {
        throw new Error('Expected unary operator');
      }
      return /** @type {UnaryExpressionNode} */ ({
        type: 'UnaryExpression',
        operator: op,
        argument: parseUnary(),
      });
    }
    return parseAccessors();
  };

  /**
   * @param {() => AstNode} nextParser
   * @param {string[]} operators
   * @returns {() => AstNode}
   */
  const buildBinaryParser = (nextParser, operators) => () => {
    let left = nextParser();
    let currentToken = peek();
    while (
      currentToken &&
      typeof currentToken.value === 'string' &&
      operators.includes(currentToken.value)
    ) {
      const op = consume()?.value;
      if (typeof op !== 'string') {
        throw new Error('Expected binary operator');
      }
      const right = nextParser();
      left = /** @type {BinaryExpressionNode} */ ({
        type: 'BinaryExpression',
        operator: op,
        left,
        right,
      });
      currentToken = peek();
    }
    return left;
  };

  const parseMultiplicative = buildBinaryParser(parseUnary, ['*', '/', '%']);
  const parseAdditive = buildBinaryParser(parseMultiplicative, ['+', '-']);
  const parseComparison = buildBinaryParser(parseAdditive, [
    '<',
    '>',
    '<=',
    '>=',
  ]);
  const parseEquality = buildBinaryParser(parseComparison, [
    '==',
    '!=',
    '===',
    '!==',
  ]);
  const parseLogicalAnd = buildBinaryParser(parseEquality, ['&&']);
  const parseLogicalOr = buildBinaryParser(parseLogicalAnd, ['||']);
  const parseNullishCoalescing = buildBinaryParser(parseLogicalOr, ['??']);

  /** @returns {AstNode} */
  const parseConditional = () => {
    const test = parseNullishCoalescing();
    if (peek()?.value === '?') {
      consume();
      const consequent = parseAssignment();
      if (peek()?.type !== 'COLON')
        throw new Error("Expected ':' for ternary operator.");
      consume();
      const alternate = parseAssignment();
      return /** @type {ConditionalExpressionNode} */ ({
        type: 'ConditionalExpression',
        test,
        consequent,
        alternate,
      });
    }
    return test;
  };

  /** @returns {AstNode} */
  const parseArrow = () => {
    const left = parseConditional();
    if (peek()?.type === 'ARROW') {
      consume();
      /** @type {AstNode[]} */
      const params =
        left.type === 'Identifier'
          ? [left]
          : left.type === 'EmptyParentheses'
            ? []
            : /** @type {ArrowFunctionExpressionNode} */ (left).expressions ||
              [];
      if (!Array.isArray(params))
        throw new Error('Invalid arrow function parameters.');
      return /** @type {ArrowFunctionExpressionNode} */ ({
        type: 'ArrowFunctionExpression',
        params,
        body: parseAssignment(),
      });
    }
    return left;
  };

  parseAssignment = () => {
    const left = parseArrow();
    if (peek()?.type === 'EQUALS') {
      consume();
      if (
        left.type !== 'Identifier' &&
        left.type !== 'MemberExpression' &&
        left.type !== 'ComputedMemberExpression'
      ) {
        throw new Error('Invalid left-hand side in assignment expression.');
      }
      return /** @type {AssignmentExpressionNode} */ ({
        type: 'AssignmentExpression',
        left,
        right: parseAssignment(),
      });
    }
    return left;
  };

  const ast = parseAssignment();

  if (i < tokens.length) {
    const token = peek();
    if (token) {
      throw new Error(
        `Parser Error: Unexpected token '${token.value}' at end of expression.`,
      );
    }
  }

  return ast;
}

---------- END: engine/expression-evaluator.js ----------

---------- START: engine/reactivity.js ----------
/**
 * @file Manages the core reactivity system. This system is responsible for tracking dependencies
 * between state and effects (like rendering or computations), and automatically re-running the
 * effects when the state they depend on changes. This enables a declarative programming model
 * where the UI automatically updates in response to state modifications.
 */

import { isObject } from '../shared/utils.js';
import { createLogger } from '../shared/logger.js';

/**
 * A function that can be provided to an effect to control when it re-runs.
 * If a scheduler is present, the effect's `run` function will not be called directly. Instead,
 * the scheduler will be called, and it becomes the scheduler's responsibility to eventually
 * call the effect's `run` function.
 * @callback EffectScheduler
 * @param {() => void} run - The function that executes the effect.
 * @returns {void}
 * @example
 * // A simple scheduler that batches updates using the microtask queue.
 * const scheduler = (run) => Promise.resolve().then(run);
 * effect(() => { console.log(state.count) }, { scheduler });
 */

/**
 * Represents an operation that is tracked for reactive dependencies. When any of its
 * dependencies change, the effect can be re-run to produce an updated result. This is the
 * core unit of the reactivity system.
 * @typedef {object} ReactiveEffect
 * @property {Function} fn - The function to execute that contains reactive dependencies.
 * @property {EffectScheduler} [scheduler] - A custom scheduler to control the timing of re-runs.
 * @property {boolean} active - A flag indicating if the effect is currently active and tracking dependencies.
 * @property {Set<ReactiveEffect>[]} deps - A collection of dependency sets this effect is subscribed to.
 * @property {() => any} run - Executes the effect's function, gathering dependencies, and returning the result.
 * @property {() => void} stop - Deactivates the effect, severing its connections to all dependencies.
 */

/**
 * A reactive object that wraps a single value. The framework tracks access to the `.value`
 * property, allowing effects to re-run when it changes.
 * @template T
 * @typedef {object} Ref
 * @property {T} value - The reactive value. Accessing this property tracks the dependency, and setting it triggers updates.
 * @property {true} __is_ref - An internal flag to identify this object as a Ref.
 */

/**
 * A special type of Ref that is read-only and whose value is calculated by a getter function.
 * The value is cached and only re-computed when one of its underlying reactive dependencies changes.
 * @template T
 * @typedef {object} ComputedRef
 * @property {T} value - The read-only computed value. Accessing this tracks dependencies on the underlying state.
 * @property {true} __is_ref - An internal flag to identify this object as a Ref.
 * @property {true} __is_computed - An internal flag to identify this object as a computed property.
 * @property {T} oldValue - The previous value of the computed property, accessible within watcher effects.
 */

/**
 * Represents an object or array that has been made fully reactive. Any access to its properties
 * (including nested properties) is tracked, and any mutation will trigger updates.
 * @template T
 * @typedef {T & {}} ReactiveProxy
 */

/**
 * The configuration object for creating a centralized `store`.
 * @template S The type of the state object.
 * @template G The type of the getters object.
 * @template A The type of the actions object.
 * @typedef {object} StoreOptions
 * @property {() => S} state - A function that returns the initial state object. Using a function ensures each store instance gets a fresh state object.
 * @property {G} [getters] - An object of functions that act as computed properties for the store. They receive the state as `this` and are read-only.
 * @property {A} [actions] - An object of functions that are used to modify the store's state. They also receive the state and other actions/getters as `this`.
 */

/**
 * Configuration options for creating an `effect`.
 * @typedef {object} EffectOptions
 * @property {EffectScheduler} [scheduler] - An optional scheduler function to control the timing of effect re-runs.
 */

/**
 * The type for a getter function used by a `computed` property.
 * @template T
 * @callback ComputedGetter
 * @returns {T} The calculated value.
 */

const logger = createLogger('[Reactivity]');

/**
 * @internal
 * @type {ReactiveEffect | null}
 */
let activeEffect = null;

/**
 * @internal
 * @type {ReactiveEffect[]}
 */
const effectStack = [];

/**
 * @internal
 * @type {WeakMap<object, Map<any, Set<ReactiveEffect>>>}
 */
const targetMap = new WeakMap();

/**
 * @internal
 * @type {WeakMap<object, any>}
 */
const proxyMap = new WeakMap();

/**
 * A symbol used to retrieve the original, raw (non-reactive) object from a reactive proxy.
 * This is useful for performance-critical code or when you need to pass data to external
 * libraries that shouldn't trigger reactive updates.
 * @type {symbol}
 * @example
 * const user = state({ name: 'webs' });
 * const rawUser = user[RAW_SYMBOL]; // rawUser is the original { name: 'webs' } object
 * console.log(user.name); // Access is tracked
 * console.log(rawUser.name); // Access is NOT tracked
 */
export const RAW_SYMBOL = Symbol('raw');

/**
 * @internal
 * @param {object} target
 * @param {string | symbol | number} key
 */
function track(target, key) {
  if (activeEffect) {
    logger.debug(`Tracking dependency for key: "${String(key)}"`);
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      depsMap = new Map();
      targetMap.set(target, depsMap);
      logger.debug(`- Created new dependency map for target:`, target);
    }
    let dep = depsMap.get(key);
    if (!dep) {
      dep = new Set();
      depsMap.set(key, dep);
      logger.debug(`- Created new dependency set for key: "${String(key)}"`);
    }
    dep.add(/** @type {ReactiveEffect} */ (activeEffect));
    /** @type {ReactiveEffect} */ (activeEffect).deps.push(dep);
    logger.debug(`- Added effect to dependency set for key: "${String(key)}"`);
  }
}

/**
 * @internal
 * @param {object} target
 * @param {string | symbol | number} key
 */
function trigger(target, key) {
  logger.debug(`Triggering effects for key: "${String(key)}"`);
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    logger.debug('- No dependency map found, skipping trigger.');
    return;
  }

  const effectsToRun = new Set();
  const dep = depsMap.get(key);
  if (dep) {
    logger.debug('- Found direct dependencies.');
    dep.forEach((effect) => effectsToRun.add(effect));
  }

  if (Array.isArray(target) && key === 'length') {
    logger.debug(
      '- Array length change detected, checking for out-of-bounds dependencies.',
    );
    depsMap.forEach((dep, depKey) => {
      if (typeof depKey === 'number' && depKey >= target.length) {
        dep.forEach((effect) => effectsToRun.add(effect));
      }
    });
  }

  if (effectsToRun.size > 0) {
    logger.info(`Running ${effectsToRun.size} effects.`);
  }

  effectsToRun.forEach((effect) => {
    if (effect.scheduler) {
      logger.debug('Executing scheduler for effect:', effect);
      effect.scheduler(effect.run);
    } else {
      logger.debug('Running effect:', effect);
      effect.run();
    }
  });
}

/**
 * @internal
 * @param {ReactiveEffect} effect
 */
function cleanup(effect) {
  logger.debug('Cleaning up dependencies for effect:', effect);
  const { deps } = effect;
  for (let i = 0; i < deps.length; i++) {
    const dep = deps[i];
    if (dep) dep.delete(effect);
  }
  deps.length = 0;
  logger.debug('Cleanup complete.');
}

/**
 * Checks if a value is a ref.
 * @param {any} r - The value to check.
 * @returns {r is Ref<any>} `true` if the value is a ref, otherwise `false`.
 * @example
 * const count = ref(0);
 * const plain = { value: 0 };
 * isRef(count); // true
 * isRef(plain); // false
 */
export function isRef(r) {
  return !!(r && r.__is_ref === true);
}

/**
 * Creates a reactive reference (ref) which encapsulates a value.
 * This allows the framework's reactivity system to track dependencies and
 * trigger updates when the `.value` property is accessed or mutated.
 * Use `ref` for primitive values (string, number, boolean) that need to be reactive.
 * @template T
 * @param {T} value - The initial value.
 * @returns {Ref<T>} A reactive ref object.
 * @example
 * const count = ref(0);
 *
 * effect(() => {
 * // This effect will re-run whenever count.value changes.
 * console.log(`The count is: ${count.value}`);
 * });
 *
 * count.value++; // Logs: "The count is: 1"
 */
export function ref(value) {
  logger.debug('Creating new ref.');
  return createRef(value);
}

/**
 * @internal
 * @template T
 * @param {T} value
 * @returns {Ref<T>}
 */
function createRef(value) {
  const wrapper = {
    _value: value,
    __is_ref: /** @type {const} */ (true),
    get value() {
      track(this, 'value');
      return this._value;
    },
    set value(newValue) {
      if (newValue !== this._value) {
        this._value = newValue;
        trigger(this, 'value');
      }
    },
  };
  return wrapper;
}

/**
 * @internal
 * @template {object} T
 * @param {T} target
 * @returns {ReactiveProxy<T>}
 */
function reactive(target) {
  if (!isObject(target) && !Array.isArray(target)) return target;
  if (proxyMap.has(target)) return proxyMap.get(target);

  /** @type {ProxyHandler<any>} */
  let handlers;
  if (Array.isArray(target)) {
    handlers = arrayHandlers;
  } else if (target instanceof Map) {
    handlers = collectionHandlers.map;
  } else if (target instanceof Set) {
    handlers = collectionHandlers.set;
  } else {
    handlers = baseHandlers;
  }

  const proxy = new Proxy(target, handlers);
  proxyMap.set(target, proxy);
  logger.debug('Created new reactive proxy.', {
    originalTarget: target,
    proxy,
  });
  return proxy;
}

/**
 * Creates a reactive state object or ref.
 * If the initial value is an object or an array, it returns a deep reactive proxy.
 * If the initial value is a primitive, it returns a `ref`. This is the primary way
 * to declare reactive state in a component.
 * @template T
 * @param {T} initialValue - The initial state value.
 * @returns {T extends object ? ReactiveProxy<T> : Ref<T>} A reactive state container.
 * @example
 * // For primitives, returns a ref
 * const count = state(0);
 * count.value++;
 *
 * // For objects, returns a reactive proxy
 * const user = state({ name: 'webs', nested: { id: 1 } });
 * user.name = 'Gemini';
 * user.nested.id++; // nested properties are also reactive
 */
export function state(initialValue) {
  logger.debug('Creating new state object/ref.');
  if (isObject(initialValue) || Array.isArray(initialValue)) {
    return /** @type {T extends object ? ReactiveProxy<T> : Ref<T>} */ (
      reactive(initialValue)
    );
  }
  return /** @type {T extends object ? ReactiveProxy<T> : Ref<T>} */ (
    createRef(initialValue)
  );
}

/**
 * Creates a centralized state management store, ideal for sharing state across
 * multiple components without prop drilling. It combines state, computed getters, and
 * actions into a single reactive object.
 * @template {object} S
 * @template {Record<string, (...args: any[]) => any>} [G={}]
 * @template {Record<string, (...args: any[]) => any>} [A={}]
 * @param {StoreOptions<S, G, A>} options - The store configuration.
 * @returns {ReactiveProxy<S> & G & A} A reactive store instance.
 * @example
 * // In a central file, e.g., 'src/stores/counter.js'
 * export const counterStore = store({
 * state: () => ({
 * count: 0,
 * lastChanged: null
 * }),
 * getters: {
 * double() {
 * // `this` refers to the store's state
 * return this.count * 2;
 * }
 * },
 * actions: {
 * increment() {
 * // `this` can access state, other getters, and other actions
 * this.count++;
 * this.lastChanged = new Date();
 * },
 * add(amount) {
 * this.count += amount;
 * }
 * }
 * });
 *
 * // In a component:
 * // import { counterStore } from '../stores/counter.js';
 * counterStore.increment();
 * console.log(counterStore.double); // 2
 */
export function store(options) {
  const state = reactive(options.state());
  /** @type {Record<string | symbol, any>} */
  const methodsAndGetters = {};

  const proxy = new Proxy(state, {
    get(target, key, receiver) {
      if (key in methodsAndGetters) {
        return methodsAndGetters[key];
      }
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      if (key in methodsAndGetters) {
        logger.warn(
          `Attempted to overwrite store getter or action: "${String(key)}"`,
        );
        return false;
      }
      return Reflect.set(target, key, value, receiver);
    },
    has(target, key) {
      return key in methodsAndGetters || Reflect.has(target, key);
    },
    ownKeys(target) {
      return [...Reflect.ownKeys(target), ...Object.keys(methodsAndGetters)];
    },
    getOwnPropertyDescriptor(target, key) {
      if (key in methodsAndGetters) {
        return Object.getOwnPropertyDescriptor(methodsAndGetters, key);
      }
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
  });

  if (options.getters) {
    for (const key in options.getters) {
      const getterFn = options.getters[key];
      const computedFn = computed(() => getterFn?.call(proxy));
      Object.defineProperty(methodsAndGetters, key, {
        get: () => computedFn.value,
        enumerable: true,
        configurable: true,
      });
    }
  }

  if (options.actions) {
    for (const key in options.actions) {
      const actionFn = options.actions[key];
      methodsAndGetters[key] = actionFn?.bind(proxy);
    }
  }

  return /** @type {ReactiveProxy<S> & G & A} */ (proxy);
}

/**
 * @internal
 * @type {ProxyHandler<object>}
 */
const baseHandlers = {
  get(target, key, receiver) {
    if (key === RAW_SYMBOL) return target;
    const value = Reflect.get(target, key, receiver);
    track(target, key);
    const unwrapped = isRef(value) ? value.value : value;
    return isObject(unwrapped) || Array.isArray(unwrapped)
      ? reactive(unwrapped)
      : unwrapped;
  },
  set(target, key, value, receiver) {
    const oldValue = Reflect.get(target, key, receiver);
    const result = Reflect.set(target, key, value, receiver);
    if (oldValue !== value) {
      trigger(target, key);
    }
    return result;
  },
};

/**
 * @internal
 */
const arrayMutationMethods = new Set([
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse',
]);

/**
 * @internal
 * @type {ProxyHandler<any[]>}
 */
const arrayHandlers = {
  get(target, key, receiver) {
    if (key === RAW_SYMBOL) return target;

    if (typeof key === 'string' || typeof key === 'number') {
      track(target, key);
    }

    const value = Reflect.get(target, key, receiver);

    if (typeof value === 'function' && arrayMutationMethods.has(String(key))) {
      /**
       * @param {...any} args
       */
      return function (...args) {
        const result = /** @type {(...args: any[]) => any} */ (value).apply(
          target,
          args,
        );
        trigger(target, 'length');
        for (let i = 0; i < target.length; i++) {
          trigger(target, i);
        }
        return result;
      };
    }

    return isObject(value) || Array.isArray(value) ? reactive(value) : value;
  },
  set(target, key, value, receiver) {
    const oldValue = Reflect.get(target, key, receiver);
    const hadKey = Object.prototype.hasOwnProperty.call(target, key);
    const result = Reflect.set(target, key, value, receiver);

    if (!hadKey) {
      if (typeof key === 'string' && /^\d+$/.test(key)) {
        trigger(target, 'length');
      }
      trigger(target, key);
    } else if (oldValue !== value) {
      trigger(target, key);
    }
    return result;
  },
};

/**
 * @internal
 * @type {{map: ProxyHandler<Map<any, any>>, set: ProxyHandler<Set<any>>}}
 */
const collectionHandlers = {
  map: {
    get(target, key, _receiver) {
      if (key === RAW_SYMBOL) return target;
      if (key === 'size') {
        track(target, 'size');
        return Reflect.get(target, 'size', target);
      }

      const value = Reflect.get(target, key, target);

      if (typeof value === 'function') {
        switch (key) {
          case 'get':
            return (/** @type {any} */ k) => {
              track(target, k);
              const res = target.get(k);
              return isObject(res) ? reactive(res) : res;
            };
          case 'has':
            return (/** @type {any} */ k) => {
              track(target, k);
              return target.has(k);
            };
          case 'set':
            return (/** @type {any} */ k, /** @type {any} */ v) => {
              const had = target.has(k);
              const oldValue = target.get(k);
              const result = target.set(k, v);
              if (!had) {
                trigger(target, 'size');
              }
              if (!had || oldValue !== v) {
                trigger(target, k);
              }
              return result;
            };
          case 'delete':
            return (/** @type {any} */ k) => {
              const had = target.has(k);
              const result = target.delete(k);
              if (had) {
                trigger(target, 'size');
                trigger(target, k);
              }
              return result;
            };
          case 'clear':
            return () => {
              const hadItems = target.size > 0;
              const result = target.clear();
              if (hadItems) {
                trigger(target, 'size');
              }
              return result;
            };
          default:
            return value.bind(target);
        }
      }
      return value;
    },
    set: (target, key, value, receiver) => {
      return Reflect.set(target, key, value, receiver);
    },
  },
  set: {
    get(target, key) {
      if (key === RAW_SYMBOL) return target;
      if (key === 'size') {
        track(target, 'size');
        return Reflect.get(target, key, target);
      }

      const value = Reflect.get(target, key, target);
      if (typeof value === 'function') {
        switch (key) {
          case 'has':
            return (/** @type {any} */ v) => {
              track(target, v);
              return target.has(v);
            };
          case 'add':
            return (/** @type {any} */ v) => {
              const had = target.has(v);
              const result = target.add(v);
              if (!had) {
                trigger(target, 'size');
                trigger(target, v);
              }
              return result;
            };
          case 'delete':
            return (/** @type {any} */ v) => {
              const had = target.has(v);
              const result = target.delete(v);
              if (had) {
                trigger(target, 'size');
                trigger(target, v);
              }
              return result;
            };
          case 'clear':
            return () => {
              const hadItems = target.size > 0;
              const result = target.clear();
              if (hadItems) {
                trigger(target, 'size');
              }
              return result;
            };
          default:
            return value.bind(target);
        }
      }
      return value;
    },
    set: (target, key, value, receiver) => {
      return Reflect.set(target, key, value, receiver);
    },
  },
};

/**
 * @internal
 * @param {Function} fn
 * @param {EffectScheduler} [scheduler]
 * @returns {ReactiveEffect}
 */
function createReactiveEffect(fn, scheduler) {
  /** @type {ReactiveEffect} */
  const effect = {
    fn,
    scheduler,
    active: true,
    deps: [],
    run() {
      logger.debug('Running effect function...');
      if (!effect.active) {
        logger.debug('- Effect is inactive, skipping.');
        return effect.fn();
      }
      if (effectStack.includes(effect)) {
        logger.debug('- Effect already in stack, avoiding infinite loop.');
        return;
      }

      cleanup(effect);
      try {
        effectStack.push(effect);
        activeEffect = effect;
        const result = effect.fn();
        logger.debug('- Effect function completed.');
        return result;
      } finally {
        effectStack.pop();
        activeEffect = effectStack[effectStack.length - 1] || null;
        logger.debug('- Restored active effect from stack.');
      }
    },
    stop() {
      if (effect.active) {
        logger.info('Stopping effect...');
        cleanup(effect);
        effect.active = false;
        logger.info('Effect stopped successfully.');
      } else {
        logger.warn('Attempted to stop an inactive effect.');
      }
    },
  };
  return effect;
}

/**
 * Runs a function and reactively tracks its dependencies. When the dependencies change,
 * the function runs again. `effect` is the foundation for rendering, computed properties, and watchers.
 *
 * It has two main signatures:
 * 1. **Autorun:** Takes a single function that is run immediately and then again whenever its dependencies change.
 * 2. **Watcher:** Takes a source (getter function or reactive object) and a callback. The callback only runs when the source's value changes.
 *
 * @param {Function | Ref<any> | ReactiveProxy<any>} source - The function to run and track, or a reactive source to watch.
 * @param {Function} [callback] - The callback to run when the source changes. Receives `(newValue, oldValue)`.
 * @param {EffectOptions} [options] - Optional effect configuration.
 * @returns {() => void} A function that can be called to manually stop the effect.
 * @example
 * // 1. Autorun example (common for rendering logic)
 * const count = state(0);
 * effect(() => console.log(count.value)); // Logs 0, then logs again on every change to count.value
 * count.value++; // Logs 1
 *
 * // 2. Watcher example (for specific side effects)
 * const user = state({ name: 'Webs' });
 * effect(
 * () => user.name, // The source to watch
 * (newName, oldName) => { // The callback
 * console.log(`Name changed from ${oldName} to ${newName}`);
 * }
 * );
 * user.name = 'Gemini'; // Logs: "Name changed from Webs to Gemini"
 */
export function effect(source, callback, options) {
  logger.info('Creating new effect.');
  let runner;
  const isWatcher = typeof callback === 'function';

  if (isWatcher) {
    /** @type {any} */
    let oldValue;
    const getter = () => {
      return typeof source === 'function'
        ? source()
        : isRef(source)
          ? source.value
          : source;
    };

    const computedRef = computed(getter);

    runner = createReactiveEffect(() => {
      const newValue = computedRef.value;
      if (newValue !== oldValue) {
        logger.debug('Effect callback triggered due to value change.');
        callback(newValue, oldValue);
        oldValue = newValue;
      }
    }, options?.scheduler);
  } else {
    if (typeof source !== 'function') {
      logger.error(
        'Invalid source provided. effect with a single argument must be a function.',
      );
      throw new Error('effect with a single argument must be a function.');
    }
    const effectOptions = /** @type {EffectOptions | undefined} */ (callback);
    runner = createReactiveEffect(source, effectOptions?.scheduler);
  }
  runner.run();
  const stop = () => runner.stop();
  logger.info('Effect created and ran for the first time.');
  return stop;
}

/**
 * Creates a computed property that reactively calculates its value based on other
 * reactive state. The result is cached and only re-evaluated when its dependencies change.
 * @template T
 * @param {ComputedGetter<T>} getter - The function to compute the value.
 * @returns {ComputedRef<T>} A read-only ref whose value is the result of the getter.
 * @example
 * const count = ref(1);
 * const user = state({ firstName: 'John', lastName: 'Doe' });
 *
 * const double = computed(() => count.value * 2);
 * console.log(double.value); // 2
 *
 * const fullName = computed(() => `${user.firstName} ${user.lastName}`);
 * console.log(fullName.value); // "John Doe"
 *
 * user.firstName = 'Jane';
 * console.log(fullName.value); // "Jane Doe" (automatically updated)
 */
export function computed(getter) {
  logger.debug('Creating new computed property.');
  /** @type {any} */
  let computedValue;
  /** @type {any} */
  let oldValue;
  let isDirty = true;

  const scheduler = () => {
    if (!isDirty) {
      isDirty = true;
      trigger(computedRef, 'value');
      logger.debug('Scheduler: marked computed property as dirty.');
    }
  };

  const getterEffect = createReactiveEffect(getter, scheduler);

  const computedRef = {
    get value() {
      if (isDirty) {
        logger.debug('Computed property is dirty, recalculating value.');
        oldValue = computedValue;
        computedValue = getterEffect.run();
        isDirty = false;
      }
      track(computedRef, 'value');
      logger.debug(
        `Computed value accessed, tracking dependency. Current value: ${JSON.stringify(
          computedValue,
        )}`,
      );
      return computedValue;
    },
    get oldValue() {
      logger.debug(
        `Old computed value accessed. Old value: ${JSON.stringify(oldValue)}`,
      );
      return oldValue;
    },
    __is_ref: /** @type {const} */ (true),
    __is_computed: /** @type {const} */ (true),
  };
  logger.debug('Computed property created.');
  return /** @type {ComputedRef<any>} */ (/** @type {unknown} */ (computedRef));
}

---------- END: engine/reactivity.js ----------

---------- START: engine/renderer.js ----------
/**
 * @typedef {import('./vdom.js').VNode} VNode
 * @typedef {import('./vdom.js').Slots} Slots
 * @typedef {import('./vdom.js').Props} Props
 */

/**
 * A generic function type for lifecycle hooks.
 * @typedef {(...args: any[]) => void} Hook
 */

/**
 * @typedef {object} PropOptions
 * @property {any} [default] - The default value for the prop.
 */

/**
 * @typedef {object} SetupContext
 * @property {Readonly<Record<string, any>>} attrs
 * @property {Readonly<Slots>} slots
 * @property {Readonly<Record<string, any>>} params
 */

/**
 * @template T
 * @typedef {object} Component
 * @property {string} name
 * @property {Record<string, PropOptions>} [props]
 * @property {(props: Readonly<Props>, context: SetupContext) => object | void} [setup]
 * @property {string | (() => string)} [template]
 * @property {() => VNode | null} [render]
 * @property {Record<string, Component<any>>} [components]
 */

/**
 * @typedef {object} AppContext
 * @property {Record<string, Component<any>>} [components]
 * @property {object} [globals]
 * @property {Record<string | symbol, any>} [provides]
 * @property {Record<string, any>} [params]
 * @property {(n1: VNode | null, n2: VNode | null, container: Element, anchor?: Node | null, parentComponent?: any | null) => void} [patch]
 * @property {(vnode: VNode, container: Element) => any | undefined | null} [hydrate]
 */

/**
 * @typedef {object} RendererOptions
 * @property {(tag: string) => Element} createElement
 * @property {(text: string) => globalThis.Text} createText
 * @property {(text: string) => globalThis.Comment} createComment
 * @property {(el: Element, text: string) => void} setElementText
 * @property {(child: Node, parent: Element, anchor?: Node | null) => void} insert
 * @property {(child: Node) => void} remove
 * @property {(el: Element, key: string, prevValue: any, nextValue: any) => void} patchProp
 * @property {(selector: string) => Element | null} querySelector
 */

/**
 * @template T
 * @typedef {object} Renderer
 * @property {(n1: VNode | null, n2: VNode | null, container: Element, anchor?: Node | null, parentComponent?: import('./component.js').ComponentInstance<any> | null) => void} patch
 * @property {(vnode: VNode, container: Element) => import('./component.js').ComponentInstance<any> | undefined | null} hydrate
 */

/**
 * @typedef {Window & { __WEBS_DEVELOPER__?: { events: { emit: (event: string, data: any) => void; } } }} DevtoolsWindow
 */

/**
 * @file Core DOM rendering engine. Handles VDOM patching, component lifecycle, and hydration.
 */

import { effect } from './reactivity.js';
import { createLogger } from '../shared/logger.js';
import { isObject, isString } from '../shared/utils.js';
import {
  createComponent,
  pushInstance,
  popInstance,
  mergeProps,
  applyServerState,
} from './component.js';
import {
  Text,
  Comment,
  Fragment,
  Teleport,
  DynamicText,
  createVnode,
} from './vdom.js';

const logger = createLogger('[Renderer]');
/** @type {DevtoolsWindow} */
const devtools =
  typeof window !== 'undefined' ? /** @type {any} */ (window) : {};

/**
 * @internal
 * @param {Node | null} node
 * @returns {string}
 */
function getNodeDescription(node) {
  if (!node) return 'null';
  switch (node.nodeType) {
    case 1:
      return `<${/** @type {Element} */ (node).tagName.toLowerCase()}>`;
    case 3:
      const text = (node.textContent || '').trim();
      return `#text \"${text.length > 30 ? text.slice(0, 27) + '...' : text}\"`;
    case 8:
      return `<!--${/** @type {Comment} */ (node).data}-->`;
    default:
      return node.nodeName;
  }
}

/**
 * Creates a renderer instance with platform-specific DOM manipulation methods.
 * @param {RendererOptions} options - The platform-specific renderer options.
 * @returns {Renderer<any>} A renderer object with `patch` and `hydrate` methods.
 */
export function createRenderer(options) {
  const {
    createElement: hostCreateElement,
    patchProp: hostPatchProp,
    insert: hostInsert,
    remove: hostRemove,
    setElementText: hostSetElementText,
    createText: hostCreateText,
    createComment: hostCreateComment,
    querySelector: hostQuerySelector,
  } = options;

  /** @type {Renderer<any>['patch']} */
  const patch = (n1, n2, container, anchor = null, parentComponent = null) => {
    if (n1 === n2) {
      return;
    }

    if (n1 && !n2) {
      unmount(n1);
      return;
    }

    if (n1 && n2 && (n1.type !== n2.type || n1.key !== n2.key)) {
      const anchor = n1.el?.nextSibling ?? null;
      unmount(n1);
      patch(null, n2, container, anchor, parentComponent);
      return;
    }

    if (!n2) {
      return;
    }

    const { type } = n2;
    switch (type) {
      case Text:
        logger.debug('Patching Text node.');
        n2.el = n1 ? n1.el : hostCreateText(/**@type {string}*/ (n2.children));
        if (n1) {
          if (n2.children !== n1.children) {
            /** @type {Node} */ (n2.el).textContent = String(n2.children);
          }
        } else {
          hostInsert(/**@type {Node}*/ (n2.el), container, anchor);
        }
        break;
      case Comment:
        logger.debug('Patching Comment node.');
        n2.el = n1
          ? n1.el
          : hostCreateComment(/**@type {string}*/ (n2.children));
        if (!n1) {
          hostInsert(/**@type {Node}*/ (n2.el), container, anchor);
        }
        break;
      case Fragment:
        logger.debug('Patching Fragment node.');
        if (!n1) {
          const childrenToPatch = Array.isArray(n2.children)
            ? n2.children
            : [n2.children];
          childrenToPatch.forEach((c) => {
            const childVnode =
              isString(c) || typeof c === 'number'
                ? createVnode(Text, null, c)
                : /** @type {import('./vdom.js').VNode} */ (c);
            patch(null, childVnode, container, anchor, parentComponent);
          });
        } else {
          patchChildren(n1, n2, container, anchor, parentComponent);
        }
        break;
      case Teleport:
        logger.debug('Patching Teleport node.');
        if (n2.props?.to) {
          const target = hostQuerySelector(n2.props.to);
          if (target) {
            patchChildren(n1, n2, target, null, parentComponent);
          }
        }
        break;
      case DynamicText:
        logger.debug('Patching Dynamic Text node.');
        const dummyN1 = { type: Fragment, children: n1?.children };
        const dummyN2 = { type: Fragment, children: n2.children };

        patchChildren(
          /** @type {import('./vdom.js').VNode} */ (dummyN1),
          /** @type {import('./vdom.js').VNode} */ (dummyN2),
          container,
          anchor,
          parentComponent,
        );
        break;
      default:
        if (isString(type)) {
          logger.debug(`Patching native element: <${type}>`);
          patchElement(n1, n2, container, anchor, parentComponent);
        } else if (isObject(type)) {
          logger.debug(
            `Patching component: <${
              /** @type {Component<any>} */ (type).name
            }>`,
          );
          if (!n1) {
            mountComponent(n2, container, anchor, parentComponent);
          } else {
            updateComponent(n1, n2);
          }
        }
    }
  };

  /**
   * @param {import('./vdom.js').VNode | null} n1
   * @param {import('./vdom.js').VNode} n2
   * @param {Element} container
   * @param {Node | null} anchor
   * @param {import('./component.js').ComponentInstance<any> | null} parentComponent
   */
  const patchElement = (n1, n2, container, anchor, parentComponent) => {
    const el = (n2.el = n1
      ? /** @type {Element} */ (n1.el)
      : hostCreateElement(/**@type {string}*/ (n2.type)));
    const oldProps = n1?.props || {};
    const newProps = n2.props || {};

    for (const key in newProps) {
      hostPatchProp(el, key, oldProps[key], newProps[key]);
    }
    for (const key in oldProps) {
      if (!(key in newProps)) {
        hostPatchProp(el, key, oldProps[key], null);
      }
    }

    patchChildren(n1, n2, el, anchor, parentComponent);
    if (!n1) {
      hostInsert(el, container, anchor);
    }
  };

  /**
   * @param {import('./vdom.js').VNode | null} n1
   * @param {import('./vdom.js').VNode} n2
   * @param {Element} container
   * @param {Node | null} anchor
   * @param {import('./component.js').ComponentInstance<any> | null} parentComponent
   */
  const patchChildren = (n1, n2, container, anchor, parentComponent) => {
    const c1 = n1?.children;
    const c2 = n2?.children;

    if (isString(c2)) {
      if (c1 && !isString(c1)) {
        unmountChildren(/** @type {import('./vdom.js').VNodeChildren} */ (c1));
      }
      hostSetElementText(container, c2);
      return;
    }
    /** @param {any} c */
    const isSlotsObject = (c) =>
      isObject(c) && !('type' in c) && !Array.isArray(c);
    const oldChildren =
      c1 && !isSlotsObject(c1) ? (Array.isArray(c1) ? c1 : [c1]).flat() : [];
    const newChildren =
      c2 && !isSlotsObject(c2) ? (Array.isArray(c2) ? c2 : [c2]).flat() : [];

    if (newChildren.length === 0) {
      if (oldChildren.length > 0) {
        unmountChildren(
          /** @type {import('./vdom.js').VNodeChildren} */ (oldChildren),
        );
      }
      if (!isString(c1)) {
        hostSetElementText(container, '');
      }
      return;
    }

    if (oldChildren.length === 0) {
      newChildren.forEach((c) => {
        // @ts-ignore
        if (c && (c.type !== Text || c.children?.trim())) {
          patch(
            null,
            /** @type {import('./vdom.js').VNode} */ (c),
            container,
            anchor,
            parentComponent,
          );
        }
      });
      return;
    }

    const oldVNodes = /** @type {import('./vdom.js').VNode[]} */ (
      oldChildren.filter(isObject)
    );
    const newVNodes = /** @type {import('./vdom.js').VNode[]} */ (
      newChildren.filter(isObject)
    );

    if (newVNodes.some((child) => child.key != null)) {
      patchKeyedChildren(oldVNodes, newVNodes, container, parentComponent);
    } else {
      patchUnkeyedChildren(oldVNodes, newVNodes, container, parentComponent);
    }
  };

  /**
   * @param {import('./vdom.js').VNode[]} c1
   * @param {import('./vdom.js').VNode[]} c2
   * @param {Element} container
   * @param {import('./component.js').ComponentInstance<any> | null} parentComponent
   */
  const patchUnkeyedChildren = (c1, c2, container, parentComponent) => {
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);

    for (let i = 0; i < commonLength; i++) {
      const nextChild = c2[i];
      const oldChild = c1[i];
      if (nextChild && oldChild) {
        patch(oldChild, nextChild, container, null, parentComponent);
      }
    }
    if (newLength > oldLength) {
      for (let i = commonLength; i < newLength; i++) {
        const nextChild = c2[i];
        if (nextChild) {
          patch(null, nextChild, container, null, parentComponent);
        }
      }
    } else if (oldLength > newLength) {
      unmountChildren(c1.slice(commonLength));
    }
  };

  /**
   * @param {import('./vdom.js').VNode[]} c1
   * @param {import('./vdom.js').VNode[]} c2
   * @param {Element} container
   * @param {import('./component.js').ComponentInstance<any> | null} parentComponent
   */
  const patchKeyedChildren = (c1, c2, container, parentComponent) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;

    while (i <= e1 && i <= e2) {
      const p = c1[i];
      const n = c2[i];
      if (p && n && p.key === n.key) {
        patch(p, n, container, null, parentComponent);
        i++;
      } else {
        break;
      }
    }
    while (i <= e1 && i <= e2) {
      const p = c1[e1];
      const n = c2[e2];
      if (p && n && p.key === n.key) {
        patch(p, n, container, null, parentComponent);
        e1--;
        e2--;
      } else {
        break;
      }
    }

    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos]?.el : null;
        while (i <= e2) {
          const nextChild = c2[i++];
          if (nextChild)
            patch(null, nextChild, container, anchor, parentComponent);
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        const oldChild = c1[i++];
        if (oldChild) unmount(oldChild);
      }
    } else {
      const s1 = i,
        s2 = i;
      /** @type {Map<any, number>} */
      const keyToNewIndexMap = new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i];
        if (nextChild?.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      const toBePatched = e2 - s2 + 1;
      const newIndexToOldIndexMap = new Array(toBePatched).fill(0);
      let moved = false;
      let maxNewIndexSoFar = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (prevChild) {
          const newIndex = keyToNewIndexMap.get(prevChild.key);
          if (newIndex === undefined) {
            unmount(prevChild);
          } else {
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            const nextChild = c2[newIndex];
            if (nextChild)
              patch(prevChild, nextChild, container, null, parentComponent);
          }
        }
      }
      const increasingNewIndexSequence = moved
        ? getLongestIncreasingSubsequence(newIndexToOldIndexMap)
        : [];
      let j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1]?.el : null;
        if (newIndexToOldIndexMap[i] === 0) {
          if (nextChild)
            patch(null, nextChild, container, anchor, parentComponent);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            if (nextChild?.el) {
              hostInsert(nextChild.el, container, anchor);
            }
          } else {
            j--;
          }
        }
      }
    }
  };

  /**
   * @param {import('./vdom.js').VNode} vnode
   * @param {Element} container
   * @param {Node | null} anchor
   * @param {import('./component.js').ComponentInstance<any> | null} parentComponent
   * @param {boolean} [isHydrating=false]
   */
  const mountComponent = (
    vnode,
    container,
    anchor,
    parentComponent,
    isHydrating = false,
  ) => {
    const instance = (vnode.component = createComponent(
      vnode,
      parentComponent,
      false,
    ));

    const runner = effect(
      () => {
        pushInstance(instance);

        if (!instance.isMounted) {
          instance.hooks.onBeforeMount?.forEach((h) => h.call(instance.ctx));
          let subTree = instance.render
            ? instance.render.call(instance.ctx, instance.ctx)
            : null;

          if (!subTree) {
            subTree = createVnode(Comment, null, 'w-if');
          }
          instance.subTree = subTree;

          if (
            Object.keys(instance.attrs).length > 0 &&
            subTree.type !== Fragment &&
            subTree.props
          ) {
            subTree.props = mergeProps(subTree.props, instance.attrs);
          }

          if (isHydrating) {
            if (!vnode.el) {
              logger.warn(
                `Hydration failed for <${instance.type.name}>: no DOM element to hydrate against.`,
              );
            }
            const parentEl = vnode.el ? vnode.el.parentElement : null;
            if (!parentEl) {
              logger.warn(
                `Hydration failed for component <${instance.type.name}>: DOM node is detached.`,
              );
            }
            hydrateNode(subTree, vnode.el, parentEl, instance);
          } else {
            patch(null, subTree, container, anchor, instance);
          }

          vnode.el = subTree.el;
          if (subTree.type === Fragment) {
            /** @type {any[]} */
            const children = (
              Array.isArray(subTree.children)
                ? subTree.children
                : [subTree.children]
            )
              .flat()
              .filter(Boolean);
            for (let i = children.length - 1; i >= 0; i--) {
              const child = children[i];
              if (
                isObject(child) &&
                /** @type {import('./vdom.js').VNode} */ (child).el
              ) {
                instance.lastEl = /** @type {import('./vdom.js').VNode} */ (
                  child
                ).el;
                break;
              }
            }
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (
                isObject(child) &&
                /** @type {import('./vdom.js').VNode} */ (child).el
              ) {
                vnode.el = /** @type {import('./vdom.js').VNode} */ (child).el;
                break;
              }
            }
          } else {
            instance.lastEl = subTree.el;
          }

          instance.isMounted = true;
          instance.hooks.onMounted?.forEach((h) => h.call(instance.ctx));

          if (devtools && devtools.__WEBS_DEVELOPER__) {
            devtools.__WEBS_DEVELOPER__.events.emit('component:added', {
              uid: instance.uid,
              parentId: instance.parent ? instance.parent.uid : null,
              name: instance.type.name || 'Anonymous',
              props: instance.props,
              state: instance.internalCtx,
            });
          }
        } else {
          instance.hooks.onBeforeUpdate?.forEach((h) => h.call(instance.ctx));
          const prevTree = instance.subTree;
          let nextTree = instance.render
            ? instance.render.call(instance.ctx, instance.ctx)
            : null;

          if (!nextTree) {
            nextTree = createVnode(Comment, null, 'w-if');
          }
          instance.subTree = nextTree;

          const newAttrs = instance.attrs;
          if (
            Object.keys(newAttrs).length > 0 &&
            nextTree.type !== Fragment &&
            nextTree.props
          ) {
            nextTree.props = mergeProps(nextTree.props, newAttrs);
          }

          let anchorNodeForParent = prevTree?.el;

          if (prevTree?.type === Fragment && prevTree.children) {
            const children = Array.isArray(prevTree.children)
              ? prevTree.children
              : [prevTree.children];
            if (children.length > 0 && isObject(children[0])) {
              anchorNodeForParent = /** @type {import('./vdom.js').VNode}*/ (
                children[0]
              ).el;
            }
          }

          const parentContainer = anchorNodeForParent
            ? anchorNodeForParent.parentElement
            : null;

          if (parentContainer) {
            patch(prevTree, nextTree, parentContainer, null, instance);
            instance.vnode.el = nextTree.el;
            instance.hooks.onUpdated?.forEach((h) => h.call(instance.ctx));
            if (devtools && devtools.__WEBS_DEVELOPER__) {
              devtools.__WEBS_DEVELOPER__.events.emit('component:updated', {
                uid: instance.uid,
                props: instance.props,
                state: instance.internalCtx,
              });
            }
          }
        }

        popInstance();
      },
      undefined,
      {
        scheduler: () => {
          if (instance.update) instance.update();
        },
      },
    );
    instance.update = runner;
    instance.hooks.onReady?.forEach((h) => h.call(instance.ctx));
  };
  /**
   * @param {import('./vdom.js').Props} prevProps
   * @param {import('./vdom.js').Props} nextProps
   * @returns {boolean}
   */
  const hasPropsChanged = (prevProps, nextProps) => {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for (const key of nextKeys) {
      if (nextProps[key] !== prevProps[key]) return true;
    }
    return false;
  };

  /**
   * @param {import('./vdom.js').VNode} n1
   * @param {import('./vdom.js').VNode} n2
   * @returns {boolean}
   */
  const shouldUpdateComponent = (n1, n2) => {
    const { props: prevProps, children: prevChildren } = n1;
    const { props: nextProps, children: nextChildren } = n2;

    if (prevChildren || nextChildren) return true;
    if (prevProps === nextProps) return false;
    if (!prevProps) return !!nextProps;
    if (!nextProps) return true;

    return hasPropsChanged(prevProps, nextProps);
  };

  /**
   * @param {import('./vdom.js').VNode} n1
   * @param {import('./vdom.js').VNode} n2
   */
  const updateComponent = (n1, n2) => {
    const instance = (n2.component =
      /** @type {import('./component.js').ComponentInstance<any>} */ (
        n1.component
      ));

    if (!shouldUpdateComponent(n1, n2)) {
      n2.el = n1.el;
      instance.vnode = n2;
      return;
    }

    instance.vnode = n2;
    n2.el = n1.el;

    const { props: propsOptions } = instance.type;
    const vnodeProps = n2.props || {};
    const nextProps = {};
    const nextAttrs = {};

    for (const key in vnodeProps) {
      if (
        propsOptions &&
        Object.prototype.hasOwnProperty.call(propsOptions, key)
      ) {
        /** @type {any} */ (nextProps)[key] = vnodeProps[key];
      } else {
        /** @type {any} */ (nextAttrs)[key] = vnodeProps[key];
      }
    }

    instance.attrs = nextAttrs;
    instance.slots =
      /** @type {import('./vdom.js').Slots} */ (n2.children) || {};

    if (instance.hooks.onPropsReceived) {
      instance.hooks.onPropsReceived.forEach((h) =>
        h.call(instance.ctx, nextProps, instance.props),
      );
    }

    for (const key in nextProps) {
      instance.props[key] = /** @type {any} */ (nextProps)[key];
    }
    for (const key in instance.props) {
      if (!Object.prototype.hasOwnProperty.call(nextProps, key)) {
        delete instance.props[key];
      }
    }

    if (vnodeProps.initialState) {
      applyServerState(instance.internalCtx, vnodeProps.initialState);
    }

    if (instance.update) {
      instance.update();
    }
  };

  /** @param {import('./vdom.js').VNode | import('./vdom.js').VNodeChild} vnode */
  const unmount = (vnode) => {
    if (!vnode || !isObject(vnode)) return;

    if (vnode.component) {
      if (devtools && devtools.__WEBS_DEVELOPER__) {
        devtools.__WEBS_DEVELOPER__.events.emit('component:removed', {
          uid: vnode.component.uid,
        });
      }

      if (vnode.component.update) {
        /** @type {any} */ (vnode.component.update).effect?.stop();
      }
      vnode.component.hooks.onUnmounted?.forEach(
        /** @type {any} */ (h) => h.call(vnode.component?.ctx),
      );
      unmount(vnode.component.subTree);
      return;
    }
    if (vnode.type === Fragment || vnode.type === Teleport) {
      if (vnode.children) {
        unmountChildren(
          /** @type {import('./vdom.js').VNodeChildren} */ (vnode.children),
        );
      }
      return;
    }
    if (vnode.el) {
      hostRemove(vnode.el);
    }
  };

  /** @param {import('./vdom.js').VNodeChildren} children */
  const unmountChildren = (children) => {
    const childrenToUnmount = (
      Array.isArray(children) ? children : [children]
    ).filter(Boolean);
    childrenToUnmount.forEach(unmount);
  };

  /** @type {Renderer<any>['hydrate']} */
  const hydrate = (vnode, container) => {
    if (!container.firstChild) {
      patch(null, vnode, container);
      return vnode.component;
    }
    const rootDomNode = skipNonEssentialNodes(container.firstChild);
    if (!rootDomNode) {
      patch(null, vnode, container);
      return vnode.component;
    }

    hydrateNode(vnode, rootDomNode, container, null);
    return vnode.component;
  };

  /**
   * @param {Node | null} node
   * @returns {Node | null}
   */
  const skipNonEssentialNodes = (node) => {
    let currentNode = node;
    while (
      currentNode &&
      (currentNode.nodeType === 8 ||
        (currentNode.nodeType === 3 &&
          (currentNode.textContent || '').trim() === ''))
    ) {
      currentNode = currentNode.nextSibling;
    }
    return currentNode;
  };

  /**
   * @param {import('./vdom.js').VNode} vnode
   * @param {Node | null} domNode
   * @param {Element | null} parentDom
   * @param {import('./component.js').ComponentInstance<any> | null} parentComponent
   * @returns {Node | null}
   */
  const hydrateNode = (vnode, domNode, parentDom, parentComponent = null) => {
    if (!vnode) {
      return domNode;
    }

    if (isObject(vnode.type)) {
      vnode.el = domNode;
      if (parentDom) {
        mountComponent(vnode, parentDom, domNode, parentComponent, true);
      }
      const lastNode = vnode.component?.lastEl;
      return lastNode ? lastNode.nextSibling : domNode;
    }

    if (vnode.type === Fragment) {
      const nextDomNode = hydrateChildren(
        /** @type {import('./vdom.js').VNodeChildren} */ (vnode.children),
        /** @type {Element} */ (parentDom),
        domNode,
        parentComponent,
      );
      /** @type {any[]} */
      const childVnodes = (
        Array.isArray(vnode.children) ? vnode.children : [vnode.children]
      )
        .flat()
        .filter(Boolean);

      const firstChildVnode = childVnodes.find(
        (c) => isObject(c) && /**@type {import('./vdom.js').VNode}*/ (c).el,
      );

      if (isObject(firstChildVnode)) {
        vnode.el = /**@type {import('./vdom.js').VNode}*/ (firstChildVnode).el;
      }
      return nextDomNode;
    }

    let currentDomNode = skipNonEssentialNodes(/**@type {Node}*/ (domNode));

    if (!currentDomNode || !parentDom) {
      if (parentDom) {
        patch(null, vnode, parentDom, null, parentComponent);
      }
      return null;
    }

    const { type, props, children } = vnode;

    /**
     * @param {string} expected
     * @param {string} found
     * @param {import('./vdom.js').VNode} vnodeDetails
     * @returns {Node | null}
     */
    const handleMismatch = (expected, found, vnodeDetails) => {
      logger.error(
        `[Hydration Mismatch] Expected ${expected}, but found ${found}.`,
        vnodeDetails,
      );
      if (process.env.NODE_ENV !== 'production') {
        patch(null, vnode, parentDom, currentDomNode, parentComponent);
        if (currentDomNode) hostRemove(currentDomNode);
        return vnode.el ? vnode.el.nextSibling : null;
      } else {
        return currentDomNode?.nextSibling ?? null;
      }
    };

    if (type === Text && props && props['w-dynamic']) {
      if (
        currentDomNode &&
        currentDomNode.nodeType === 8 &&
        /**@type {Comment}*/ (currentDomNode).data === '['
      ) {
        const textNode = currentDomNode.nextSibling;
        const closingComment = textNode ? textNode.nextSibling : null;

        if (
          closingComment &&
          closingComment.nodeType === 8 &&
          /**@type {Comment}*/ (closingComment).data === ']'
        ) {
          vnode.el = textNode;
          return closingComment.nextSibling;
        } else {
          return handleMismatch(
            "closing comment '<!--]-->'",
            getNodeDescription(closingComment),
            vnode,
          );
        }
      }
    }

    vnode.el = currentDomNode;

    switch (type) {
      case Text:
        if (!currentDomNode || currentDomNode.nodeType !== 3) {
          return handleMismatch(
            'a text node',
            getNodeDescription(currentDomNode),
            /** @type {import('./vdom.js').VNode} */ ({
              expectedContent: vnode.children,
              ...vnode,
            }),
          );
        } else if (
          String(currentDomNode.textContent) !== String(vnode.children)
        ) {
          if (process.env.NODE_ENV !== 'production') {
            currentDomNode.textContent = String(vnode.children);
          }
        }
        return currentDomNode.nextSibling;

      case Comment:
        if (!currentDomNode || currentDomNode.nodeType !== 8) {
          return handleMismatch(
            'a comment node',
            getNodeDescription(currentDomNode),
            vnode,
          );
        }
        return currentDomNode.nextSibling;
      case Teleport:
        if (props && props.to) {
          return hydrateChildren(
            /** @type {import('./vdom.js').VNodeChildren} */ (children),
            hostQuerySelector(props.to),
            null,
            parentComponent,
          );
        }
        return currentDomNode.nextSibling;
      default:
        if (isString(type)) {
          const vnodeTagName = type.toLowerCase();
          const domTagName = /** @type {Element} */ (
            currentDomNode
          )?.tagName?.toLowerCase();

          if (
            !currentDomNode ||
            currentDomNode.nodeType !== 1 ||
            domTagName !== vnodeTagName
          ) {
            return handleMismatch(
              `element <${type}>`,
              getNodeDescription(currentDomNode),
              vnode,
            );
          }
          if (props) {
            for (const key in props) {
              hostPatchProp(
                /**@type {Element}*/ (currentDomNode),
                key,
                null,
                props[key],
              );
            }
          }
          hydrateChildren(
            /** @type {import('./vdom.js').VNodeChildren} */ (children),
            /**@type {Element}*/ (currentDomNode),
            currentDomNode.firstChild,
            parentComponent,
          );
          return currentDomNode.nextSibling;
        }
    }
    return currentDomNode ? currentDomNode.nextSibling : null;
  };

  /**
   * @param {import('./vdom.js').VNodeChildren} children
   * @param {Element | null} parentDom
   * @param {Node | null} startNode
   * @param {import('./component.js').ComponentInstance<any> | null} parentComponent
   * @returns {Node | null}
   */
  const hydrateChildren = (
    children,
    parentDom,
    startNode,
    parentComponent = null,
  ) => {
    let nextDomNode = startNode;
    if (!children || !parentDom) {
      return nextDomNode;
    }

    const childVnodes = (
      Array.isArray(children) ? children : [children]
    ).flat();

    for (const childVnode of childVnodes) {
      if (!childVnode) continue;
      nextDomNode = hydrateNode(
        /** @type {import('./vdom.js').VNode} */ (childVnode),
        nextDomNode,
        parentDom,
        parentComponent,
      );
    }
    return nextDomNode;
  };

  return { patch, hydrate };
}

/**
 * @internal
 * @param {number[]} arr
 * @returns {number[]}
 */
function getLongestIncreasingSubsequence(arr) {
  if (arr.length === 0) return [];
  /** @type {(number | undefined)[]} */
  const p = new Array(arr.length);
  const result = [0];
  let i, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0 && arrI != null) {
      const j = result[result.length - 1];
      if (j !== undefined) {
        const arrJ = arr[j];
        if (arrJ != null && arrJ < arrI) {
          p[i] = j;
          result.push(i);
          continue;
        }
      }

      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = (u + v) >> 1;
        const resultC = result[c];
        if (resultC !== undefined) {
          const arrResultC = arr[resultC];
          if (arrResultC != null && arrResultC < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
      }
      const resultU = result[u];
      if (resultU !== undefined) {
        const arrResultU = arr[resultU];
        if (arrResultU && arrI != null && arrI < arrI) {
          if (u > 0) {
            const prevResult = result[u - 1];
            if (prevResult !== undefined) p[i] = prevResult;
          }
          result[u] = i;
        }
      }
    }
  }
  u = result.length;
  let v_ = result[u - 1];
  if (v_ === undefined) return [];

  /** @type {number} */
  let currentV = v_;

  while (u-- > 0) {
    result[u] = currentV;
    const p_v_ = p[currentV];
    if (p_v_ === undefined) break;
    currentV = p_v_;
  }
  return result;
}

---------- END: engine/renderer.js ----------

---------- START: engine/ssr.js ----------
/**
 * @file Type definitions for Server-Side Rendering (SSR) functionality.
 * @typedef {import('./vdom.js').VNodeChild} VNodeChild
 * @typedef {import('./vdom.js').VNodeChildren} VNodeChildren
 * @typedef {import('./vdom.js').Slots} Slots
 * @typedef {import('./vdom.js').Props} Props
 * @typedef {import('./component.js').ComponentInstance<any>} ComponentInstance
 */

/**
 * @typedef {object} RenderResult
 * @property {string} html - The rendered HTML string.
 * @property {object} componentState - The initial state of the components.
 */

/**
 * @typedef {object} SsrContext
 * @property {object} componentState - An object to hold the component state.
 */

/**
 * @file Handles Server-Side Rendering (SSR) of VNodes to an HTML string.
 */

import {
  isObject,
  isString,
  isFunction,
  normalizeClass,
  voidElements,
} from '../shared/utils.js';
import { createLogger } from '../shared/logger.js';
import { createComponent, mergeProps } from './component.js';
import { isRef } from './reactivity.js';
import { Text, Comment, Fragment, Teleport, VNode } from './vdom.js';

const logger = createLogger('[SSR]');

/**
 * @internal
 * @param {any} obj
 * @returns {any}
 */
function unwrapRefs(obj) {
  if (!obj || typeof obj !== 'object') return obj;
  /** @type {Record<string, any>} */
  const res = {};
  for (const key in obj) {
    const val = /** @type {any} */ (obj)[key];
    if (isRef(val)) {
      res[key] = unwrapRefs(val.value);
    } else if (Array.isArray(val)) {
      res[key] = val.map(unwrapRefs);
    } else if (
      typeof val === 'object' &&
      val !== null &&
      !(val instanceof Set) &&
      !(val instanceof Map)
    ) {
      res[key] = unwrapRefs(val);
    } else {
      res[key] = val;
    }
  }
  return res;
}

/**
 * Renders a VNode to an HTML string on the server.
 * @param {VNode} vnode The root VNode to render.
 * @returns {Promise<RenderResult>} An object containing the rendered HTML and the initial state.
 */
export async function renderToString(vnode) {
  try {
    /** @type {SsrContext} */
    const context = { componentState: {} };
    const html = await renderVnode(vnode, null, context);
    const unwrappedState = unwrapRefs(context.componentState);

    if (unwrappedState && /** @type {any} */ (unwrappedState).session) {
      delete (/** @type {any} */ (unwrappedState).session);
    }

    return { html, componentState: unwrappedState };
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    logger.error('SSR rendering error:', e);
    const html = `<div style=\"color:red; background:lightyellow; border: 1px solid red; padding: 1rem;\">SSR Error: ${escapeHtml(
      message,
    )}</div>`;
    return { html, componentState: {} };
  }
}

/**
 * @internal
 * @param {VNodeChild} vnode
 * @param {ComponentInstance | null} parentComponent
 * @param {SsrContext} context
 * @returns {Promise<string>}
 */
async function renderVnode(vnode, parentComponent, context) {
  if (vnode == null) return '';
  if (isString(vnode) || typeof vnode === 'number') {
    return escapeHtml(String(vnode));
  }
  if (!isObject(vnode) || !(vnode instanceof VNode)) {
    return `<!-- invalid vnode detected -->`;
  }

  const { type, props, children } = vnode;

  switch (type) {
    case Text:
      const content = children != null ? escapeHtml(String(children)) : '';
      return props && props['w-dynamic']
        ? `<!--[-->${content}<!--]-->`
        : content;
    case Comment:
      return `<!--${children != null ? escapeHtml(String(children)) : ''}-->`;
    case Fragment:
    case Teleport:
      if (
        isObject(children) &&
        !Array.isArray(children) &&
        !('type' in children)
      ) {
        const slots = /** @type {Slots} */ (children);
        if (slots.default) {
          const defaultContent = slots.default();
          const childArray = (
            Array.isArray(defaultContent) ? defaultContent : [defaultContent]
          ).flat();
          let result = '';
          for (const child of childArray) {
            result += await renderVnode(
              /** @type{VNodeChild} */ (child),
              parentComponent,
              context,
            );
          }
          return result;
        }
        return '';
      }
      return await renderChildren(
        /** @type {VNodeChildren | Slots} */ (children),
        parentComponent,
        context,
      );
    default:
      if (isString(type)) {
        const tag = type.toLowerCase();
        let html = `<${tag}${renderProps(props)}>`;
        if (!voidElements.has(tag)) {
          html += await renderChildren(children, parentComponent, context);
          html += `</${tag}>`;
        }
        return html;
      } else if (isObject(type)) {
        const instance = createComponent(vnode, parentComponent, true);

        if (parentComponent) {
          instance.appContext.components = {
            ...(parentComponent.appContext.components || {}),
            ...(parentComponent.type.components || {}),
            ...(instance.type.components || {}),
          };
        }

        let subTree = instance.render
          ? instance.render.call(instance.ctx, instance.ctx)
          : null;

        if (!subTree) {
          return `<!--w-if-->`;
        }

        if (
          Object.keys(instance.attrs).length > 0 &&
          subTree.type !== Fragment &&
          subTree.props
        ) {
          subTree.props = mergeProps(subTree.props, instance.attrs);
        }
        if (!parentComponent && context) {
          context.componentState = instance.internalCtx;
        }
        if (isFunction(instance.render)) {
          return await renderVnode(subTree, instance, context);
        }
        return `<!-- component failed to render -->`;
      }
      return `<!-- invalid vnode type -->`;
  }
}

/**
 * @internal
 * @param {VNodeChildren | Slots} children
 * @param {ComponentInstance | null} parentComponent
 * @param {SsrContext} context
 * @returns {Promise<string>}
 */
async function renderChildren(children, parentComponent, context) {
  if (!children) return '';
  const childArray = (Array.isArray(children) ? children : [children]).flat();
  let result = '';
  for (const child of childArray) {
    result += await renderVnode(
      /** @type{VNodeChild} */ (child),
      parentComponent,
      context,
    );
  }
  return result;
}

/**
 * @internal
 * @param {Props | null} props
 * @returns {string}
 */
function renderProps(props) {
  if (!props) return '';
  let result = '';
  for (const key in props) {
    if (key === 'key' || key.startsWith('on') || key === 'w-dynamic') continue;
    const value = props[key];
    if (key === 'class') {
      const classValue = normalizeClass(value);
      if (classValue) {
        result += ` class=\"${escapeHtml(classValue)}\"`;
      }
    } else if (key === 'style') {
      const styleString = isObject(value)
        ? Object.entries(value)
            .map(
              ([k, v]) => `${k.replace(/([A-Z])/g, '-$1').toLowerCase()}:${v}`,
            )
            .join(';')
        : String(value);
      if (styleString) {
        result += ` style=\"${escapeHtml(styleString)}\"`;
      }
    } else if (typeof value === 'boolean') {
      if (value) result += ` ${key}`;
    } else if (value != null) {
      result += ` ${key}=\"${escapeHtml(String(value))}\"`;
    }
  }
  return result;
}

/**
 * @internal
 * @param {any} str
 * @returns {string}
 */
function escapeHtml(str) {
  if (str == null) return '';
  return String(str).replace(/[&<>\"']/g, (match) => {
    switch (match) {
      case '&':
        return '&amp;';
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '\"':
        return '&quot;';
      case "'":
        return '&#039;';
      default:
        return match;
    }
  });
}

---------- END: engine/ssr.js ----------

---------- START: engine/template-parser.js ----------
/**
 * @file Type definitions for the template parser.
 */

/**
 * @typedef {object} HtmlToken
 * @property {string} type - The type of the token.
 */

/** @typedef {HtmlToken & { content: string }} TextToken */
/** @typedef {HtmlToken & { content: string }} CommentToken */
/** @typedef {HtmlToken & { expression: string }} IfStartToken */
/** @typedef {HtmlToken & { expression: string, item: string, key: string | null }} EachStartToken */
/** @typedef {HtmlToken & { expression: string }} ElseIfToken */
/** @typedef {HtmlToken} ElseToken */
/** @typedef {HtmlToken} IfEndToken */
/** @typedef {HtmlToken} EachEndToken */
/** @typedef {HtmlToken & { tagName: string, attributes: AttributeToken[], selfClosing: boolean }} TagStartToken */
/** @typedef {HtmlToken & { tagName: string }} TagEndToken */
/** @typedef {{ name: string, value: string | true }} AttributeToken */

/** @typedef {TextToken | CommentToken | IfStartToken | EachStartToken | ElseIfToken | ElseToken | IfEndToken | EachEndToken | TagStartToken | TagEndToken} AnyHtmlToken */

/**
 * @typedef {object} HtmlAstNode
 * @property {string} type - The type of the AST node.
 * @property {HtmlAstNode[]} [children] - Child nodes.
 */

/** @typedef {HtmlAstNode & { children: HtmlAstNode[] }} RootNode */
/** @typedef {HtmlAstNode & { test: string, children: HtmlAstNode[] }} IfBlockNode */
/** @typedef {HtmlAstNode & { test: string, children: HtmlAstNode[] }} ElseIfBlockNode */
/** @typedef {HtmlAstNode & { children: HtmlAstNode[] }} ElseBlockNode */
/** @typedef {HtmlAstNode & { expression: string, item: string, key: string | null, children: HtmlAstNode[] }} EachBlockNode */
/** @typedef {HtmlAstNode & { tagName: string, attributes: AttributeToken[], children: HtmlAstNode[] }} ElementNode */
/** @typedef {HtmlAstNode & { content: string }} TextNode */
/** @typedef {HtmlAstNode & { content: string }} CommentNode */

/**
 * @file A high-performance, caching HTML parser designed specifically for the framework's custom template syntax, including directives and bindings.
 */

import { voidElements } from '../shared/utils.js';

/** @type {Map<string, RootNode>} */
const htmlAstCache = new Map();

const directiveRegex =
  /{#if\s+(.+?)}|{#each\s+(.+?)\s+as\s+(.+?)(?:\s*\((.+?)\))?}|{:else if\s+(.+?)}|{:else}|{\/if}|{\/each}/g;

/**
 * @internal
 * Tokenizes an HTML string, separating template directives from HTML content.
 * @param {string} html - The HTML string to tokenize.
 * @returns {AnyHtmlToken[]} An array of tokens.
 */
function tokenizeHtml(html) {
  /** @type {AnyHtmlToken[]} */
  const tokens = [];
  let lastIndex = 0;

  html.replace(
    directiveRegex,
    (match, ifExpr, eachExpr, eachItem, eachKey, elseIfExpr, offset) => {
      if (offset > lastIndex) {
        tokens.push({
          type: 'text',
          content: html.substring(lastIndex, offset),
        });
      }

      if (ifExpr) {
        tokens.push({ type: 'ifStart', expression: ifExpr.trim() });
      } else if (eachExpr) {
        tokens.push({
          type: 'eachStart',
          expression: eachExpr.trim(),
          item: eachItem.trim(),
          key: eachKey ? eachKey.trim() : null,
        });
      } else if (elseIfExpr) {
        tokens.push({ type: 'elseIf', expression: elseIfExpr.trim() });
      } else if (match === '{:else}') {
        tokens.push({ type: 'else' });
      } else if (match === '{/if}') {
        tokens.push({ type: 'ifEnd' });
      } else if (match === '{/each}') {
        tokens.push({ type: 'eachEnd' });
      }

      lastIndex = offset + match.length;
      return match;
    },
  );

  if (lastIndex < html.length) {
    tokens.push({ type: 'text', content: html.substring(lastIndex) });
  }

  /** @type {AnyHtmlToken[]} */
  const finalTokens = [];
  for (const token of tokens) {
    if (token.type === 'text') {
      finalTokens.push(
        ...tokenizeHtmlContent(/** @type {TextToken} */ (token).content),
      );
    } else {
      finalTokens.push(token);
    }
  }

  return finalTokens;
}

/**
 * @internal
 * Tokenizes the content part of an HTML string (tags, text, comments).
 * @param {string} html - The HTML content string.
 * @returns {Array<TextToken | CommentToken | TagStartToken | TagEndToken>} An array of content tokens.
 */
function tokenizeHtmlContent(html) {
  /** @type {Array<TextToken | CommentToken | TagStartToken | TagEndToken>} */
  const tokens = [];
  const tagRegex = /<\/?([a-zA-Z0-9:-]+)\s*([^>]*)>|<!--([\s\S]*?)-->/g;
  let lastIndex = 0;

  html.replace(tagRegex, (match, tagName, attrs, comment, offset) => {
    if (offset > lastIndex) {
      const textContent = html.substring(lastIndex, offset);
      if (textContent) {
        tokens.push({
          type: 'text',
          content: textContent,
        });
      }
    }

    if (comment !== undefined) {
      tokens.push({ type: 'comment', content: comment || '' });
    } else if (match.startsWith('</')) {
      tokens.push({ type: 'tagEnd', tagName });
    } else {
      /** @type {AttributeToken[]} */
      const attributes = [];
      const attrRegex =
        /([:@#]?[a-zA-Z0-9:.-]+)(?:=(?:"([^"]*)"|'([^']*)'|([^>\s]+)))?/g;
      let attrMatch;
      while ((attrMatch = attrRegex.exec(attrs))) {
        const name = attrMatch[1];
        if (name) {
          attributes.push({
            name: name,
            value: attrMatch[2] ?? attrMatch[3] ?? attrMatch[4] ?? true,
          });
        }
      }
      tokens.push({
        type: 'tagStart',
        tagName,
        attributes,
        selfClosing: match.endsWith('/>'),
      });
    }
    lastIndex = offset + match.length;
    return match;
  });

  if (lastIndex < html.length) {
    const textContent = html.substring(lastIndex);
    if (textContent) {
      tokens.push({ type: 'text', content: textContent });
    }
  }
  return tokens;
}

/**
 * @internal
 * Builds an Abstract Syntax Tree (AST) from an array of tokens.
 * @param {AnyHtmlToken[]} tokens - The flat array of tokens.
 * @returns {RootNode} The root of the AST.
 */
function buildTree(tokens) {
  /** @type {RootNode} */
  const root = { type: 'root', children: [] };
  /** @type {(RootNode | ElementNode | IfBlockNode | ElseIfBlockNode | ElseBlockNode | EachBlockNode)[]} */
  const stack = [root];

  for (const token of tokens) {
    let parent = stack[stack.length - 1];
    if (!parent) continue;

    switch (token.type) {
      case 'ifStart': {
        const node = /** @type {IfBlockNode} */ ({
          type: 'ifBlock',
          test: /** @type {IfStartToken} */ (token).expression,
          children: [],
        });
        parent.children?.push(node);
        stack.push(node);
        break;
      }
      case 'elseIf': {
        stack.pop();
        parent = stack[stack.length - 1];
        if (!parent) continue;
        const node = /** @type {ElseIfBlockNode} */ ({
          type: 'elseIfBlock',
          test: /** @type {ElseIfToken} */ (token).expression,
          children: [],
        });
        parent.children?.push(node);
        stack.push(node);
        break;
      }
      case 'else': {
        stack.pop();
        parent = stack[stack.length - 1];
        if (!parent) continue;
        const node = /** @type {ElseBlockNode} */ ({
          type: 'elseBlock',
          children: [],
        });
        parent.children?.push(node);
        stack.push(node);
        break;
      }
      case 'eachStart': {
        const eachToken = /** @type {EachStartToken} */ (token);
        const node = /** @type {EachBlockNode} */ ({
          type: 'eachBlock',
          expression: eachToken.expression,
          item: eachToken.item,
          key: eachToken.key,
          children: [],
        });
        parent.children?.push(node);
        stack.push(node);
        break;
      }
      case 'ifEnd':
      case 'eachEnd': {
        stack.pop();
        break;
      }
      case 'tagStart': {
        const tagToken = /** @type {TagStartToken} */ (token);
        const node = /** @type {ElementNode} */ ({
          type: 'element',
          tagName: tagToken.tagName.toLowerCase(),
          attributes: tagToken.attributes,
          children: [],
        });
        parent.children?.push(node);
        if (!tagToken.selfClosing && !voidElements.has(node.tagName)) {
          stack.push(node);
        }
        break;
      }
      case 'tagEnd': {
        if (
          stack.length > 1 &&
          /** @type {ElementNode} */ (parent).tagName ===
            /** @type {TagEndToken} */ (token).tagName.toLowerCase()
        ) {
          stack.pop();
        }
        break;
      }
      case 'text': {
        const content = /** @type {TextToken} */ (token).content;
        if (content.trim().length > 0) {
          parent.children?.push(
            /** @type {TextNode} */ ({ type: 'text', content: content }),
          );
        }
        break;
      }
      case 'comment': {
        parent.children?.push(
          /** @type {CommentNode} */ ({
            type: 'comment',
            content: /** @type {CommentToken} */ (token).content,
          }),
        );
        break;
      }
    }
  }
  return root;
}

/**
 * Parses an HTML string into an Abstract Syntax Tree (AST).
 * This function handles standard HTML, comments, and custom templating directives
 * like `{#if}` and `{#each}`. The result is cached.
 * @param {string} html - The HTML template string to parse.
 * @returns {RootNode} The root node of the generated AST.
 */
export function parseHtml(html) {
  const cached = htmlAstCache.get(html);
  if (cached) {
    return cached;
  }
  const tokens = tokenizeHtml(html);
  const ast = buildTree(tokens);
  htmlAstCache.set(html, ast);
  return ast;
}

---------- END: engine/template-parser.js ----------

---------- START: engine/vdom.js ----------
/**
 * @file Defines the core Virtual DOM (VDOM) structures and creation functions.
 */

import { isObject } from '../shared/utils.js';

/**
 * @typedef {import('./renderer.js').Component<any>} Component
 * @typedef {import('./component.js').ComponentInstance<any>} ComponentInstance
 * @typedef {import('./renderer.js').AppContext} AppContext
 */

/**
 * @typedef {Record<string, any>} Props
 */

/**
 * @typedef {VNode | string | number | null | undefined} VNodeChild
 */

/**
 * @typedef {VNodeChild[]} VNodeChildrenArray
 */

/**
 * @typedef {VNodeChild | VNodeChildrenArray} VNodeChildren
 */

/**
 * @typedef {Record<string, () => VNodeChildren>} Slots
 */

export const Text = Symbol('Text');
export const Comment = Symbol('Comment');
export const Fragment = Symbol('Fragment');
export const Teleport = Symbol('Teleport');
export const DynamicText = Symbol('DynamicText');

export class VNode {
  /**
   * @param {string | symbol | Component} type
   * @param {Props | null} props
   * @param {VNodeChildren | Slots | string | null} children
   */
  constructor(type, props, children) {
    this.type = type;
    this.props = props || {};
    this.children = children;
    /** @type {Node | null} */
    this.el = null;
    this.key = this.props.key;
    /** @type {ComponentInstance | null} */
    this.component = null;
    /** @type {AppContext | null} */
    this.appContext = null;
  }
}

/**
 * Low-level VNode creation. The `h` function is the public-facing API.
 * @param {string | symbol | Component} type
 * @param {Props | null} props
 * @param {VNodeChildren | string | null} [children]
 * @returns {VNode}
 */
export function createVnode(type, props, children) {
  let normalizedChildren = null;

  if (children !== undefined && children !== null) {
    if (type === Text || type === Comment) {
      normalizedChildren = Array.isArray(children)
        ? children.filter((c) => c != null).join('')
        : String(children);
    } else {
      const childNodes = Array.isArray(children) ? children : [children];
      const flattened = childNodes
        .flat()
        .filter((c) => c !== null && c !== undefined && typeof c !== 'boolean')
        .map((c) =>
          isObject(c) && 'type' in c
            ? /** @type {VNode} */ (c)
            : new VNode(Text, null, String(c)),
        );

      if (flattened.length > 0) {
        normalizedChildren = /** @type {VNodeChildrenArray} */ (flattened);
      }
    }
  }

  return new VNode(type, props, normalizedChildren);
}

/**
 * Hyperscript function for creating VNodes. Public API for manual render functions.
 * @param {string | symbol | Component} type
 * @param {Props | VNodeChildren | null} [propsOrChildren]
 * @param {...(VNodeChildren | Slots)} childrenArgs - Can be VNode children or a single slots object.
 * @returns {VNode}
 */
export function h(type, propsOrChildren, ...childrenArgs) {
  const isComponent = typeof type === 'function' || isObject(type);
  const hasProps =
    isObject(propsOrChildren) &&
    !Array.isArray(propsOrChildren) &&
    !(propsOrChildren instanceof VNode);

  const props = hasProps ? /** @type {Props} */ (propsOrChildren) : {};
  const children = hasProps ? childrenArgs : [propsOrChildren, ...childrenArgs];

  if (
    isComponent &&
    children.length === 1 &&
    isObject(children[0]) &&
    !Array.isArray(children[0]) &&
    !(/** @type {any} */ (children[0] instanceof VNode))
  ) {
    const slots = /** @type {Slots} */ (children[0]);
    return new VNode(type, props, slots);
  }

  const finalChildren = /** @type {VNodeChildren} */ (
    /** @type {unknown} */ (children)
  );
  return createVnode(type, props, finalChildren);
}

---------- END: engine/vdom.js ----------

---------- START: native/.webs.dylib ----------
����             �         �  __TEXT                   0               0                   __text          __TEXT          p      
%      p               �            __stubs         __TEXT          z)      r       z)              �           __cstring       __TEXT          �)      �      �)                             __const         __TEXT          �.      0       �.                             __unwind_info   __TEXT          �.      X       �.                                �   __DATA_CONST     0              0                         __got           __DATA_CONST     0      �        0                              H   __LINKEDIT       @               @      0                       (                 .webs.dylib     4  �    @  �  3  �   �A  �         �B  �   �Q  H     P       �   �      �                              HQ  (                         �hj׹A=��G�� J��2                       �*                 8           L   /usr/lib/libSystem.B.dylib      &      pB  H   )      �B                                                                              UH��H�� H�}�H�}� u�   H�E�� �E��tm� �E��t� �E��uh� H�E�H�x��$  �YH�E�    H�E�H�M�H;As#H�E�H�@H�M�H�<�����H�E�H��H�E���H�E�H�x�$  �H�E�H�x�A  �� H�}��$  H�� ]�fffff.�     UH��H��`H�}�H�u�H�}� uH�=�$  �}  H�E�H�U��^  H�E�H�E�H�E�H�E�H�EЀ8 �,  H�E؃8 �
  H�E�� ��[uH�=t$  �.  H�E�H�U��  H�}�H�5�$  �$  H�E�H�}� tH�E�H�M�H)�H�E��H�}���#  H�E�H�E�H�E�H�}�H���#  H�E�H�}� uH�=<$  �  H�E�H�U��  H�}�H�u�H�U�H�������Y#  H�E�H�M�� H�E�H�xH�u��  H�E�H�}��A#  H�}� uH�=$  �Z  H�E�H�U��;  H�E�HE�H�E���   H�E؃8��   H�E�� ��[��   H�E�H��H�E�H�}�H�u��
   �#  H�E�H�E�H;E�tH�E�� ��]tH�=�#  ��   H�E�H�U��   H�}� |H�E�H�M�H;ArH�=�#  �   H�E�H�U��   H�E�H�@H�M�H��H�E�H�E�H��H�E��8H�E�� ��[uH�=v#  �f   H�E�H�U��JH�=�#  �P   H�E�H�U��4� H�E�� ��.uH�E�H��H�E������H�}��N   H�E�H�E�    H�E�H�U�H��`]�@ UH��H�� H�}�H�E�    H�}���!  H�E�H�E�H�U�H�� ]ÐUH��H��0  H�(  H� H�E�H������H������ uH�=#  �!  H�������  H������� H������H����   H������H�  Hc�H���H�=�"  �I!  H��������   H�������HH�=�"  H��"  ��HE��!  H�������   H������H�������@�   1�L�r"  H�ΰ�   H��������   H�������VH������H�x�   H�������=H�=6"  �   H�������(H�=)"  �   H�������H�="  �~   H������H������H������H��&  H� H�M�H9�uH������H��0  ]��   ���������s���3����������UH��H�� H�}�   �    H�E�H�}� u
H�E�    �uH�}� v
H�E�H�E���   H�E�� H�M�H�E�H�HH�E�H�@    H�E�H�x�   �  H��H�E�H�H�E�H�8 uH�}��v  H�E�    �H�E�H�E�H�E�H�� ]�fD  UH��H�� H�}�H�}� u�   H�E�    H�E�H�M�H;AsbH�E�H� H�M�H��H�E�H�}� t8H�E�H�@H�E�H�E�H�8��  H�E�H�x����H�}���  H�E�H�E���� H�E�H��H�E��H�E�H�8�  H�}��  H�� ]�D  UH��H��0H�}�H�u�H�U�H�E��~@(l#  fb�f(p#  f\�(�f��X��~Hfb�f\�(�f��X��!#  �Y�f.�r	H�}���   H�}��  H�M�1�H�qH�U�H�E�H� H�M�H��H�E�H�}� tAH�E�H�8H�u��  �� uH�E�H�x����H�M�H�E�H�H�   H�E�H�@H�E�븿   ��  H�E�H�}� u�nH�}���  H��H�E�H�H�E�H�8 uH�}��  �FH�M�H�E�H�HH�E�H� H�M�H��H�E�H�HH�U�H�E�H� H�M�H��H�E�H�HH��H�HH��0]ÐUH��H��@H�}�H�E�H�@H��H�E�H�}�   ��  H�E�H�}� uH�}#  H�8H�5�  � ��  �   H�E�    H�E�H�M�H;AsH�E�H� H�M�H��H�E�H�}� tRH�E�H�@H�E�H�E�H�8�w   1ɉ�H�u�H�U�H�E�H�M�H��H�E�H�HH�U�H�E�H�M�H��H�E�H�E��� H�E�H��H�E��s���H�E�H�8�B  H�M�H�E�H�H�M�H�E�H�HH��@]ÐUH��H�}��ŝ�H�E�H�E�H�E�H�E�8 t*H�E�H� H3E�H�E�HiE� H�E�H�E�H��H�E���H�E�]�fffff.�     UH��H��0H�}�H�u�H�}� tH�}� u
H�E�    �jH�}��o���H�M�1�H�qH�U�H�E�H� H�M�H��H�E�H�}� t1H�E�H�8H�u��y  �� uH�E�H�@H�E��H�E�H�@H�E���H�E�    H�E�H��0]�@ UH��H��0H�}�H�u�H�U�H�}� tH�}� uH�E�    �   H�}�H�u��   H�M�1�H�qH�U�H�E�H� H�M�H��H�E�H�}� tGH�E�H�8��  H;E�u'H�E�H�8H�u�H�U���  �� uH�E�H�@H�E��H�E�H�@H�E��H�E�    H�E�H��0]� UH��H�}�H�u�ŝ�H�E�H�E�    H�E�H;E�s/H�E�H�M�H�H3E�H�E�HiE� H�E�H�E�H��H�E���H�E�]�    UH��H��@H�}�H�u�H�E�H�E�H�E�H�E�H�E�H�E�H�}� tH�E�H�     H�}��   H�E�H�}� u!H�}� t
H�E�H�8 uH�}�H�5�  �  H�}� tKH�}� t
H�E�H�8 u:H�}��  H�E�� �� t#H�}�H�5~  �t  H�}�����H�E�    �5� H�}� t$H�E�H�8 tH�}� tH�}������H�E�    �H�E�H�E�H�E�H��@]�f�UH��H�� H�}�H�}���  H�E�H� � ��މ�H�M��YwaH�E�H�x   Hc�H���H�}��  H�E��VH�}��  H�E��GH�}��h  H�E��8� H�}���
  H�E��'H�}���  H�E��H�}�H�5�  �  H�E�    H�E�H�� ]Ñ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������     UH��H��@H�}�H�u�H�E�H�x ��   H�E�H�@H�8 ��   �E�   �E�   H�E�H�@H�E�H�E�H�M�H;s5H�E�� ��
u�E���E��E�   �	�E���E�H�E�H��H�E�뾿   �_  H�E�H�}� tDH�}�D�M�D�U�H�E�   1�H������L�?  D�$H�D$� ��  H�M�H�E�H�@H�� H��@]�f�UH��H��H�}�H�E�H� �1��� �E�tH�E�H� �8��  �� ���E��E��u�H�E�H�H��H��H��]�f�     UH��H��0H�}�H�}ؾ   �6   H�}� u
H�E�    �H�}�H�u��   H�}���  H�E�H�E�H��0]ÐUH��H�� H�}�H�u�H�}� v
H�E�H�E���   H�E�� H�M�H�E�H�HH�E�H�x�  H��H�E�H�H�E�H�8 t
H�E�H� �  H�E�H�@    H�� ]�ff.�     UH��H��PH�1  H� H�E�H�}�H�u�H�}� uH�}�H�5.  ��  ��   H�Eȋ H�E�H����   H�E�H��   Hc�H���H�}�H�5�  �  �   H�}�H�EȊHH�5�  H��  ��HE��t  �cH�}�H�E��@�    1�L��  H�ΰ��  H�}�H�u��@  �/H�E�H�xH�u��  �H�}�H�u��.  �H�}�H�u��  H�8  H� H�M�H9�uH��P]��  �������������~���W���B����     UH��H�� H�}�H�E�H�8 u
H�E�    �@H�E�H�8H�E�H�pH���d  H�E�H�}� t
H�E�H�E��H�E�H� H�E�H�E�H�E�H�E�H�� ]�fD  UH��H�� H�}�H�}��  H�E�H�}� u
H�E�    �<�   �L  H�E�H�}� uH�}���  H�E�    �H�M�H�E�H�HH�E�H�E�H�E�H�� ]�UH��H�� H�}�H�E�H�H��H��   ��
  H�E�H�}� uH�E�    �  H�E�H�@   H�E�H�@    H�E�H�xH���Q  H��H�E�H�HH�E�H�x uH�}��   H�E�    ��  H�}�����H�E�H� � ��]uH�E�H�H��H�H�E�H�E��  � H�E�H� �8 �b  H�}������H�E�H�}� uH�}��}���H�E�    �Y  H�E�H�@H�M�H;ArNH�E�H�HH��H�HH�}�H��H�E�H�pH���F
  �� uH�}��(���H�}�����H�E�    ��   � H�U�H�E�H�@H�u�H�NH��H��H�~H��H�}��$���H�E�H� � ��]uH�E�H�H��H�H�E�H�E��   H�E�H� � ��,uKH�E�H�H��H�H�}������H�E�H� � ��]u#H�}�H�5�  �����H�}��l���H�E�    �K�#H�}�H�5�  ����H�}��G���H�E�    �&����H�}�H�5�  �x���H�}�����H�E�    H�E�H�� ]�ffff.�     UH��H��0H�}�H�E�H�H��H�1��  H�E�H�}� uH�E�    �V  �   �����H��H�E�H�HH�E�H�x uH�}���  H�E�    �   H�}������H�E�H� � ��}uH�E�H�H��H�H�E�H�E���  � H�E�H� �8 ��  H�E�H� � ��"t&H�}�H�5�  �}���H�}��$���H�E�    �  H�}���  H�E�H�}� uH�}������H�E�    �|  H�}��$���H�E�H� � ��:t/H�}�H�5}  ����H�}���  H�}�����H�E�    �5  H�E�H�H��H�H�}�����H�E�H�}� uH�}��  H�}��r���H�E�    ��   H�E�H�xH�u�H�U������H�}��{  H�}��~���H�E�H� � ��}uH�E�H�H��H�H�E�H�E��   H�E�H� � ��,uKH�E�H�H��H�H�}��.���H�E�H� � ��}u#H�}�H�5�  ����H�}������H�E�    �K�#H�}�H�5�  �����H�}�����H�E�    �&�6���H�}�H�5�  �����H�}��y���H�E�    H�E�H��0]��    UH��H��0H�}�H�E�H� H�E�H�E�H� � ��-uH�E�H�H��H�� H�E�H� �8�U  �� tH�E�H�H��H���H�E�H� � ��.u4H�E�H�H��H�H�E�H� �8�  �� tH�E�H�H��H���� H�E�H� � ��etH�E�H� � ��E��   H�E�H�H��H�H�E�H� � ��+tH�E�H� � ��-uH�E�H�H��H�H�E�H� �8�  �� uH�}�H�5k  ����H�E�    ��   � H�E�H� �8�_  �� tH�E�H�H��H���� �   �  H�E�H�}� uH�E�    �   H�E�H� H�M�H)�H�E�H�}�H���  H�E�H�}� uH�}���  H�E�    �KH�}�H�u�H�U�H�������  H�E�H�M�� H�}�1�����  H�E��@H�}��  H�E�H�E�H�E�H��0]�f.�     UH��H�� H�}�H�E�H�8H�5	  �   �  �� uEH�E�H�H��H��   �  H�E�H�}� uH�E�    ��   H�E��@H�E�H�E��   H�E�H�8H�5�  �   �.  �� u?H�E�H�H��H��   �M  H�E�H�}� u
H�E�    �eH�E��@ H�E�H�E��SH�E�H�8H�5F  �   ��
  �� uH�E�H�H��H��   ��  H�E��H�}�H�5�  ����H�E�    H�E�H�� ]�f�     UH��H��@H�}�H�E�H�H��H�H�E�H� H�E�H�E�H�E�H�E��1��� �E�tH�E�� ��"���EǊEǨu�=H�E�� ��\u#H�E�H��H�E�H�E��8 tH�E�H��H�E��H�E�H��H�E��H�E�� ��"tH�}�H�5  �����H�E�    ��  H�}�H�E�H)�H���	  H�E�H�}� u%H��  H�8H�5�  � �Z	  H�E�    �  H�E�H�E�H�E�H�E�H�E�H;E��w  H�E�� ��\�@  H�E�H��H�E�H�E�� �E���"t[� �E���/t� �E���\t^� �E���bt� �E���f��   � �E���n��   � �E���r��   � �E���t��   �   H�E�H��H��H�M�� "�   H�E�H��H��H�M�� \�   H�E�H��H��H�M�� /�{H�E�H��H��H�M�� �gH�E�H��H��H�M�� �SH�E�H��H��H�M�� 
�?H�E�H��H��H�M�� �+H�E�H��H��H�M�� 	�H�EȊH�E�H��H��H�UЈH�E�H��H�E��"H�E�H��H��H�MȊH�E�H��H��H�UЈ�{���H�E��  H�M�H��H�E�H�H�E�H�E�H�E�H��@]�f�UH��H�� �}��   �    �n  H�E�H�}� u"H��  H�8H�5
  � �Q  H�E�    ��M�H�E�H�E�H�E�H�E�H�� ]�fffff.�     UH��H�� H�}�H�u�H�E�H�8H�u��  H�E�H�}� u(H�}� v!H�o  H�8H�5
  � ��  �E�    �H�M�H�E�H��E�   �E�H�� ]�f�UH��H�� H�}�H�u�H�}���  H�E�H�}�H�u��V  �u�FH�E�H�8H�E�HxH�u�H�U�H�������7  H�M�H�E�HHH�HH�E�H� H�M�H�I� H�� ]�@ UH��H��0H�}�H�u�H�}�"   �  H�E�H�E�H�E�8 �C  H�E�� �E܃�ts� �E܃�	��   � �E܃�
��   � �E܃�tb� �E܃�t� �E܃�"t� �E܃�\t�   H�}�H�5
  �������   H�}�H�5�	  ������   H�}�H�5�	  �����   H�}�H�5�	  �����   H�}�H�5�	  �����rH�}�H�5�	  �����`H�}�H�5�	  �m����NH�E�� �� }0H�}�H�E�D� 1��   H��	  � ��  H�}�H�u��1����H�}�H�E��0�o  � � H�E�H��H�E�����H�}�"   �L  H��0]�fD  UH��H�� H�}�H�u�H�}�[   �"  H�E�    H�E�H�M�H;As<H�}� vH�}�,   ��  H�E�H�@H�M�H�<�H�u��~���H�E�H��H�E��H�}�]   ��  H�� ]�fff.�     UH��H��0H�}�H�u�H�}�{   �  �E�H�E�H�@H�E�H�E�    H�E�H�M�H;A��   H�E�H� H�M�H��H�E�H�}� tU�E�uH�}�,   �:  H�E�H�8H�u��Z���H�}�:   �  H�E�H�xH�u������E� H�E�H�@H�E��� H�E�H��H�E��l���H�}�}   ��   H��0]�f�UH��H��0H�}�H�u�H�E�H�8 u	�E� �   H�E�H�@HE�H�M�H;Ar~H�E�H�@H�E�H�E�H�M�H�IHM�H9�wH�E�H��H�E���H�E�H�8H�u���  H�E�H�}� uH�/	  H�8H�5�  � �  �E� �H�M�H�E�H�H�M�H�E�H�H�E��E�$H��0]�f.�     UH��H��@��H�}��E�H�}��   �����u�3�U�H�E�H� H�u�H�NH��H��H�~�H�E�H� H�M�H�I� H��]� UH��H��@H�}�H�u�H�E�    H�}�H�u������H�E�H�}� u+H�}� t
H�E�H�E��H�=K  ��  H�E�H�E�H�E��@H�}�H�u��(���H�E�H�U�H�}��W���H�}� tH�}��{  H�E�H�E��H�E�H�E�H�E�H��@]�ff.�     UH��H��H�}�H�}� t	H�}��8  H��]�fffff.�     UH��H�� H�}�H�E�    H�}�H�u������H�E�H�}� t#H�}���   H�}� t	H�}�����H�E�    �H�E�H�E�H�E�H�� ]�ffffff.�     UH��H��H�}�H�}��k���H��]�D  UH��H��0H�}�H�u�H�}� uH�=/  �   H�E��7H�}�H�u������H�E�H�U�H�}� tH�}��F   H�E�H�E��H�E�H�E�H�E�H��0]��%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  �%�  Failed to query on a null root node. Error: Attempted to index an object with array syntax. .[ Memory allocation failed for query key. Error: Key not found in path. Error: Invalid or unclosed array index. Error: Array index out of bounds. Error: Attempted to index a non-array value. Error: Attempted to access key on a non-object value. null true false %g [Array] [Object] unknown Webs Hash: Failed to allocate memory for resize.
 Memory allocation failed during parsing. Extra content after top-level value. Invalid JSON value. Unterminated string literal. Webs Parser: Memory allocation failed for unescaped string.
 Webs Parser: Failed to allocate memory for WebsValue.
 Trailing comma in array. Expected ',' or ']' in array. Unterminated array. Webs Parser: Memory reallocation failed.
 Expected string key in object. Expected ':' after key in object. Trailing comma in object. Expected ',' or '}' in object. Unterminated object. Invalid number format (exponent). Invalid literal. Error at line %d, col %d: %s Webs Encoder: Failed to reallocate string builder.
 \" \\ \b \f \n \r \t \u%04x Error: An unknown parsing error occurred. Error: Cannot query a null value.        �?          0C  0E              0C      0E                       p  @   @   z)      @                                                                                                                                                                                                                                                                                               �     �     �     �     �     �     �     �     �	     �
     �     �     �     �     �     �     �     �     �     �      �                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                H   �                                     0                 >  \  �  �  �  �  �  �    , < N ^ n ~ � � �  ___memcpy_chk ___snprintf_chk ___sprintf_chk ___stack_chk_fail ___stack_chk_guard ___stderrp ___strncpy_chk _calloc _fprintf _free _isdigit _isspace _malloc _realloc _strcmp _strdup _strlen _strncmp _strpbrk _strtod _strtol     _webs_ �    �P  �Q  string value  �  �  �  �_len 3 �  create )free .get 8set C �  �(  decode bencode g �Q  �O  �R  json �value � �  �
  free �query � free_ hash_ Hjson_ lparse_json ~query_ �value_ �  ���0�����`��`���`P��pp�����pp�����`�0p        �    �      �           �    p          �          @      %    �      2    �      =    �      N    `      W    �      j           x    �      �           �    p      �          �           �    P      �    "      �    �"      �    �"          p#           %      ,    �%      @    p&      T    @'         d          d  d           �  d           �  f ��h       .  p      �   $  p         $   �          N  p         .  0      �   $  0         $   �         N  0         .  �      �  $  �         $   0          N  �         .         �  $            $   �         N            d          �  d             d           "  f ���h       .  �	      %   $  �	         $   �          N  �	         .  P
      7   $  P
         $   �          N  P
         .         i   $            $   p         N            .  p      �  $  p         $            N  p         .  �        $  �         $   `          N  �         .  �      G   $  �         $   �          N  �         .  �      V   $  �         $   �          N  �         .  @        $  @         $   \          N  @         d          Y  d           �  d           �  f ���h       .  �      x   $  �         $             N  �         .  �      %  $  �         $             N  �         .  �      2  $  �         $   �          N  �         .  �      =  $  �         $   `          N  �         .        �   $           $   P          N           .  `      N  $  `         $   �          N  `         .  �      W  $  �         $   @         N  �         .         j  $            $   p          N            .  �      x  $  �         $   p          N  �         .         �  $            $   p         N            .  p      �  $  p         $   �         N  p         .        �  $           $            N           .         �  $            $   0         N            .  P      �  $  P         $   �         N  P         .  "      �  $  "         $   p          N  "         .  �"      �  $  �"         $   p          N  �"         .  �"      �  $  �"         $   �          N  �"         .  p#        $  p#         $   �         N  p#         .   %        $   %         $   �          N   %         .  �%      ,  $  �%         $   �          N  �%         .  p&      @  $  p&         $   �          N  p&         .  @'      T  $  @'         $   _          N  @'         d          �  d             d             f ���h       .  �'      �   $  �'         $   �          N  �'         .  P(         $  P(         $   0          N  P(         .  �(      �   $  �(         $   p          N  �(         .  �(         $  �(         $              N  �(         .  )      �   $  )         $   j          N  )         d               P(           �(      %     �	      7     P
      G     �      V     �      i            x     �      �           �     �(      �     �'      �     )      �     p      �     0      �                                                  2            E            P            _            g            p            v                        �            �            �            �            �            �            �            �            �            �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �     _webs_free_string _webs_free_value _webs_hash_create _webs_hash_free _webs_hash_get _webs_hash_get_len _webs_hash_set _webs_json_decode _webs_json_encode _webs_parse_json _webs_query_json _webs_query_value _webs_value_free _webs_value_query ___memcpy_chk ___snprintf_chk ___sprintf_chk ___stack_chk_fail ___stack_chk_guard ___stderrp ___strncpy_chk _calloc _fprintf _free _isdigit _isspace _malloc _realloc _strcmp _strdup _strlen _strncmp _strpbrk _strtod _strtol _create_error_result _format_node_value _webs_hash_resize _hash_key _hash_key_len _parse_value _set_error _skip_whitespace _sb_init _webs_encode_value _sb_to_string _parse_string _parse_array _parse_object _parse_number _parse_literal _parse_allocated_string _create_node _webs_realloc_safe _sb_append_str _webs_encode_string _webs_encode_array _webs_encode_object _sb_ensure_capacity _sb_append_char /Users/conradklek/webs/lib/native/src/core/ webs_value.c /Users/conradklek/webs/lib/native/src/core/webs_value.o _create_error_result /Users/conradklek/webs/lib/native/src/core/ webs_hash.c /Users/conradklek/webs/lib/native/src/core/webs_hash.o /Users/conradklek/webs/lib/native/src/codecs/ webs_codec_json.c /Users/conradklek/webs/lib/native/src/codecs/webs_codec_json.o /Users/conradklek/webs/lib/native/src/api/ webs_api.c /Users/conradklek/webs/lib/native/src/api/webs_api.o      
---------- END: native/.webs.dylib ----------

---------- START: native/Makefile ----------
CC = clang
TARGET = .webs.dylib

# Add the new hash table source files to the include path and sources list
CFLAGS = -fPIC -g -Isrc/core -Isrc/codecs -Isrc/api
LDFLAGS = -shared

CORE_SOURCES = src/core/webs_value.c src/core/webs_hash.c
CODEC_SOURCES = src/codecs/webs_codec_json.c
API_SOURCES = src/api/webs_api.c

# Removed the unused SAX_SOURCES variable for clarity
ALL_SOURCES = $(CORE_SOURCES) $(CODEC_SOURCES) $(API_SOURCES)

ALL_OBJECTS = $(ALL_SOURCES:.c=.o)

# Default target
all: $(TARGET)

# Link all object files into the final shared library
$(TARGET): $(ALL_OBJECTS)
	$(CC) $(LDFLAGS) -o $@ $^

# Generic rule to compile any .c file into a .o file
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Clean up build artifacts
clean:
	rm -f $(TARGET) $(ALL_OBJECTS)

# Declare targets that are not files
.PHONY: all clean


---------- END: native/Makefile ----------

---------- START: native/src/api/webs_api.c ----------
#include "webs_api.h"
#include "../codecs/webs_codec_json.h"
#include "../core/webs_value.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char *webs_query_json(const char *json_string, const char *path) {
  char *parse_error = NULL;
  WebsValue *root = webs_json_decode(json_string, &parse_error);

  if (!root) {
    return parse_error ? parse_error
                       : strdup("Error: An unknown parsing error occurred.");
  }

  WebsResult query_result = webs_value_query(root, path);
  webs_value_free(root);

  if (query_result.error) {
    free(query_result.result);
    return query_result.error;
  }

  return query_result.result;
}

void webs_free_string(char *str) {
  if (str) {
    free(str);
  }
}

WebsValue *webs_parse_json(const char *json_string) {
  char *parse_error = NULL;
  WebsValue *value = webs_json_decode(json_string, &parse_error);

  if (parse_error) {
    free(parse_error);
    if (value) {
      webs_value_free(value);
    }
    return NULL;
  }
  return value;
}

void webs_free_value(WebsValue *value) { webs_value_free(value); }

char *webs_query_value(const WebsValue *value, const char *path) {
  if (!value) {
    return strdup("Error: Cannot query a null value.");
  }
  WebsResult query_result = webs_value_query((WebsValue *)value, path);
  if (query_result.error) {
    free(query_result.result);
    return query_result.error;
  }
  return query_result.result;
}

---------- END: native/src/api/webs_api.c ----------

---------- START: native/src/api/webs_api.h ----------
#ifndef WEBS_API_H
#define WEBS_API_H

typedef struct WebsValue WebsValue;

const char *webs_query_json(const char *json_string, const char *path);

void webs_free_string(char *str);

WebsValue *webs_parse_json(const char *json_string);

char *webs_json_encode(const WebsValue *value);

void webs_free_value(WebsValue *value);

#endif

---------- END: native/src/api/webs_api.h ----------

---------- START: native/src/api/webs_api.o ----------
����           �                                       �      �      �                   __text          __TEXT                  �      �     �       �            __cstring       __TEXT          �      L       �                             __debug_abbrev  __DWARF         &            �                             __debug_info    __DWARF         -      Z      �                             __debug_str_offs__DWARF         �      �       /
                             __debug_str     __DWARF         O      �      �
                             __debug_addr    __DWARF         �      @       ~      �                    __debug_names   __DWARF         	      �      �                            __compact_unwind__LD            �
      �       �     0                    __eh_frame      __TEXT          �      �       (               h            __debug_line    __DWARF         `      �            X                    __debug_line_str__DWARF               �       �                             2                         `  
      �      P                                                                        UH��H��@H�}�H�u�H�E�    H�}�H�u��    H�E�H�}� u+H�}� t
H�E�H�E��H�=�  �    H�E�H�E�H�E��@H�}�H�u��    H�E�H�U�H�}��    H�}� tH�}��    H�E�H�E��H�E�H�E�H�E�H��@]�ff.�     UH��H��H�}�H�}� t	H�}��    H��]�fffff.�     UH��H�� H�}�H�E�    H�}�H�u��    H�E�H�}� t#H�}��    H�}� t	H�}��    H�E�    �H�E�H�E�H�E�H�� ]�ffffff.�     UH��H��H�}�H�}��    H��]�D  UH��H��0H�}�H�u�H�}� uH�=v   �    H�E��7H�}�H�u��    H�E�H�U�H�}� tH�}��    H�E�H�E��H�E�H�E�H�E�H��0]�Error: An unknown parsing error occurred. Error: Cannot query a null value. %%%�|%�%r%s  4 I:;  I  ! I7  $ %>  $ %>  I:;  ( %  	 I  
 I%:;  %:;   %I:;8  :;  :;   %<  .@%:;'I?   %:;I  4 %:;I  .@%:;'?  & I   V                �     /    � ;   ?   * M    4�;   ?   " t   	 	
 	}   
�   !! �    �   & �   ! �   " 5  # :  $ >  %   
Y   
�   �     	�   
�   
  $   )  )   	x   
1  	;    �   V"   �p'   �h(   �`) 	5  �X* 
x   �H+ 0   "   V# �x/ 5   a   V$ "#  �p' "  �h) #5  �` $x       V% 0�x 0x    j   V& 25  �p 2O  �h( 2  �X+ 60   	  ;   	(  
�   !
8  .,),5  * -5  + 	T  }    �          /   B   v   �   �   �   �   �   �   �   �        :  ?  M  S  i  o  ^  }  �  �  �  �  �  �  �  �  �  �  �  0  �  �      +  <  H  M  Y  ^  v  }  k  �  Apple clang version 17.0.0 (clang-1700.3.19.1) src/api/webs_api.c /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk MacOSX.sdk /Users/conradklek/webs/lib/native char __ARRAY_SIZE_TYPE__ unsigned int WEBS_VALUE_OBJECT WEBS_VALUE_ARRAY WEBS_VALUE_STRING WEBS_VALUE_NUMBER WEBS_VALUE_BOOL WEBS_VALUE_NULL WebsValue type WebsValueType value object_val WebsObject table WebsHashTable array_val WebsArray elements count size_t unsigned long capacity string_val number_val double bool_val _Bool webs_query_json webs_free_string webs_parse_json webs_free_value webs_query_value json_string path parse_error root query_result WebsResult result error str <     �                    �       �       P      p        �                	      !      LLVM0700                                 B�T�r��� [=������<�͓<�����j�`���`RG�O��b��"5w�H3���L�c �|o  �  �  �  �  +  �   �    �    �  ^  k  ?  0  �   �                      $   *   0   6   <   B   H   N   T   Z   j   p     $  .     �    1   :   >   �   �   t    )   �   B   �   �    �    0   �    }   �   (   ?    ;                 �                      �       "                      �       a                      P                            p      j                             zR x�  $      `��������        A�C       $   D   ��������"        A�C       $   l   ��������a        A�C       $   �   8�������        A�C       $   �   0�������j        A�C       �    �   �          "   <   y   �    ��%s�؜1�L��Д   u8mW���i g৛L��   ,D�!����.��.ehg�   �m%Ns�ċF!�^Y�q  	        	
�&�J�LX/t�/r�J.j4JJ�JZX/JYJiJKJ 
�X
/JZ >	
�'�J�LX
/J	YX/JZ
�JKJ L:
�*JBX �
�X/�;hBJJ�X/JYJhJKJ /Users/conradklek/webs/lib/native src/api/../codecs/../core /Library/Developer/CommandLineTools/usr/lib/clang/17/include src/api src/api/webs_api.c webs_value.h __stddef_size_t.h webs_api.h       �    -�  	  -�    -�    a    -!    -    -�     -�     -�     -u     -d   	  -I     -D     !     -8     0     (                          �     `     @                 �     =     �       a     P      ,     �                    O     p      }                            �              r                             _webs_value_query _strdup _webs_query_json _webs_parse_json _webs_free_string _webs_query_value _webs_free_value _webs_value_free _webs_json_decode    
---------- END: native/src/api/webs_api.o ----------

---------- START: native/src/codecs/webs_codec_json.c ----------
#include "webs_codec_json.h"
#include "../core/webs_hash.h"
#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  const char *current;
  const char *start;
  char **error;
} Parser;

static WebsValue *parse_value(Parser *p);

static int webs_realloc_safe(void **ptr, size_t new_size) {
  void *new_ptr = realloc(*ptr, new_size);
  if (!new_ptr && new_size > 0) {
    fprintf(stderr, "Webs Parser: Memory reallocation failed.\n");
    return 0;
  }
  *ptr = new_ptr;
  return 1;
}

static WebsValue *create_node(WebsValueType type) {
  WebsValue *node = (WebsValue *)calloc(1, sizeof(WebsValue));
  if (!node) {
    fprintf(stderr, "Webs Parser: Failed to allocate memory for WebsValue.\n");
    return NULL;
  }
  node->type = type;
  return node;
}

static void set_error(Parser *p, const char *message) {
  if (p->error && !*p->error) {
    int line = 1;
    int col = 1;
    const char *temp = p->start;
    while (temp < p->current) {
      if (*temp == '\n') {
        line++;
        col = 1;
      } else {
        col++;
      }
      temp++;
    }
    char *err_buf = (char *)malloc(256);
    if (err_buf) {
      snprintf(err_buf, 256, "Error at line %d, col %d: %s", line, col,
               message);
      *p->error = err_buf;
    }
  }
}

static void skip_whitespace(Parser *p) {
  while (*p->current && isspace((unsigned char)*p->current)) {
    p->current++;
  }
}

static char *parse_allocated_string(Parser *p) {
  p->current++;
  const char *start = p->current;
  const char *end = start;

  while (*end && *end != '"') {
    if (*end == '\\') {
      end++;
      if (*end)
        end++;
    } else {
      end++;
    }
  }

  if (*end != '"') {
    set_error(p, "Unterminated string literal.");
    return NULL;
  }

  char *unescaped_str = (char *)malloc(end - start + 1);
  if (!unescaped_str) {
    fprintf(stderr,
            "Webs Parser: Memory allocation failed for unescaped string.\n");
    return NULL;
  }

  char *writer = unescaped_str;
  const char *reader = start;
  while (reader < end) {
    if (*reader == '\\') {
      reader++;
      switch (*reader) {
      case '"':
        *writer++ = '"';
        break;
      case '\\':
        *writer++ = '\\';
        break;
      case '/':
        *writer++ = '/';
        break;
      case 'b':
        *writer++ = '\b';
        break;
      case 'f':
        *writer++ = '\f';
        break;
      case 'n':
        *writer++ = '\n';
        break;
      case 'r':
        *writer++ = '\r';
        break;
      case 't':
        *writer++ = '\t';
        break;
      default:
        *writer++ = *reader;
        break;
      }
      reader++;
    } else {
      *writer++ = *reader++;
    }
  }
  *writer = '\0';

  p->current = end + 1;
  return unescaped_str;
}

static WebsValue *parse_string(Parser *p) {
  char *str_val = parse_allocated_string(p);
  if (!str_val)
    return NULL;

  WebsValue *node = create_node(WEBS_VALUE_STRING);
  if (!node) {
    free(str_val);
    return NULL;
  }
  node->value.string_val = str_val;
  return node;
}

static WebsValue *parse_number(Parser *p) {
  const char *start = p->current;
  if (*p->current == '-')
    p->current++;
  while (isdigit((unsigned char)*p->current))
    p->current++;
  if (*p->current == '.') {
    p->current++;
    while (isdigit((unsigned char)*p->current))
      p->current++;
  }
  if (*p->current == 'e' || *p->current == 'E') {
    p->current++;
    if (*p->current == '+' || *p->current == '-')
      p->current++;
    if (!isdigit((unsigned char)*p->current)) {
      set_error(p, "Invalid number format (exponent).");
      return NULL;
    }
    while (isdigit((unsigned char)*p->current))
      p->current++;
  }

  WebsValue *node = create_node(WEBS_VALUE_NUMBER);
  if (!node)
    return NULL;

  size_t len = p->current - start;
  char *num_str = malloc(len + 1);
  if (!num_str) {
    free(node);
    return NULL;
  }
  memcpy(num_str, start, len);
  num_str[len] = '\0';

  node->value.number_val = strtod(num_str, NULL);
  free(num_str);

  return node;
}

static WebsValue *parse_literal(Parser *p) {
  WebsValue *node;
  if (strncmp(p->current, "true", 4) == 0) {
    p->current += 4;
    node = create_node(WEBS_VALUE_BOOL);
    if (!node)
      return NULL;
    node->value.bool_val = true;
    return node;
  }
  if (strncmp(p->current, "false", 5) == 0) {
    p->current += 5;
    node = create_node(WEBS_VALUE_BOOL);
    if (!node)
      return NULL;
    node->value.bool_val = false;
    return node;
  }
  if (strncmp(p->current, "null", 4) == 0) {
    p->current += 4;
    return create_node(WEBS_VALUE_NULL);
  }
  set_error(p, "Invalid literal.");
  return NULL;
}

static WebsValue *parse_array(Parser *p) {
  p->current++;

  WebsValue *node = create_node(WEBS_VALUE_ARRAY);
  if (!node)
    return NULL;

  node->value.array_val.capacity = 8;
  node->value.array_val.count = 0;
  node->value.array_val.elements =
      malloc(sizeof(WebsValue *) * node->value.array_val.capacity);
  if (!node->value.array_val.elements) {
    free(node);
    return NULL;
  }

  skip_whitespace(p);
  if (*p->current == ']') {
    p->current++;
    return node;
  }

  while (*p->current) {
    WebsValue *element = parse_value(p);
    if (!element) {
      webs_value_free(node);
      return NULL;
    }

    if (node->value.array_val.count >= node->value.array_val.capacity) {
      node->value.array_val.capacity *= 2;
      if (!webs_realloc_safe((void **)&node->value.array_val.elements,
                             sizeof(WebsValue *) *
                                 node->value.array_val.capacity)) {
        webs_value_free(element);
        webs_value_free(node);
        return NULL;
      }
    }
    node->value.array_val.elements[node->value.array_val.count++] = element;

    skip_whitespace(p);
    if (*p->current == ']') {
      p->current++;
      return node;
    }
    if (*p->current == ',') {
      p->current++;
      skip_whitespace(p);
      if (*p->current == ']') {
        set_error(p, "Trailing comma in array.");
        webs_value_free(node);
        return NULL;
      }
    } else {
      set_error(p, "Expected ',' or ']' in array.");
      webs_value_free(node);
      return NULL;
    }
  }

  set_error(p, "Unterminated array.");
  webs_value_free(node);
  return NULL;
}

static WebsValue *parse_object(Parser *p) {
  p->current++;

  WebsValue *node = create_node(WEBS_VALUE_OBJECT);
  if (!node)
    return NULL;

  node->value.object_val.table = webs_hash_create(8);
  if (!node->value.object_val.table) {
    free(node);
    return NULL;
  }

  skip_whitespace(p);
  if (*p->current == '}') {
    p->current++;
    return node;
  }

  while (*p->current) {
    if (*p->current != '"') {
      set_error(p, "Expected string key in object.");
      webs_value_free(node);
      return NULL;
    }

    char *key_string = parse_allocated_string(p);
    if (!key_string) {
      webs_value_free(node);
      return NULL;
    }

    skip_whitespace(p);
    if (*p->current != ':') {
      set_error(p, "Expected ':' after key in object.");
      free(key_string);
      webs_value_free(node);
      return NULL;
    }
    p->current++;

    WebsValue *value_node = parse_value(p);
    if (!value_node) {
      free(key_string);
      webs_value_free(node);
      return NULL;
    }

    webs_hash_set(node->value.object_val.table, key_string, value_node);
    free(key_string);

    skip_whitespace(p);
    if (*p->current == '}') {
      p->current++;
      return node;
    }
    if (*p->current == ',') {
      p->current++;
      skip_whitespace(p);
      if (*p->current == '}') {
        set_error(p, "Trailing comma in object.");
        webs_value_free(node);
        return NULL;
      }
    } else {
      set_error(p, "Expected ',' or '}' in object.");
      webs_value_free(node);
      return NULL;
    }
  }

  set_error(p, "Unterminated object.");
  webs_value_free(node);
  return NULL;
}

static WebsValue *parse_value(Parser *p) {
  skip_whitespace(p);
  switch (*p->current) {
  case '"':
    return parse_string(p);
  case '[':
    return parse_array(p);
  case '{':
    return parse_object(p);
  case '-':
  case '0' ... '9':
    return parse_number(p);
  case 't':
  case 'f':
  case 'n':
    return parse_literal(p);
  default:
    set_error(p, "Invalid JSON value.");
    return NULL;
  }
}

WebsValue *webs_json_decode(const char *json_string, char **error) {
  Parser p = {.current = json_string, .start = json_string, .error = error};
  if (error) {
    *error = NULL;
  }

  WebsValue *root = parse_value(&p);

  if (!root && (!error || !*error)) {
    set_error(&p, "Memory allocation failed during parsing.");
  }

  if (root && (!error || !*error)) {
    skip_whitespace(&p);
    if (*p.current != '\0') {
      set_error(&p, "Extra content after top-level value.");
      webs_value_free(root);
      return NULL;
    }
  }

  if (error && *error && root) {
    webs_value_free(root);
    return NULL;
  }

  return root;
}

typedef struct {
  char *buffer;
  size_t length;
  size_t capacity;
} StringBuilder;

static void sb_init(StringBuilder *sb, size_t initial_capacity) {
  sb->capacity = initial_capacity > 0 ? initial_capacity : 256;
  sb->buffer = malloc(sb->capacity);
  if (sb->buffer) {
    sb->buffer[0] = '\0';
  }
  sb->length = 0;
}

static bool sb_ensure_capacity(StringBuilder *sb, size_t additional_length) {
  if (!sb->buffer)
    return false;
  if (sb->length + additional_length >= sb->capacity) {
    size_t new_capacity = sb->capacity;
    while (new_capacity <= sb->length + additional_length) {
      new_capacity *= 2;
    }
    char *new_buffer = realloc(sb->buffer, new_capacity);
    if (!new_buffer) {
      fprintf(stderr, "Webs Encoder: Failed to reallocate string builder.\n");
      return false;
    }
    sb->buffer = new_buffer;
    sb->capacity = new_capacity;
  }
  return true;
}

static void sb_append_str(StringBuilder *sb, const char *str) {
  size_t len = strlen(str);
  if (!sb_ensure_capacity(sb, len))
    return;
  memcpy(sb->buffer + sb->length, str, len);
  sb->length += len;
  sb->buffer[sb->length] = '\0';
}

static void sb_append_char(StringBuilder *sb, char c) {
  if (!sb_ensure_capacity(sb, 1))
    return;
  sb->buffer[sb->length++] = c;
  sb->buffer[sb->length] = '\0';
}

static char *sb_to_string(StringBuilder *sb) {
  if (!sb->buffer)
    return NULL;
  char *final_str = realloc(sb->buffer, sb->length + 1);
  return final_str ? final_str : sb->buffer;
}

static void webs_encode_value(const WebsValue *value, StringBuilder *sb);

static void webs_encode_string(const char *str, StringBuilder *sb) {
  sb_append_char(sb, '"');
  for (const char *p = str; *p; p++) {
    switch (*p) {
    case '"':
      sb_append_str(sb, "\\\"");
      break;
    case '\\':
      sb_append_str(sb, "\\\\");
      break;
    case '\b':
      sb_append_str(sb, "\\b");
      break;
    case '\f':
      sb_append_str(sb, "\\f");
      break;
    case '\n':
      sb_append_str(sb, "\\n");
      break;
    case '\r':
      sb_append_str(sb, "\\r");
      break;
    case '\t':
      sb_append_str(sb, "\\t");
      break;
    default:
      if ((unsigned char)*p < 32) {
        char hex_buf[7];
        sprintf(hex_buf, "\\u%04x", (unsigned char)*p);
        sb_append_str(sb, hex_buf);
      } else {
        sb_append_char(sb, *p);
      }
      break;
    }
  }
  sb_append_char(sb, '"');
}

static void webs_encode_object(const WebsValue *value, StringBuilder *sb) {
  sb_append_char(sb, '{');
  bool first = true;
  WebsHashTable *table = value->value.object_val.table;
  for (size_t i = 0; i < table->capacity; i++) {
    WebsHashEntry *entry = table->entries[i];
    while (entry) {
      if (!first) {
        sb_append_char(sb, ',');
      }
      webs_encode_string(entry->key, sb);
      sb_append_char(sb, ':');
      webs_encode_value(entry->value, sb);
      first = false;
      entry = entry->next;
    }
  }
  sb_append_char(sb, '}');
}

static void webs_encode_array(const WebsValue *value, StringBuilder *sb) {
  sb_append_char(sb, '[');
  for (size_t i = 0; i < value->value.array_val.count; i++) {
    if (i > 0) {
      sb_append_char(sb, ',');
    }
    webs_encode_value(value->value.array_val.elements[i], sb);
  }
  sb_append_char(sb, ']');
}

static void webs_encode_value(const WebsValue *value, StringBuilder *sb) {
  if (!value) {
    sb_append_str(sb, "null");
    return;
  }

  switch (value->type) {
  case WEBS_VALUE_NULL:
    sb_append_str(sb, "null");
    break;
  case WEBS_VALUE_BOOL:
    sb_append_str(sb, value->value.bool_val ? "true" : "false");
    break;
  case WEBS_VALUE_NUMBER: {
    char num_buf[32];
    snprintf(num_buf, sizeof(num_buf), "%g", value->value.number_val);
    sb_append_str(sb, num_buf);
    break;
  }
  case WEBS_VALUE_STRING:
    webs_encode_string(value->value.string_val, sb);
    break;
  case WEBS_VALUE_ARRAY:
    webs_encode_array(value, sb);
    break;
  case WEBS_VALUE_OBJECT:
    webs_encode_object(value, sb);
    break;
  }
}

char *webs_json_encode(const WebsValue *value) {
  StringBuilder sb;
  sb_init(&sb, 1024);
  if (!sb.buffer)
    return NULL;

  webs_encode_value(value, &sb);

  return sb_to_string(&sb);
}

---------- END: native/src/codecs/webs_codec_json.c ----------

---------- START: native/src/codecs/webs_codec_json.h ----------
#ifndef WEBS_CODEC_JSON_H
#define WEBS_CODEC_JSON_H

#include "../core/webs_value.h"

WebsValue *webs_json_decode(const char *json_string, char **error);

char *webs_json_encode(const WebsValue *value);

#endif

---------- END: native/src/codecs/webs_codec_json.h ----------

---------- START: native/src/codecs/webs_codec_json.o ----------
����           �                                       �F      �      �F                   __text          __TEXT                  �      �     �K  �     �            __cstring       __TEXT          �      �      �                             __debug_abbrev  __DWARF         �      �      a                             __debug_info    __DWARF         B      	      �                              __debug_str_offs__DWARF         O%      �      *                             __debug_str     __DWARF         �&      �      �+                             __debug_addr    __DWARF         �+             a0      �P  ?                  __debug_names   __DWARF         �-      t      d2                            __compact_unwind__LD             1      �      �5     �R                    __eh_frame      __TEXT          �3      �      �8               h            __debug_line    __DWARF         h7      �       <      �S                    __debug_line_str__DWARF         <F      �       �J                             2                   )      �S           �S  )   HV  @     P                                                                      UH��H��@H�}�H�u�H�E�H�E�H�E�H�E�H�E�H�E�H�}� tH�E�H�     H�}��    H�E�H�}� u!H�}� t
H�E�H�8 uH�}�H�5�  �    H�}� tKH�}� t
H�E�H�8 u:H�}��    H�E�� �� t#H�}�H�5�  �    H�}��    H�E�    �5� H�}� t$H�E�H�8 tH�}� tH�}��    H�E�    �H�E�H�E�H�E�H��@]�f�UH��H�� H�}�H�}��    H�E�H� � ��މ�H�M��YwaH�E�H�x   Hc�H���H�}��    H�E��VH�}��    H�E��GH�}��    H�E��8� H�}��    H�E��'H�}��    H�E��H�}�H�5�  �    H�E�    H�E�H�� ]Ñ������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������     UH��H��@H�}�H�u�H�E�H�x ��   H�E�H�@H�8 ��   �E�   �E�   H�E�H�@H�E�H�E�H�M�H;s5H�E�� ��
u�E���E��E�   �	�E���E�H�E�H��H�E�뾿   �    H�E�H�}� tDH�}�D�M�D�U�H�E�   1�H������L�R  D�$H�D$� �    H�M�H�E�H�@H�� H��@]�f�UH��H��H�}�H�E�H� �1��� �E�tH�E�H� �8�    �� ���E��E��u�H�E�H�H��H��H��]�f�     UH��H��0H�}�H�}ؾ   �    H�}� u
H�E�    �H�}�H�u��    H�}��    H�E�H�E�H��0]ÐUH��H�� H�}�H�u�H�}� v
H�E�H�E���   H�E�� H�M�H�E�H�HH�E�H�x�    H��H�E�H�H�E�H�8 t
H�E�H� �  H�E�H�@    H�� ]�ff.�     UH��H��PH�    H� H�E�H�}�H�u�H�}� uH�}�H�5�  �    ��   H�Eȋ H�E�H����   H�E�H��   Hc�H���H�}�H�5v  �    �   H�}�H�EȊHH�5T  H�H  ��HE��    �cH�}�H�E��@�    1�L�]  H�ΰ�    H�}�H�u��    �/H�E�H�xH�u��    �H�}�H�u��    �H�}�H�u��    H�    H� H�M�H9�uH��P]��    �������������~���W���B����     UH��H�� H�}�H�E�H�8 u
H�E�    �@H�E�H�8H�E�H�pH���    H�E�H�}� t
H�E�H�E��H�E�H� H�E�H�E�H�E�H�E�H�� ]�fD  UH��H�� H�}�H�}��    H�E�H�}� u
H�E�    �<�   �    H�E�H�}� uH�}��    H�E�    �H�M�H�E�H�HH�E�H�E�H�E�H�� ]�UH��H�� H�}�H�E�H�H��H��   �    H�E�H�}� uH�E�    �  H�E�H�@   H�E�H�@    H�E�H�xH���    H��H�E�H�HH�E�H�x uH�}��    H�E�    ��  H�}��    H�E�H� � ��]uH�E�H�H��H�H�E�H�E��  � H�E�H� �8 �b  H�}��    H�E�H�}� uH�}��    H�E�    �Y  H�E�H�@H�M�H;ArNH�E�H�HH��H�HH�}�H��H�E�H�pH���    �� uH�}��    H�}��    H�E�    ��   � H�U�H�E�H�@H�u�H�NH��H��H�~H��H�}��    H�E�H� � ��]uH�E�H�H��H�H�E�H�E��   H�E�H� � ��,uKH�E�H�H��H�H�}��    H�E�H� � ��]u#H�}�H�5�  �    H�}��    H�E�    �K�#H�}�H�5�  �    H�}��    H�E�    �&����H�}�H�5�  �    H�}��    H�E�    H�E�H�� ]�ffff.�     UH��H��0H�}�H�E�H�H��H�1��    H�E�H�}� uH�E�    �V  �   �    H��H�E�H�HH�E�H�x uH�}��    H�E�    �   H�}��    H�E�H� � ��}uH�E�H�H��H�H�E�H�E���  � H�E�H� �8 ��  H�E�H� � ��"t&H�}�H�5�  �    H�}��    H�E�    �  H�}��    H�E�H�}� uH�}��    H�E�    �|  H�}��    H�E�H� � ��:t/H�}�H�5�  �    H�}��    H�}��    H�E�    �5  H�E�H�H��H�H�}��    H�E�H�}� uH�}��    H�}��    H�E�    ��   H�E�H�xH�u�H�U��    H�}��    H�}��    H�E�H� � ��}uH�E�H�H��H�H�E�H�E��   H�E�H� � ��,uKH�E�H�H��H�H�}��    H�E�H� � ��}u#H�}�H�5�  �    H�}��    H�E�    �K�#H�}�H�5�  �    H�}��    H�E�    �&�6���H�}�H�5�  �    H�}��    H�E�    H�E�H��0]��    UH��H��0H�}�H�E�H� H�E�H�E�H� � ��-uH�E�H�H��H�� H�E�H� �8�    �� tH�E�H�H��H���H�E�H� � ��.u4H�E�H�H��H�H�E�H� �8�    �� tH�E�H�H��H���� H�E�H� � ��etH�E�H� � ��E��   H�E�H�H��H�H�E�H� � ��+tH�E�H� � ��-uH�E�H�H��H�H�E�H� �8�    �� uH�}�H�5n  �    H�E�    ��   � H�E�H� �8�    �� tH�E�H�H��H���� �   �    H�E�H�}� uH�E�    �   H�E�H� H�M�H)�H�E�H�}�H���    H�E�H�}� uH�}��    H�E�    �KH�}�H�u�H�U�H�������    H�E�H�M�� H�}�1����    H�E��@H�}��    H�E�H�E�H�E�H��0]�f.�     UH��H�� H�}�H�E�H�8H�5~  �   �    �� uEH�E�H�H��H��   �    H�E�H�}� uH�E�    ��   H�E��@H�E�H�E��   H�E�H�8H�5!  �   �    �� u?H�E�H�H��H��   �    H�E�H�}� u
H�E�    �eH�E��@ H�E�H�E��SH�E�H�8H�5�
  �   �    �� uH�E�H�H��H��   �    H�E��H�}�H�5�
  �    H�E�    H�E�H�� ]�f�     UH��H��@H�}�H�E�H�H��H�H�E�H� H�E�H�E�H�E�H�E��1��� �E�tH�E�� ��"���EǊEǨu�=H�E�� ��\u#H�E�H��H�E�H�E��8 tH�E�H��H�E��H�E�H��H�E��H�E�� ��"tH�}�H�5  �    H�E�    ��  H�}�H�E�H)�H���    H�E�H�}� u%H�    H�8H�5�  � �    H�E�    �  H�E�H�E�H�E�H�E�H�E�H;E��w  H�E�� ��\�@  H�E�H��H�E�H�E�� �E���"t[� �E���/t� �E���\t^� �E���bt� �E���f��   � �E���n��   � �E���r��   � �E���t��   �   H�E�H��H��H�M�� "�   H�E�H��H��H�M�� \�   H�E�H��H��H�M�� /�{H�E�H��H��H�M�� �gH�E�H��H��H�M�� �SH�E�H��H��H�M�� 
�?H�E�H��H��H�M�� �+H�E�H��H��H�M�� 	�H�EȊH�E�H��H��H�UЈH�E�H��H�E��"H�E�H��H��H�MȊH�E�H��H��H�UЈ�{���H�E��  H�M�H��H�E�H�H�E�H�E�H�E�H��@]�f�UH��H�� �}��   �    �    H�E�H�}� u"H�    H�8H�5  � �    H�E�    ��M�H�E�H�E�H�E�H�E�H�� ]�fffff.�     UH��H�� H�}�H�u�H�E�H�8H�u��    H�E�H�}� u(H�}� v!H�    H�8H�5  � �    �E�    �H�M�H�E�H��E�   �E�H�� ]�f�UH��H�� H�}�H�u�H�}��    H�E�H�}�H�u��    �u�FH�E�H�8H�E�HxH�u�H�U�H�������    H�M�H�E�HHH�HH�E�H� H�M�H�I� H�� ]�@ UH��H��0H�}�H�u�H�}�"   �    H�E�H�E�H�E�8 �C  H�E�� �E܃�ts� �E܃�	��   � �E܃�
��   � �E܃�tb� �E܃�t� �E܃�"t� �E܃�\t�   H�}�H�5'  �    ��   H�}�H�5  �    �   H�}�H�5  �    �   H�}�H�5�  �    �   H�}�H�5�  �    �rH�}�H�5�  �    �`H�}�H�5�  �    �NH�E�� �� }0H�}�H�E�D� 1��   H��  � �    H�}�H�u��    �H�}�H�E��0�    � � H�E�H��H�E�����H�}�"   �    H��0]�fD  UH��H�� H�}�H�u�H�}�[   �    H�E�    H�E�H�M�H;As<H�}� vH�}�,   �    H�E�H�@H�M�H�<�H�u��    H�E�H��H�E��H�}�]   �    H�� ]�fff.�     UH��H��0H�}�H�u�H�}�{   �    �E�H�E�H�@H�E�H�E�    H�E�H�M�H;A��   H�E�H� H�M�H��H�E�H�}� tU�E�uH�}�,   �    H�E�H�8H�u��    H�}�:   �    H�E�H�xH�u��    �E� H�E�H�@H�E��� H�E�H��H�E��l���H�}�}   �    H��0]�f�UH��H��0H�}�H�u�H�E�H�8 u	�E� �   H�E�H�@HE�H�M�H;Ar~H�E�H�@H�E�H�E�H�M�H�IHM�H9�wH�E�H��H�E���H�E�H�8H�u��    H�E�H�}� uH�    H�8H�5�  � �    �E� �H�M�H�E�H�H�M�H�E�H�H�E��E�$H��0]�f.�     UH��H��@��H�}��E�H�}��   �    �u�3�U�H�E�H� H�u�H�NH��H��H�~�H�E�H� H�M�H�I� H��]�Memory allocation failed during parsing. Extra content after top-level value. Invalid JSON value. Unterminated string literal. Webs Parser: Memory allocation failed for unescaped string.
 Webs Parser: Failed to allocate memory for WebsValue.
 Trailing comma in array. Expected ',' or ']' in array. Unterminated array. Webs Parser: Memory reallocation failed.
 Expected string key in object. Expected ':' after key in object. Trailing comma in object. Expected ',' or '}' in object. Unterminated object. Invalid number format (exponent). true false null Invalid literal. Error at line %d, col %d: %s %g Webs Encoder: Failed to reallocate string builder.
 \" \\ \b \f \n \r \t \u%04x %%%�|%�%r%s  4 I:;  I  ! I7  $ %>  $ %>  4 I:;  I:;  	( %  
 I   I%:;  %:;   %I:;8  :;  :;     .@%:;'I?   %:;I  4 %:;I  .@%:;'I  .@%:;'   %:;I    4 %:;I  .@%:;'  .@%:;'I  & I   I%:;  :;   %I:;8   		                �     0    �� <   @   ) O    ��<   @   % f    {�<   @    |    R�<   @    �    Y�<   @   = �    �<   @   7 �    �<   @    �    �<   @    f    ��    �	<   @   *    3�
<   @    %   @�<   @   " <   Z�<   @       _�^   e�<   @    %   ��~   ��<   @    �   ��<   @    ~   ���   ��<   @    |    5��   -�<   @    �   ��<   @   4 �   ���   ���   ���   ���   ���   ���   ��P   ��<   @    w  		 			
			 
<   
�  �   �   �  & �  ! g  " !{  # "�  $ $�  %   \  �  �    
�    #   [  [   
(  
-  5  {  	 �  
V   
5  c  o   �   [  [   
�  
�  �  #%
�  &�   V' ��  �p> �{  �h? ��  �P@ ��  �HD ��    �   V( j�  �p@ j�   !�   V) %�x@ %�  �pE %{  "�   �lF 'w  �hG (w  �`H ){  �XI 3{    #W   V* <�x@ <�   $O   V+ ={  �p =�  �XJ >�   %u   V, ��xJ ��  �pN �[   &  V- �H �  �@J �  '4   �PO ,�    (j   V. �{  �pJ ��  �hP �{   )p   V/ ��  �p@ ��  �hQ �{  �`R ��   *c  V0 ܀  �p@ ܲ  �hR ߀  +]  �`S �    ,�  V1 �  �p@ �  �hR !�  -�  �`T 8{  �XU G�    .  V2 ��  �p@ ��  �hB �{  �`R ��  �XV �[  �PW �{   /'  V3   �p@ ²  �hR À   0�  V4 B{  �p@ B�  �hB D{  �`X E{  �XY V{  �PZ ]{  �H[ ^{   1b   V5 �  �t �  �hR �   2n   V6 w  �p\ �  �h] [  �`^ �   3|   V8 ��xJ ��  �p_ �{  �hV �[   4�  V9 ��x_ �{  �pJ ��  5X  �h@ �{  60   �a` �P     7�   V: �x �  �pJ �  8R   �ha [    9�   V; ��x ��  �pJ ��  �ob �  �` �  :�   �Xa [  ;q   �Pc (     <�   V< ��  �pJ ��  �hd �[  =~   �`e �[  �Xf �{    >_   V= ��xJ ��  �wg �<    7
�  <   
{  �  C  	A{   
 B{   ?�    
�  
�  �  �  M � �K{   � L[   �[   � 
�  <   @     
	     �         /   L   �   �   �   �   �   �   �   �       *  D  I  W  ]  s  �  �  �  �  �  �  �  �  y  h  �  �  :  �  �  �  �        !  2  >  H  X  i  q  �  �  �  �  �  �  �  �  �  n      '  9  L  _  r  ~  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �              +  /  7  ;  I  P  W  [  d  l  p  x  z  �  �  �  �  �  Apple clang version 17.0.0 (clang-1700.3.19.1) src/codecs/webs_codec_json.c /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk MacOSX.sdk /Users/conradklek/webs/lib/native char __ARRAY_SIZE_TYPE__ unsigned int WEBS_VALUE_OBJECT WEBS_VALUE_ARRAY WEBS_VALUE_STRING WEBS_VALUE_NUMBER WEBS_VALUE_BOOL WEBS_VALUE_NULL WebsValue type WebsValueType value object_val WebsObject table WebsHashTable entries WebsHashEntry key next capacity size_t unsigned long count array_val WebsArray elements string_val number_val double bool_val _Bool unsigned char webs_json_decode parse_value set_error skip_whitespace webs_json_encode sb_init webs_encode_value sb_to_string parse_string parse_array parse_object parse_number parse_literal parse_allocated_string create_node webs_realloc_safe sb_append_str webs_encode_string webs_encode_array webs_encode_object sb_ensure_capacity sb_append_char int json_string error p Parser current start root message line col temp err_buf sb StringBuilder buffer length initial_capacity num_buf final_str str_val node element key_string value_node len num_str end unescaped_str writer reader ptr new_size new_ptr str hex_buf i first entry additional_length new_capacity new_buffer c �    �      (      M      a      ~      �      �            )      =      g      �      �      �      �      �                  #      (      9      V      Y      �      �      �      �      �      �      �      �                            Q            p      �      @      �      �      �      `      6      �	      �
      p      �      �      p      �      P      �      �      �      `      ~      �            8      �      	      �         p                   '   !      LLVM0700                	                                       !   $   &   0��>�f����,������T�;����2�V�aGB�T�~?1p]c �|Oْ^"�@�M��N�Գ���L�\h��L�^�������	=� [=��<�b3�ڠ���r���͓<��^B!��[�c�5>�/���V�<5w�Hn  �  �  �    �  H  9  �  y  �  q  �   �  !  �  i  _    �  2  �   �  L    �  �  h  :    �  �   >  '  X  �  �  �  I                     $   *   0   6   F   L   R   X   ^   d   j   p   v   |   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   �   $  .       w   ]   [   �   $   �   f   �   ,   �    	   J   �   <    g   �   $   �   R   �   -  5   �   @    �   
   �   �   �   �   �  �  �   �   c   w      o   }   �      �   �           �                             �                             �                            W                      p      O                      �      u                      @                           �      j                      �      p                      `      c                     �	      �                     p                           �      '                     �      �                     p      b                      �      n                      P      |                      �      �                     `      �                      �      �                      �      �                      �      _                             zR x�  $       ��������        A�C       $   D   ���������        A�C       $   l   ���������        A�C       $   �   ��������W        A�C       $   �   ��������O        A�C       $   �   ��������u        A�C       $     P�������       A�C       $   4  h�������j        A�C       $   \  ��������p        A�C       $   �  ��������c       A�C       $   �  @��������       A�C       $   �  ��������       A�C       $   �  ��������'       A�C       $   $  ���������       A�C       $   L  @�������b        A�C       $   t  ��������n        A�C       $   �  ��������|        A�C       $   �  (��������       A�C       $   �  ���������        A�C       $     ���������        A�C       $   <  ���������        A�C       $   d  X�������_        A�C       �    ~   �          "   5   r    D}�������؅>>G�   u8mW���i g৛L��   ��g;�MKõ?�w�{a�   ,D�!����.��.ehg  	        �
�J0JJFJJKX/Jw�LX.X.JJ/�X.X.JJ/�	J<	</�JY�0X.JJ.X/JY
�JKJ O�
�JYJ<<�}����JXhJXhJX�JXjJXhJ��J �}�
��fJJJ	guuJJKJJ</J<</�u/�y�	.�	KX/5JJJ>/ �
�J
<�1.4J!<<XC�=<gJ�1 ��
��X/�J
��KJ �~t#
�X).��|��JJKJJ�J=�/	J<>J� � 
�X/J�[J��{f���J�ZJ$J<JY1%JJY1%J1JJY0JJY0JJ[. �{f�&
��/�!J)<-J4JJ	X
Kt
�".&J�|t�JKJ �}�*
�J	XKX/��KX
/JY�JJ
KJKJ � f
�J��KX/�"J�J$�:J"JJ�"JL�
/JY�JYJ<<</J�J�.J<&�JX
K	X/JY	�J(J%J	J/&J(�.J"L8J2II�1	JY	JY�E/JJ$J?JC�LJ
YJ	<<	</J�J
�J	<<	</J�JYJ<<</	J�	JY�/J�JY]�'XJ�JY�J 0
�J�tKX/"�� JK�
/JY�JYJ<<</J�J�.J<
�J	<<	</J�JY/�JX
K	X/JY�J
YJ	<<	</J�JYJY�J)�JX
K	X/JYJY�*J1J=JJ
YJZJ
YJ	<<	</J�J
�J	<<	</J�JYJ<<</	J�	JY�/J�JYP�4XJ�JY�J �~�
�J<KJ<<</J�".%J<
<XYJ�0J<<</J$�'J<<XYJ�0/J<<<.!J<)<<gJ
�J	<<< .#J<+<	</J"�%J<
<	�/J��$.'J<<XYJ�00�KX/�J<J
<KJJ	XKX
/JY�uJJ#LJ�JYJ
ZJKJ �
�J<&</J�
�K	X/�JKJ�J<'</J�
�K	X/�JKJhJ<&</J��hJ��J �~�
�J�J<KJL
J�.J<��� <
g	J<	<
/�J</�
/z�
.J<</J�(�.J,J4<!J	XKX/���	JKJ
KJJ
g	J<	<g�Jf�t� <�t� <�t� <�t� <��� <��� <��� <��	=Z�	=Z�	=0�	=0�	=0�	=0�	=0�	=0J.�1�/�.�^.%XJ>JJJ
=JKJ ��"
��KX/���<J
/JKJ n<
�J!<J	XKX.X/��
�JJ=u< ��
�J
XKJJXK/#JJ�J<JJK �
�J�JJJ�Jf�|t�<�|��<�|��<�|t�<�|t�<�|t�<�J�ZJ�ZJ�ZJ�ZJ�0J�0J�0J<<	0�J	JY/J	J�0"_.�"XJ� �
�J��JJJ/	X/J�.J7JJ;JJ9T�4J� c 
�J�K2JJK�JJJg#J+<JJKug	J�!J&<JYJ� J'JJYKJJxJ
.,t.�XJ� ��
��/�JJ)J&JJ/JJKJ J'JJ</� 1$J,<JX
K	X/��hJJ=JJLKX �
!J�K/<J<J�=J<JJK /Users/conradklek/webs/lib/native src/codecs/../core /Library/Developer/CommandLineTools/usr/lib/clang/17/include src/codecs/webs_codec_json.c webs_value.h webs_hash.h __stddef_size_t.h   �    -f    -_    U    =C  "  -�    -�  	  -�    -r    -b    -
    -�    -�  	  -�    -z    -P    --    -    -    -    �    -�    �    -�    �    -�    �    -�    �    -�    |    -w    g    -b    �    -�    -v    -e  #  -&    -        =�  "  -�    -�    �    =�    -�    -�    �    =}  !  -\    -W    �    -�    {    -^  $  -T        -  $  -�    �    -�  $  -�    `    -N  %  -5    -    -�  !  -�    -�    -�    -�    t    -�    -�    -S  (  -J    -E    +  (  -"    -      (  -�    -�    �    -�    -�    -|  '  -Z  (  -Q    -=     -  (  -    -    -    �
    -�
  (  -�
    -�
  (  -�
    -�
    D
    -.
    -
  &  -�	    -�	  (  -�	    -�	    �	  (  -|	    -w	    `	  (  -W	    -R	    8	    -�    -�  (  -�  (  -�    -O  (  -;     -�    -�    -�  !  -�    -4    -     -    -�  "  -[    -D    ==    -.    -    -    -�    -�    �    -�    �    �    -�    q    -l    K    =  !  -�  
  -�  	  -�    -;     -�    -�    �  !  -�    -�    �    -u    -d    -U    -F    -    -�   (  -�   (  -�     -�     �     -k     -f     ?      -�    �    �    �    �    �    �    �    �    �    �    �    �    �    �    �    x    p    h    `    X    P    H    @    8    0    (                          �     �     �     �     �     �     �     �     �     �     �     �     �     �     �     �     x     p     h     `     X     P     H     @     8     0     (                          �    �    `    @              �    �    �    �    `    @              �     �     �     �     `     @                 �     �  h `    k           �            �          (    �           `      V     �	      �     p      �     �      5     �      x    @          �      x     P      6    �      "     `      d     �      J    �      �    p      �    �           �      �     �      �            �    p      �              
             �              �                           �              8             b             �             >              �             '             /             �              �                           �             G              �              _sb_ensure_capacity _parse_array _webs_encode_array _sb_init _isdigit _webs_hash_set _parse_object _webs_encode_object _sb_append_str _set_error _parse_number _sb_append_char ___stderrp _strncmp _strlen ___stack_chk_fail _parse_literal ___memcpy_chk ___sprintf_chk ___snprintf_chk _sb_to_string _parse_string _webs_encode_string _parse_allocated_string _fprintf _parse_value _webs_encode_value _webs_hash_create _webs_realloc_safe _webs_value_free _create_node _webs_json_encode _webs_json_decode _isspace _skip_whitespace ___stack_chk_guard _strtod _malloc _realloc _calloc 
---------- END: native/src/codecs/webs_codec_json.o ----------

---------- START: native/src/core/webs_hash.c ----------
#include "webs_hash.h"
#include "webs_value.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static size_t hash_key(const char *key) {
  size_t hash = 2166136261u;
  for (const char *p = key; *p; p++) {
    hash ^= (size_t)(*p);
    hash *= 16777619;
  }
  return hash;
}

static size_t hash_key_len(const char *key, size_t len) {
  size_t hash = 2166136261u;
  for (size_t i = 0; i < len; i++) {
    hash ^= (size_t)key[i];
    hash *= 16777619;
  }
  return hash;
}

WebsHashTable *webs_hash_create(size_t capacity) {
  WebsHashTable *table = malloc(sizeof(WebsHashTable));
  if (!table)
    return NULL;

  table->capacity = capacity > 0 ? capacity : 16;
  table->count = 0;
  table->entries = calloc(table->capacity, sizeof(WebsHashEntry *));
  if (!table->entries) {
    free(table);
    return NULL;
  }
  return table;
}

void webs_hash_free(WebsHashTable *table) {
  if (!table)
    return;
  for (size_t i = 0; i < table->capacity; i++) {
    WebsHashEntry *entry = table->entries[i];
    while (entry) {
      WebsHashEntry *next = entry->next;
      free(entry->key);
      webs_value_free(entry->value);
      free(entry);
      entry = next;
    }
  }
  free(table->entries);
  free(table);
}

static void webs_hash_resize(WebsHashTable *table) {
  size_t new_capacity = table->capacity * 2;
  WebsHashEntry **new_entries = calloc(new_capacity, sizeof(WebsHashEntry *));
  if (!new_entries) {
    fprintf(stderr, "Webs Hash: Failed to allocate memory for resize.\n");
    return;
  }

  for (size_t i = 0; i < table->capacity; i++) {
    WebsHashEntry *entry = table->entries[i];
    while (entry) {
      WebsHashEntry *next = entry->next;

      size_t index = hash_key(entry->key) % new_capacity;

      entry->next = new_entries[index];
      new_entries[index] = entry;

      entry = next;
    }
  }

  free(table->entries);
  table->entries = new_entries;
  table->capacity = new_capacity;
}

void webs_hash_set(WebsHashTable *table, const char *key, WebsValue *value) {
  if (table->count >= table->capacity * 0.75) {
    webs_hash_resize(table);
  }

  size_t index = hash_key(key) % table->capacity;
  WebsHashEntry *entry = table->entries[index];

  while (entry) {
    if (strcmp(entry->key, key) == 0) {
      webs_value_free(entry->value);
      entry->value = value;
      return;
    }
    entry = entry->next;
  }

  WebsHashEntry *new_entry = malloc(sizeof(WebsHashEntry));
  if (!new_entry)
    return;

  new_entry->key = strdup(key);
  if (!new_entry->key) {
    free(new_entry);
    return;
  }
  new_entry->value = value;

  new_entry->next = table->entries[index];
  table->entries[index] = new_entry;
  table->count++;
}

WebsValue *webs_hash_get(WebsHashTable *table, const char *key) {
  if (!table || !key)
    return NULL;
  size_t index = hash_key(key) % table->capacity;
  WebsHashEntry *entry = table->entries[index];

  while (entry) {
    if (strcmp(entry->key, key) == 0) {
      return entry->value;
    }
    entry = entry->next;
  }
  return NULL;
}

WebsValue *webs_hash_get_len(WebsHashTable *table, const char *key,
                             size_t len) {
  if (!table || !key)
    return NULL;
  size_t index = hash_key_len(key, len) % table->capacity;
  WebsHashEntry *entry = table->entries[index];

  while (entry) {
    if (strlen(entry->key) == len && strncmp(entry->key, key, len) == 0) {
      return entry->value;
    }
    entry = entry->next;
  }
  return NULL;
}

---------- END: native/src/core/webs_hash.c ----------

---------- START: native/src/core/webs_hash.h ----------
#ifndef WEBS_HASH_H
#define WEBS_HASH_H

#include <stddef.h>

typedef struct WebsValue WebsValue;

typedef struct WebsHashEntry {
  char *key;
  WebsValue *value;
  struct WebsHashEntry *next;
} WebsHashEntry;

struct WebsHashTable {
  WebsHashEntry **entries;
  size_t capacity;
  size_t count;
};

typedef struct WebsHashTable WebsHashTable;

WebsHashTable *webs_hash_create(size_t capacity);
void webs_hash_free(WebsHashTable *table);
void webs_hash_set(WebsHashTable *table, const char *key, WebsValue *value);
WebsValue *webs_hash_get(WebsHashTable *table, const char *key);

WebsValue *webs_hash_get_len(WebsHashTable *table, const char *key, size_t len);

#endif

---------- END: native/src/core/webs_hash.h ----------

---------- START: native/src/core/webs_hash.o ----------
����           (             �                          f      H      f                   __text          __TEXT                  �      H     �       �            __literal8      __TEXT                        H                            __literal16     __TEXT                        X                            __cstring       __TEXT          0      2       x                             __debug_abbrev  __DWARF         b      /      �                             __debug_info    __DWARF         �      �      �                             __debug_str_offs__DWARF         f      �       �                             __debug_str     __DWARF         J      �      �                             __debug_addr    __DWARF               �       N      �                    __debug_names   __DWARF         �            �                            __compact_unwind__LD            �             �                           __eh_frame      __TEXT          �      X      �               h            __debug_line    __DWARF                �      H      `                     __debug_line_str__DWARF         �      �                                    2                         h      �!  �      P                   
                                                   UH��H�� H�}�   �    H�E�H�}� u
H�E�    �uH�}� v
H�E�H�E���   H�E�� H�M�H�E�H�HH�E�H�@    H�E�H�x�   �    H��H�E�H�H�E�H�8 uH�}��    H�E�    �H�E�H�E�H�E�H�� ]�fD  UH��H�� H�}�H�}� u�   H�E�    H�E�H�M�H;AsbH�E�H� H�M�H��H�E�H�}� t8H�E�H�@H�E�H�E�H�8�    H�E�H�x�    H�}��    H�E�H�E���� H�E�H��H�E��H�E�H�8�    H�}��    H�� ]�D  UH��H��0H�}�H�u�H�U�H�E��~@(�  fb�f(�  f\�(�f��X��~Hfb�f\�(�f��X��A  �Y�f.�r	H�}��    H�}��    H�M�1�H�qH�U�H�E�H� H�M�H��H�E�H�}� tAH�E�H�8H�u��    �� uH�E�H�x�    H�M�H�E�H�H�   H�E�H�@H�E�븿   �    H�E�H�}� u�nH�}��    H��H�E�H�H�E�H�8 uH�}��    �FH�M�H�E�H�HH�E�H� H�M�H��H�E�H�HH�U�H�E�H� H�M�H��H�E�H�HH��H�HH��0]ÐUH��H��@H�}�H�E�H�@H��H�E�H�}�   �    H�E�H�}� uH�    H�8H�5  � �    �   H�E�    H�E�H�M�H;AsH�E�H� H�M�H��H�E�H�}� tRH�E�H�@H�E�H�E�H�8�    1ɉ�H�u�H�U�H�E�H�M�H��H�E�H�HH�U�H�E�H�M�H��H�E�H�E��� H�E�H��H�E��s���H�E�H�8�    H�M�H�E�H�H�M�H�E�H�HH��@]ÐUH��H�}��ŝ�H�E�H�E�H�E�H�E�8 t*H�E�H� H3E�H�E�HiE� H�E�H�E�H��H�E���H�E�]�fffff.�     UH��H��0H�}�H�u�H�}� tH�}� u
H�E�    �jH�}��    H�M�1�H�qH�U�H�E�H� H�M�H��H�E�H�}� t1H�E�H�8H�u��    �� uH�E�H�@H�E��H�E�H�@H�E���H�E�    H�E�H��0]�@ UH��H��0H�}�H�u�H�U�H�}� tH�}� uH�E�    �   H�}�H�u��    H�M�1�H�qH�U�H�E�H� H�M�H��H�E�H�}� tGH�E�H�8�    H;E�u'H�E�H�8H�u�H�U��    �� uH�E�H�@H�E��H�E�H�@H�E��H�E�    H�E�H��0]� UH��H�}�H�u�ŝ�H�E�H�E�    H�E�H;E�s/H�E�H�M�H�H3E�H�E�HiE� H�E�H�E�H��H�E���H�E�]�          �?          0C  0E              0C      0EWebs Hash: Failed to allocate memory for resize.
 %%%�|%�%r%s  4 I:;  I  ! I7  $ %>  $ %>  I:;  ( %  	 I%:;  
.@%:;'I?   %:;I  4 %:;I  .@%:;'?    .@%:;'  .@%:;'I   I  %:;   %I:;8  :;  :;  & I   �                �     /    =� ;   ?   2 ^   	 	
 	j   
�   V �  �p b   �h v   �   V' (�x (v  x   �p. +b   T   �h/ ,�  6   �`% .�      o  V( T�x Tv  �p T�  �h T�  �`0 Yb   �X/ Z�  �P1 e�     V) 9�x 9v  �p2 :b   �h3 ;�  �   �`. Ab   	n   �X/ B�  
P   �P% D�  �H0 Fb       R   V* b   �x �  �p4 b   ;   �h5 	�    
�   V+ u  �p uv  �h u�  �`0 xb   �X/ y�   
�   V, �  �p �v  �h ��  �`6 �b   �X0 �b   �P/ ��   \   V- b   �x �  �p6 b   �h4 b   A   �`. b     �  	�  �   b   b    �  �  	�  &&�  	   
%�   ;     	   X   %  & `  ! �  "  �  # !�  $ #�  %   	C   	h  v    {  	�  	�  �   b   b    �  �  	  "$�  �  ;    �          /   D   x   �   �   �   �   �   �   �        "  9  2  G  �  �  �  �  �      �    #  7  �  @  F  -  O  Z  e  l  u  {  �  X  g  u  �  �  �  �  �  �  �  �  �  �  �  �  �  Apple clang version 17.0.0 (clang-1700.3.19.1) src/core/webs_hash.c /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk MacOSX.sdk /Users/conradklek/webs/lib/native char __ARRAY_SIZE_TYPE__ unsigned int WEBS_VALUE_OBJECT WEBS_VALUE_ARRAY WEBS_VALUE_STRING WEBS_VALUE_NUMBER WEBS_VALUE_BOOL WEBS_VALUE_NULL size_t unsigned long webs_hash_create webs_hash_free webs_hash_set webs_hash_resize hash_key webs_hash_get webs_hash_get_len hash_key_len WebsHashTable entries WebsHashEntry key value WebsValue type WebsValueType object_val WebsObject table array_val WebsArray elements count capacity string_val number_val double bool_val _Bool next i entry index new_entry new_capacity new_entries hash p len �     0              �       �       �       �       `      �      !      7      Q      �      �      @      �      �      �                        
      !      LLVM0700                    	               ��6	\F���rX�������L�OmP��L��b͓<��{�ڪn��5w�H3��B�T�d��� [=�r������c �|O�u  �  X  �  �  �   �  �    �   G  u  �  �  �  g  e  9  2  �   -                     $   *   5   ;   A   G   M   S   c   s   y      �   �   �   $  .       �      �    �   �   ?    X   �  �   `   ^    n    /   X       �   �  �  {   �    �   j    b    ;    �               �                      �       �                      `      o                     �                           �      R                      @      �                      �      �                      �      \                             zR x�  $      8��������        A�C       $   D   ���������        A�C       $   l   H�������o       A�C       $   �   ��������       A�C       $   �   x�������R        A�C       $   �   ���������        A�C       $     (��������        A�C       $   4  ��������\        A�C       �    ~   �          "   +   h    +�1Qw�D̙� q�}   u8mW���i g৛L��   ,D�!����.��.ehg�   ��g;�MKõ?�w�{a  	        
��KX/�X$.�b�JJKJ�"JJ�J=�
/JY
�JKJ �
�X/Y�JJJ/#J+<JJKu$JJKJ<YJJYJYJE5,w.�
.J<YJY �
=+'t�J/J[J"X J
fK!J)<JJLuJ<	J!X	</JJYJJKZJJzJ	.�KX/0J�J=�
/JY0JJLJ$<JJJKJ
J<JKJ� Ft
� J)J
<(K!J�KX/��[�JJJ/#J+<JJKu$JJL&J<+X�L!JJJJKJJJLJxJ
.,t.�XJ<YJJ=JJK �t

��JJJYJ
J�"��
2J � �
�X.X/�J"X J
fK!J)<JJLuJ<	J!X	</JJhJJF4�J �
=X.X/�$JJ+X)J
fK!J)<JJLuJ	<X#J..5J:<?J&JDX	</JJhJJF4�J �~�

���JJ/JJ
X� ��
2J /Users/conradklek/webs/lib/native src/core /Library/Developer/CommandLineTools/usr/lib/clang/17/include src/core/webs_hash.c webs_value.h __stddef_size_t.h webs_hash.h   f    -L    -    -�    -m    -�    -e    -  
  -        =�  	  -}    -`    -J    -!    -    -�    -�     -�    �    �    Q    -H    -"    -    -    -�     -m   	  -     -�     �     x     p     h     `     X     P     H     @     8     0     (                          �     �     �     �     `     @                 �          �           �      U     �      �             �     �            @      c     �           `      1              �              v              �              �              <              )              M              D              �               _hash_key _webs_hash_set _webs_hash_get _strdup ___stderrp _strcmp _strncmp _strlen _hash_key_len _webs_hash_get_len _fprintf _webs_hash_resize _webs_hash_create _webs_hash_free _webs_value_free _malloc _calloc     
---------- END: native/src/core/webs_hash.o ----------

---------- START: native/src/core/webs_value.c ----------
#include "webs_value.h"
#include "webs_hash.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static WebsResult create_error_result(const char *error_message) {
  WebsResult res = {.result = NULL, .error = strdup(error_message)};
  return res;
}

void webs_value_free(WebsValue *value) {
  if (!value)
    return;
  switch (value->type) {
  case WEBS_VALUE_STRING:
    free(value->value.string_val);
    break;
  case WEBS_VALUE_ARRAY:
    for (size_t i = 0; i < value->value.array_val.count; i++) {
      webs_value_free(value->value.array_val.elements[i]);
    }
    free(value->value.array_val.elements);
    break;
  case WEBS_VALUE_OBJECT:
    webs_hash_free(value->value.object_val.table);
    break;
  default:
    break;
  }
  free(value);
}

static char *format_node_value(WebsValue *node) {
  if (!node)
    return strdup("null");
  char buffer[512];
  switch (node->type) {
  case WEBS_VALUE_NULL:
    return strdup("null");
  case WEBS_VALUE_BOOL:
    return strdup(node->value.bool_val ? "true" : "false");
  case WEBS_VALUE_NUMBER:
    snprintf(buffer, sizeof(buffer), "%g", node->value.number_val);
    return strdup(buffer);
  case WEBS_VALUE_STRING:
    return strdup(node->value.string_val);
  case WEBS_VALUE_ARRAY:
    return strdup("[Array]");
  case WEBS_VALUE_OBJECT:
    return strdup("[Object]");
  }
  return strdup("unknown");
}

WebsResult webs_value_query(WebsValue *root, const char *path) {
  if (!root) {
    return create_error_result("Failed to query on a null root node.");
  }

  WebsValue *current_node = root;
  const char *p = path;

  while (*p) {
    if (current_node->type == WEBS_VALUE_OBJECT) {
      if (*p == '[') {
        return create_error_result(
            "Error: Attempted to index an object with array syntax.");
      }

      const char *end = strpbrk(p, ".[");
      size_t len = end ? (size_t)(end - p) : strlen(p);

      char *key = malloc(len + 1);
      if (!key)
        return create_error_result("Memory allocation failed for query key.");

      strncpy(key, p, len);
      key[len] = '\0';

      current_node = webs_hash_get(current_node->value.object_val.table, key);
      free(key);

      if (!current_node) {
        return create_error_result("Error: Key not found in path.");
      }
      p += len;
    } else if (current_node->type == WEBS_VALUE_ARRAY && *p == '[') {
      p++;
      char *endptr;
      long index = strtol(p, &endptr, 10);

      if (endptr == p || *endptr != ']') {
        return create_error_result("Error: Invalid or unclosed array index.");
      }
      if (index < 0 || (size_t)index >= current_node->value.array_val.count) {
        return create_error_result("Error: Array index out of bounds.");
      }

      current_node = current_node->value.array_val.elements[index];
      p = endptr + 1;
    } else {
      if (*p == '[')
        return create_error_result(
            "Error: Attempted to index a non-array value.");
      else
        return create_error_result(
            "Error: Attempted to access key on a non-object value.");
    }

    if (*p == '.') {
      p++;
    }
  }

  WebsResult res = {.result = format_node_value(current_node), .error = NULL};
  return res;
}

---------- END: native/src/core/webs_value.c ----------

---------- START: native/src/core/webs_value.h ----------
#ifndef WEBS_VALUE_H
#define WEBS_VALUE_H

#include <stdbool.h>
#include <stddef.h>

typedef struct WebsHashTable WebsHashTable;

typedef enum {
  WEBS_VALUE_OBJECT,
  WEBS_VALUE_ARRAY,
  WEBS_VALUE_STRING,
  WEBS_VALUE_NUMBER,
  WEBS_VALUE_BOOL,
  WEBS_VALUE_NULL
} WebsValueType;

typedef struct WebsValue WebsValue;

typedef struct {
  WebsHashTable *table;
} WebsObject;

typedef struct {
  WebsValue **elements;
  size_t count;
  size_t capacity;
} WebsArray;

struct WebsValue {
  WebsValueType type;
  union {
    WebsObject object_val;
    WebsArray array_val;
    char *string_val;
    double number_val;
    bool bool_val;
  } value;
};

typedef struct {
  char *result;
  char *error;
} WebsResult;

void webs_value_free(WebsValue *value);
WebsResult webs_value_query(WebsValue *root, const char *path);

#endif

---------- END: native/src/core/webs_value.h ----------

---------- START: native/src/core/webs_value.o ----------
����           �                                       b      �      b                   __text          __TEXT                  0      �        2     �            __cstring       __TEXT          0      ~      �	                             __debug_abbrev  __DWARF         �      %      f                             __debug_info    __DWARF         �      �      �                             __debug_str_offs__DWARF         �      �       v                             __debug_str     __DWARF         �      �      j                             __debug_addr    __DWARF         p      �       (      �                    __debug_names   __DWARF         0      �      �                            __compact_unwind__LD                  �       �     h                    __eh_frame      __TEXT          �      �       H               h            __debug_line    __DWARF         H      q             �                    __debug_line_str__DWARF         �      �       q                             2                   )      �           �     �  �      P                                                                      UH��H�� H�}�H�}� u�   H�E�� �E��tm� �E��t� �E��uh� H�E�H�x�    �YH�E�    H�E�H�M�H;As#H�E�H�@H�M�H�<�����H�E�H��H�E���H�E�H�x�    �H�E�H�x�    �� H�}��    H�� ]�fffff.�     UH��H��`H�}�H�u�H�}� uH�=R  �    H�E�H�U��^  H�E�H�E�H�E�H�E�H�EЀ8 �,  H�E؃8 �
  H�E�� ��[uH�=(  �    H�E�H�U��  H�}�H�5B  �    H�E�H�}� tH�E�H�M�H)�H�E��H�}��    H�E�H�E�H�E�H�}�H���    H�E�H�}� uH�=�  �    H�E�H�U��  H�}�H�u�H�U�H�������    H�E�H�M�� H�E�H�xH�u��    H�E�H�}��    H�}� uH�=�  �    H�E�H�U��;  H�E�HE�H�E���   H�E؃8��   H�E�� ��[��   H�E�H��H�E�H�}�H�u��
   �    H�E�H�E�H;E�tH�E�� ��]tH�=U  �    H�E�H�U��   H�}� |H�E�H�M�H;ArH�=O  �    H�E�H�U��   H�E�H�@H�M�H��H�E�H�E�H��H�E��8H�E�� ��[uH�=*  �    H�E�H�U��JH�=A  �    H�E�H�U��4� H�E�� ��.uH�E�H��H�E������H�}��    H�E�H�E�    H�E�H�U�H��`]�@ UH��H�� H�}�H�E�    H�}��    H�E�H�E�H�U�H�� ]ÐUH��H��0  H�    H� H�E�H������H������ uH�=�  �    H�������  H������� H������H����   H������H�  Hc�H���H�=x  �    H��������   H�������HH�=`  H�T  ��HE��    H�������   H������H�������@�   1�L�&  H�ΰ�    H�������    H�������VH������H�x�    H�������=H�=�  �    H�������(H�=�  �    H�������H�=�  �    H������H������H������H�    H� H�M�H9�uH������H��0  ]��    ���������s���3����������Failed to query on a null root node. Error: Attempted to index an object with array syntax. .[ Memory allocation failed for query key. Error: Key not found in path. Error: Invalid or unclosed array index. Error: Array index out of bounds. Error: Attempted to index a non-array value. Error: Attempted to access key on a non-object value. null true false %g [Array] [Object] unknown %%%�|%�%r%s  4 I:;  I  ! I7  $ %>  $ %>  I:;  ( %  	 I%:;  
.@%:;'?   %:;I    4 %:;I  .@%:;'I?  .@%:;'I  :;   %I:;8   I  %:;  :;  & I  ! I7   �                     /    :� ;   ?   % M    D�;   ?   7 c    G�;   ?    y    L�;   ?   ( �    U�;   ?    y    ^��    a�;   ?   " �    i�;   ?   - �    l�;   ?   6 �    $�	;   ?    �    *�
   *�;   ?    c    ,�1   1�;   ?    G   3�;   ?   	 1   5�x  	 	
 	�  
�   V �x �  9   �p- |    �  V 8�  �h. 8�  �`/ 8�  �X0 =�  �P1 >�  �p7 t�  
  �H2 G�  �@3 H|  �� J�   �   ��4 Z�  ��5 [�    /   V �  �h8 �  �p7 �   �  V "�  ��{9 "�  ��{: %�   	�  ,)�  * �  + ;   �  	�  && 	   �  &   ! $�  " (�  # )�  $ +�  %   	]  	  #'    ,  	4  ""U    |  !|   Z  _  	g  �  	 �  
�   g  	�  '%�   !|   |   �  �  	�  &*,�  ;   6;   ?      �          /   E   y   �   �   �   �   �   �   �       #  :  3  H  X  �  �  �  i  }  �  �  �  �  �  �  
    �      �  �  "  6  �  ,  ?  J  U  \  e  k  m  r  w  �  �  �  �  �  �  �  �  �  �  Apple clang version 17.0.0 (clang-1700.3.19.1) src/core/webs_value.c /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk MacOSX.sdk /Users/conradklek/webs/lib/native char __ARRAY_SIZE_TYPE__ unsigned int WEBS_VALUE_OBJECT WEBS_VALUE_ARRAY WEBS_VALUE_STRING WEBS_VALUE_NUMBER WEBS_VALUE_BOOL WEBS_VALUE_NULL size_t unsigned long webs_value_free webs_value_query create_error_result format_node_value WebsResult result error value WebsValue type WebsValueType object_val WebsObject table WebsHashTable entries WebsHashEntry key next capacity count array_val WebsArray elements string_val number_val double bool_val _Bool i root path current_node p end len endptr index long res error_message node buffer �     0      U      �      �      �      �      �            L      �      �      �      �      �      �      �              J       �             A      `      �      �                	      !      LLVM0700                       
         B�T�r��� [=������L�5/�|͓<��U����O��b��"5w�H3���L�c �|�*��vi��  :  U  e  H  �  �  �   }  3  ,  �  �  �  �  �   �   X  i                  #   .   4   :   @   F   L   R   X   ^   n   t   z   �       $  .   ,  4   �   �   �   �   _  g   �   x   f   |   �      �   	   �  �  �   ?    ;    �   @            �                      �       �                     `      /                      �      �                            zR x�  $      P��������        A�C       $   D   ���������       A�C       $   l   `�������/        A�C       $   �   h��������       A�C       m    ~   �          "   +   h    �/ͽ�G`��%߬ �~   u8mW���i g৛L��   ,D�!����.��.ehg�   ��g;�MKõ?�w�{a  	        
�X/YJXqf<qt<
vJJY0�JJJ/.J7JJJ;W�
1!JJY0,JJY00JY <
�X/<[JKJLJ	�J	<gJ<</	<!\J�K#t)J'Jt5..J��� JLJJXKX/	<ZuJJ$LCJJJJXKJZX/	<Z	J�X#J7<;f:J=<<g�J�LJJ.J"<</	<ZX .)J&JJ/	<[4J=JJJKJ	JK/J<</	<1	<�.
� .	J<	</P�14XJX�� ��
�5�.JXK� t
��/��t�Zf&����t<JX�+tX�tJX����
��uJ�6t J� /Users/conradklek/webs/lib/native src/core /Library/Developer/CommandLineTools/usr/lib/clang/17/include src/core/webs_value.c webs_value.h __stddef_size_t.h webs_hash.h           -�    =�  
  -�    �  
  -�    �  
  -�    �  
  -~  
  -r    -h    ;  
  -/    (      
  -    �  
  -�    �    =y  
  ->    -     -    �     -�    �     -�    �     -|    [    -     -�    �    -�    -�    -�     -�    �  	  -p    -K    -F    .     -)    �      -�     �     -�     -�     -D     -�     �     �     �     �     �     �     �     x     p     h     `     X     P     H     @     8     0     (                          `     @                 �              `      �     �      �                  �       y              O              �              j              �              �              7              ?              a              G              �              (               _webs_value_query _create_error_result _webs_hash_get _strdup _strlen _strtol ___stack_chk_fail _strpbrk ___strncpy_chk ___snprintf_chk _format_node_value _webs_hash_free _webs_value_free ___stack_chk_guard _malloc 
---------- END: native/src/core/webs_value.o ----------

---------- START: native/test/json.parse.test.js ----------
import { test, expect, describe } from 'bun:test';
import { symbols } from '../webs.js';
import { dlopen, CString } from 'bun:ffi';
import { resolve } from 'path';

const libPath = resolve(import.meta.dir, '../.webs.dylib');
const lib = dlopen(libPath, symbols);

const { webs_query_json, webs_free_string } = lib.symbols;

function queryAndFree(json, path) {
  const jsonBuffer = Buffer.from(json + '\0');
  const pathBuffer = Buffer.from(path + '\0');

  const resultPtr = webs_query_json(jsonBuffer, pathBuffer);

  try {
    if (!resultPtr || resultPtr.ptr === 0) {
      return 'Error: C function returned null pointer.';
    }
    return new CString(resultPtr).toString();
  } finally {
    if (resultPtr) {
      webs_free_string(resultPtr);
    }
  }
}

describe('Webs C DOM Parser: Basic Queries', () => {
  const complexJson = `
    {
      "user": {
        "name": "John Doe",
        "isAdmin": true,
        "email": null,
        "logins": 127
      },
      "posts": [
        {"id": 1, "title": "First Post", "tags": ["c", "json"]},
        {"id": 2, "title": "Second Post", "tags": ["bun", "ffi"]}
      ],
      "matrix": [[1, 2], [3, 4]]
    }
  `;

  test('should extract a string value from an object', () => {
    expect(queryAndFree(complexJson, 'user.name')).toBe('John Doe');
  });

  test('should extract a number value', () => {
    expect(parseFloat(queryAndFree(complexJson, 'user.logins'))).toBe(127);
  });

  test('should extract a boolean value', () => {
    expect(queryAndFree(complexJson, 'user.isAdmin')).toBe('true');
  });

  test('should extract a null value', () => {
    expect(queryAndFree(complexJson, 'user.email')).toBe('null');
  });

  test('should extract a value from an array by index', () => {
    expect(queryAndFree(complexJson, 'posts[1].title')).toBe('Second Post');
  });

  test('should extract a value from a nested array', () => {
    expect(queryAndFree(complexJson, 'posts[0].tags[1]')).toBe('json');
  });

  test('should handle multi-dimensional arrays', () => {
    expect(queryAndFree(complexJson, 'matrix[1][0]')).toBe('3');
  });
});

describe('Webs C DOM Parser: Edge Cases and Errors', () => {
  test('should handle empty objects and arrays', () => {
    const json = `{"emptyObj": {}, "emptyArr": []}`;
    expect(queryAndFree(json, 'emptyObj')).toBe('[Object]');
    expect(queryAndFree(json, 'emptyArr')).toBe('[Array]');
  });

  test('should handle strings with escaped quotes', () => {
    const json = `{"quote": "He said \\"Hello, World!\\""}`;
    expect(queryAndFree(json, 'quote')).toBe('He said "Hello, World!"');
  });

  test('should return a parsing error for invalid JSON', () => {
    const json = `{"user": {"name": "John Doe"}`;
    expect(queryAndFree(json, 'user.name')).toContain('Error at line 1');
  });

  test('should return a parsing error for trailing commas', () => {
    const json = `{"a": 1,}`;
    expect(queryAndFree(json, 'a')).toContain('Trailing comma in object');
  });

  test('should return an error for extra content after top-level value', () => {
    const json = `{"a": 1} "hello"`;
    expect(queryAndFree(json, 'a')).toContain(
      'Extra content after top-level value',
    );
  });

  test('should return an error for a non-existent key path', () => {
    const json = `{"user": {"name": "John Doe"}}`;
    expect(queryAndFree(json, 'user.age')).toBe(
      'Error: Key not found in path.',
    );
  });

  test('should return an error for an out-of-bounds array index', () => {
    const json = `{"tags": ["dev"]}`;
    expect(queryAndFree(json, 'tags[5]')).toBe(
      'Error: Array index out of bounds.',
    );
  });

  test('should return an error for invalid array index format', () => {
    const json = `{"tags": ["dev"]}`;
    expect(queryAndFree(json, 'tags[abc]')).toBe(
      'Error: Invalid or unclosed array index.',
    );
  });

  test('should return an error for trying to index a non-array', () => {
    const json = `{"user": {"name": "John"}}`;
    expect(queryAndFree(json, 'user[0]')).toBe(
      'Error: Attempted to index an object with array syntax.',
    );
  });
});

describe('Webs C DOM Parser: Hash Table Resizing', () => {
  test('should handle a large number of keys, forcing a resize', () => {
    const keyCount = 100;
    let largeObj = {};
    for (let i = 0; i < keyCount; i++) {
      largeObj[`key${i}`] = i;
    }
    const json = JSON.stringify({ data: largeObj });

    expect(parseInt(queryAndFree(json, 'data.key0'), 10)).toBe(0);
    expect(parseInt(queryAndFree(json, 'data.key50'), 10)).toBe(50);
    expect(parseInt(queryAndFree(json, `data.key${keyCount - 1}`), 10)).toBe(
      keyCount - 1,
    );
  });
});

---------- END: native/test/json.parse.test.js ----------

---------- START: native/test/json.stringify.test.js ----------
import { test, expect, describe } from 'bun:test';
import { symbols } from '../webs.js';
import { dlopen, CString } from 'bun:ffi';
import { resolve } from 'path';

const libPath = resolve(import.meta.dir, '../.webs.dylib');
const lib = dlopen(libPath, symbols);

const { webs_parse_json, webs_json_encode, webs_free_value, webs_free_string } =
  lib.symbols;

function roundtrip(jsonString) {
  const jsonBuffer = Buffer.from(jsonString + '\0');

  const valuePtr = webs_parse_json(jsonBuffer);
  if (!valuePtr || valuePtr.ptr === 0) {
    return 'Error: C function returned null pointer on parse.';
  }

  try {
    const resultPtr = webs_json_encode(valuePtr);
    if (!resultPtr || resultPtr.ptr === 0) {
      return 'Error: C function returned null pointer on encode.';
    }

    try {
      return new CString(resultPtr).toString();
    } finally {
      webs_free_string(resultPtr);
    }
  } finally {
    webs_free_value(valuePtr);
  }
}

describe('Webs C JSON Serializer', () => {
  test('should correctly serialize a complex object', () => {
    const complexJson = {
      user: {
        name: 'Jane Doe',
        isAdmin: false,
        email: null,
        logins: 99,
        'special\\key': 'value with "quotes"',
      },
      posts: [
        { id: 1, title: 'First Post', tags: ['c', 'json'] },
        { id: 2, title: 'Second Post', tags: ['bun', 'ffi'] },
      ],
      matrix: [
        [1, 2],
        [3, 4],
      ],
    };
    const jsonString = JSON.stringify(complexJson);
    const resultString = roundtrip(jsonString);

    expect(JSON.parse(resultString)).toEqual(complexJson);
  });

  test('should handle empty objects and arrays', () => {
    const json = { emptyObj: {}, emptyArr: [] };
    const jsonString = JSON.stringify(json);
    const resultString = roundtrip(jsonString);
    expect(JSON.parse(resultString)).toEqual(json);
  });

  test('should handle top-level arrays', () => {
    const json = [1, 'two', true, null, { a: 3.14 }];
    const jsonString = JSON.stringify(json);
    const resultString = roundtrip(jsonString);
    expect(JSON.parse(resultString)).toEqual(json);
  });

  test('should correctly handle string escaping', () => {
    const json = {
      quote: '"',
      backslash: '\\',
      newline: '\n',
      tab: '\t',
    };
    const jsonString = JSON.stringify(json);
    const resultString = roundtrip(jsonString);
    expect(JSON.parse(resultString)).toEqual(json);
  });

  test('should handle various number formats', () => {
    const json = { integer: 42, float: 3.14159, negative: -100, zero: 0 };
    const jsonString = JSON.stringify(json);
    const resultString = roundtrip(jsonString);
    expect(JSON.parse(resultString)).toEqual(json);
  });

  test('should handle parse error gracefully', () => {
    const invalidJson = '{"key": "value",';
    const result = roundtrip(invalidJson);
    expect(result).toBe('Error: C function returned null pointer on parse.');
  });
});

---------- END: native/test/json.stringify.test.js ----------

---------- START: native/webs.js ----------
import { FFIType } from 'bun:ffi';

export const symbols = {
  webs_query_json: {
    args: [FFIType.ptr, FFIType.ptr],
    returns: FFIType.ptr,
  },
  webs_free_string: {
    args: [FFIType.ptr],
    returns: FFIType.void,
  },
  webs_parse_json: {
    args: [FFIType.ptr],
    returns: FFIType.ptr,
  },
  webs_json_encode: {
    args: [FFIType.ptr],
    returns: FFIType.ptr,
  },
  webs_free_value: {
    args: [FFIType.ptr],
    returns: FFIType.void,
  },
};

---------- END: native/webs.js ----------

---------- START: server/ai.server.js ----------
import { generateUUID } from '../shared/utils.js';
import { Ollama } from 'ollama';
import { createLogger } from '../shared/logger.js';
import * as sqliteVec from 'sqlite-vec';
import { Database } from 'bun:sqlite';
import { dirname } from 'path';
import { ensureDir } from './server-setup.js';

const logger = createLogger('[AI]');
const toolLogger = createLogger('[AI Tools]');
const storeLogger = createLogger('[Store]');
const errorLogger = createLogger('[Errors]');

/**
 * A base error class for all AI-related operations, providing a consistent
 * structure for error handling and serialization across client and server boundaries.
 * @class AIError
 * @extends {Error}
 * @property {Error | null} originalError - The original error that was caught, if any.
 */
export class AIError extends Error {
  /**
   * Creates an instance of AIError.
   * @param {string} message - The error message.
   * @param {Error | null} [originalError=null] - The original error object.
   */
  constructor(message, originalError = null) {
    const detailedMessage = originalError?.message
      ? `${message} -> ${originalError.message}`
      : message;
    super(detailedMessage);
    this.name = this.constructor.name;
    this.originalError = originalError;
    errorLogger.error(`[AIError] ${detailedMessage}`);
  }

  /**
   * Serializes the error to a plain object for transport.
   * @returns {{name: string, message: string}}
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
    };
  }
}

/** Error for timed-out operations. */
export class TimeoutError extends AIError {}
/** Error related to generating embeddings. */
export class EmbeddingError extends AIError {}
/** Error during a chat session. */
export class ChatError extends AIError {}
/** Error related to the vector store. */
export class StoreError extends AIError {}

/**
 * A namespace containing all specialized AI error classes, allowing for
 * precise error identification and handling.
 */
export const AIErrors = {
  AIError,
  TimeoutError,
  EmbeddingError,
  ChatError,
  StoreError,
};

/**
 * @typedef {object} AIConfigForStore
 * @property {string} host
 * @property {{chat: string, embedding: string, labeling: string, agent?: string}} models
 * @property {{path: string, dimensions: number}} db
 */

/**
 * @typedef {object} SearchResultMetadata
 * @property {string} filePath
 * @property {number} startLine
 * @property {number} endLine
 * @property {string} [className] - The name of the class containing the code chunk.
 * @property {string} [functionName] - The name of the function or method in the code chunk.
 * @property {string} [summary] - The AI-generated summary of the chunk.
 */

/**
 * @typedef {object} SearchResult
 * @property {string} text - The content of the search result.
 * @property {number} score - The relevance score of the result.
 * @property {SearchResultMetadata} metadata - Metadata associated with the result.
 */

class Store {
  /**
   * @param {AIConfigForStore} config
   * @param {AI} aiInstance
   */
  constructor(config, aiInstance) {
    this.config = config;
    this.ai = aiInstance;
    /** @type {Database | null} */
    this.db = null;
  }

  async init() {
    if (process.platform === 'darwin') {
      try {
        Database.setCustomSQLite('/usr/local/opt/sqlite3/lib/libsqlite3.dylib');
      } catch (e) {
        storeLogger.warn(
          `Could not set custom SQLite library. If you're on macOS and this fails, please install SQLite with Homebrew ('brew install sqlite').`,
        );
      }
    }

    await ensureDir(dirname(this.config.db.path));

    this.db = new Database(this.config.db.path, { create: true });
    sqliteVec.load(this.db);

    this.db.exec(`
      CREATE VIRTUAL TABLE IF NOT EXISTS vec_store USING vec0(
        embedding float[${this.config.db.dimensions}]
      );
      CREATE TABLE IF NOT EXISTS text_meta (
          vec_id INTEGER PRIMARY KEY,
          text_content TEXT NOT NULL,
          file_path TEXT,
          start_line INTEGER,
          end_line INTEGER,
          summary TEXT
      );
    `);

    const columns = this.db.prepare('PRAGMA table_info(text_meta)').all();
    if (
      !columns.some(
        (/** @type {{ name: string; }} */ c) => c.name === 'user_id',
      )
    ) {
      this.db.exec('ALTER TABLE text_meta ADD COLUMN user_id INTEGER');
    }
    if (
      !columns.some(
        (/** @type {{ name: string; }} */ c) => c.name === 'class_name',
      )
    ) {
      this.db.exec('ALTER TABLE text_meta ADD COLUMN class_name TEXT');
    }
    if (
      !columns.some(
        (/** @type {{ name: string; }} */ c) => c.name === 'function_name',
      )
    ) {
      this.db.exec('ALTER TABLE text_meta ADD COLUMN function_name TEXT');
    }
    if (
      !columns.some(
        (/** @type {{ name: string; }} */ c) => c.name === 'summary',
      )
    ) {
      this.db.exec('ALTER TABLE text_meta ADD COLUMN summary TEXT');
    }
  }

  /**
   * @param {Array<{content: string, embedding: Float32Array, metadata: any}>} documents
   */
  async indexBatch(documents) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    if (!documents || documents.length === 0) return;

    try {
      const tx = this.db.transaction((docs) => {
        if (!this.db)
          throw new AIErrors.StoreError('Database not initialized.');
        const insertVecStmt = this.db.prepare(
          'INSERT INTO vec_store (embedding) VALUES (?)',
        );
        const insertMetaStmt = this.db.prepare(
          'INSERT INTO text_meta (vec_id, text_content, file_path, user_id, start_line, end_line, class_name, function_name, summary) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
        );

        for (const doc of docs) {
          const { lastInsertRowid } = insertVecStmt.run(doc.embedding);
          const meta = doc.metadata;
          insertMetaStmt.run(
            lastInsertRowid,
            doc.content,
            meta.filePath,
            meta.userId ?? null,
            meta.startLine,
            meta.endLine,
            meta.className ?? null,
            meta.functionName ?? null,
            meta.summary ?? null,
          );
        }
      });

      tx(documents);
    } catch (error) {
      const typedError =
        error instanceof Error ? error : new Error(String(error));
      throw new AIErrors.StoreError(
        'Failed to execute batch index.',
        typedError,
      );
    }
  }

  /**
   * @param {string} text
   * @param {any} metadata
   */
  async index(text, metadata) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    try {
      const embedding = await this.ai.embed(text);
      if (!embedding) {
        throw new AIErrors.EmbeddingError(
          'Failed to generate embedding for indexing.',
        );
      }

      const tx = this.db.transaction(() => {
        if (!this.db)
          throw new AIErrors.StoreError('Database not initialized.');

        const { lastInsertRowid } = this.db
          .prepare('INSERT INTO vec_store (embedding) VALUES (?)')
          .run(embedding);

        this.db
          .prepare(
            'INSERT INTO text_meta (vec_id, text_content, file_path, user_id, start_line, end_line, class_name, function_name, summary) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
          )
          .run(
            lastInsertRowid,
            text,
            metadata.filePath,
            metadata.userId ?? null,
            metadata.startLine,
            metadata.endLine,
            metadata.className ?? null,
            metadata.functionName ?? null,
            metadata.summary ?? null,
          );
      });

      tx();
      return { success: true, text };
    } catch (error) {
      if (error instanceof AIErrors.AIError) throw error;
      throw new AIErrors.StoreError(
        `Failed to index chunk for ${metadata.filePath}.`,
        /** @type {Error} */ (error),
      );
    }
  }

  /**
   * @param {string} text
   * @param {Float32Array} embedding
   * @param {any} metadata
   */
  async indexWithEmbedding(text, embedding, metadata) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    try {
      const tx = this.db.transaction(() => {
        if (!this.db)
          throw new AIErrors.StoreError('Database not initialized.');
        const { lastInsertRowid } = this.db
          .prepare('INSERT INTO vec_store (embedding) VALUES (?)')
          .run(embedding);

        this.db
          .prepare(
            'INSERT INTO text_meta (vec_id, text_content, file_path, user_id, start_line, end_line, class_name, function_name, summary) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
          )
          .run(
            lastInsertRowid,
            text,
            metadata.filePath,
            metadata.userId ?? null,
            metadata.startLine,
            metadata.endLine,
            metadata.className ?? null,
            metadata.functionName ?? null,
            metadata.summary ?? null,
          );
      });

      tx();
      return { success: true, text };
    } catch (error) {
      if (error instanceof AIErrors.AIError) throw error;
      throw new AIErrors.StoreError(
        `Failed to index chunk for ${metadata.filePath}.`,
        /** @type {Error} */ (error),
      );
    }
  }
  /**
   * @param {string} filePath
   * @param {string | number | undefined} userId
   */
  async remove(filePath, userId) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    try {
      const tx = this.db.transaction(() => {
        if (!this.db)
          throw new AIErrors.StoreError('Database not initialized.');
        const records = this.db
          .prepare(
            'SELECT vec_id FROM text_meta WHERE file_path = ? AND (user_id = ? OR user_id IS NULL)',
          )
          .all(filePath, userId ?? null);
        if (records.length > 0) {
          const ids = records.map((/** @type {{vec_id: any}} */ r) => r.vec_id);
          const placeholders = ids.map(() => '?').join(',');
          this.db
            .prepare(`DELETE FROM vec_store WHERE rowid IN (${placeholders})`)
            .run(...ids);
          this.db
            .prepare(`DELETE FROM text_meta WHERE vec_id IN (${placeholders})`)
            .run(...ids);
        }
      });
      tx();
      return { success: true, filePath };
    } catch (error) {
      throw new AIErrors.StoreError(
        `Failed to remove document index for ${filePath}.`,
        /** @type {Error} */ (error),
      );
    }
  }
  /**
   * @param {string} query
   * @param {number} [limit=5]
   * @param {{userId?: string | number}} [where={}]
   */
  async search(query, limit = 5, where = {}) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    try {
      const embedding = await this.ai.embed(query);
      if (!embedding || embedding.length === 0) return [];

      const candidateLimit = limit * 10;
      let whereClause = '';
      /** @type {any[]} */
      let params = [];

      if (where.userId) {
        whereClause = 'WHERE meta.user_id = ?';
        params.push(where.userId);
      }

      const sql = `
        SELECT
          meta.text_content as text,
          meta.file_path as filePath,
          meta.start_line as startLine,
          meta.end_line as endLine,
          meta.class_name as className,
          meta.function_name as functionName,
          meta.summary as summary,
          v.distance as score
        FROM (
          SELECT rowid, distance
          FROM vec_store
          WHERE embedding MATCH ?
          ORDER BY distance
          LIMIT ?
        ) as v
        JOIN text_meta AS meta ON v.rowid = meta.vec_id
        ${whereClause};
      `;

      const queryParams = [embedding, candidateLimit, ...params];
      const candidateResults = this.db.query(sql).all(...queryParams);

      /** @type {Map<string, SearchResult>} */
      const uniqueFileResults = new Map();
      for (const result of candidateResults) {
        const filePath = /** @type {string} */ (result.filePath);
        const existing = uniqueFileResults.get(filePath);
        if (
          !existing ||
          /** @type {number} */ (result.score) < existing.score
        ) {
          uniqueFileResults.set(filePath, {
            text: /** @type {string} */ (result.text),
            score: /** @type {number} */ (result.score),
            metadata: {
              filePath: filePath,
              startLine: /** @type {number} */ (result.startLine),
              endLine: /** @type {number} */ (result.endLine),
              className: /** @type {string | undefined} */ (result.className),
              functionName: /** @type {string | undefined} */ (
                result.functionName
              ),
              summary: /** @type {string | undefined} */ (result.summary),
            },
          });
        }
      }

      return Array.from(uniqueFileResults.values())
        .sort((a, b) => a.score - b.score)
        .slice(0, limit);
    } catch (error) {
      if (error instanceof AIErrors.AIError) throw error;
      throw new AIErrors.StoreError(
        `Failed to execute search.`,
        /** @type {Error} */ (error),
      );
    }
  }

  close() {
    if (this.db) {
      this.db.close();
    }
  }
}

/**
 * @typedef {import('bun:sqlite').Database} BunDatabase
 * @typedef {import('bun').Server} BunServer
 */

/**
 * @typedef {import('ollama').ToolCall} ToolCall
 * @typedef {import('ollama').Message} ChatMessage
 */

/**
 * @typedef {import('ollama').Tool} Tool
 */

/**
 * @typedef {object} AIConfig
 * @property {string} host
 * @property {{chat: string, embedding: string, labeling: string, agent?: string}} models
 * @property {{path: string, dimensions: number}} db
 */

/**
 * @typedef {object} AgentDefinition
 * @property {string} name
 * @property {string} system_prompt
 * @property {Tool[]} tools
 * @property {string} [model]
 * @property {{ maxIterations?: number, temperature?: number }} [config]
 * @property {any} component
 */

/**
 * @typedef {object} ChatContext
 * @property {BunDatabase} db
 * @property {any} user
 * @property {Record<string, Function>} syncActions
 * @property {BunServer} server
 */

/**
 * A utility to retry an async function with exponential backoff.
 * @template T
 * @param {() => Promise<T>} fn The async function to execute.
 * @param {number} [retries=3] The number of retries.
 * @param {number} [delay=1000] The initial delay in milliseconds.
 * @returns {Promise<T>}
 */
async function retryWithBackoff(fn, retries = 3, delay = 1000) {
  try {
    return await fn();
  } catch (error) {
    if (retries > 0) {
      logger.warn(
        `Operation failed. Retrying in ${delay}ms... (${retries} retries left)`,
      );
      await new Promise((res) => setTimeout(res, delay));
      return retryWithBackoff(fn, retries - 1, delay * 2);
    }
    logger.error('Operation failed after all retries.');
    throw error;
  }
}

export class AI {
  /** @param {AIConfig} config */
  constructor(config) {
    this.config = config;
    this.store = new Store(config, this);
    this.ollama = new Ollama({ host: config.host });
    this.isReady = false;
  }

  /**
   * @param {BunServer} _server
   * @param {Record<string, AgentDefinition>} [_agentDefs]
   */
  initialize(_server, _agentDefs = {}) {}

  async init() {
    if (this.isReady) return;
    logger.info('Initializing...');
    try {
      await this.ollama.list();
      logger.info('Ollama connection successful.');
    } catch (e) {
      throw new AIErrors.AIError(
        `Failed to connect to Ollama at ${this.config.host}. Is Ollama running?`,
        e instanceof Error ? e : new Error(String(e)),
      );
    }
    await this.store.init();
    this.isReady = true;
    logger.info('Ready.');
  }

  async shutdown() {
    if (!this.isReady) return;
    logger.info('Shutting down...');
    this.store.close();
    this.isReady = false;
    await new Promise((resolve) => setTimeout(resolve, 100));
    logger.info('Shutdown complete.');
  }

  /**
   * @param {Array<{path: string, content: string}>} files
   * @param {object & {userId?: string}} [metadata={}]
   */
  async indexDirectory(files, metadata = {}) {
    if (!files || files.length === 0) {
      return { successful: 0, failed: 0 };
    }
    logger.info(`Starting batch indexing for ${files.length} files...`);

    for (const file of files) {
      await this.removeFileIndex(file.path, metadata);
    }

    const filesToProcess = files.filter(
      (f) => f.content && f.content.trim().length > 0,
    );
    const contents = filesToProcess.map((f) => f.content);

    if (contents.length === 0) {
      logger.info('No non-empty files to index.');
      return { successful: files.length, failed: 0 };
    }

    try {
      const embeddings = await this.embedBatch(contents);
      const documentsToIndex = [];

      for (let i = 0; i < filesToProcess.length; i++) {
        const file = filesToProcess[i];
        const embedding = embeddings[i];
        if (file && embedding) {
          documentsToIndex.push({
            content: file.content,
            embedding: embedding,
            metadata: {
              filePath: file.path,
              startLine: 1,
              endLine: file.content.split('\n').length,
              ...metadata,
            },
          });
        }
      }

      await this.store.indexBatch(documentsToIndex);

      const successfulCount =
        documentsToIndex.length + (files.length - filesToProcess.length);
      logger.info(
        `Batch indexing complete. Indexed ${successfulCount} files successfully.`,
      );
      return { successful: successfulCount, failed: 0 };
    } catch (error) {
      logger.error('Batch indexing failed:', error);
      return { successful: 0, failed: files.length };
    }
  }

  /**
   * @param {{ path: string, content: string }} file
   * @param {object & {userId?: string | number}} [metadata={}]
   */
  async indexFile(file, metadata = {}) {
    if (!file.path || typeof file.content !== 'string') {
      logger.warn(
        `Skipping invalid file data for: ${file.path || 'unknown file'}`,
      );
      return false;
    }

    logger.info(`- Processing file: ${file.path}`);
    try {
      await this.removeFileIndex(file.path, metadata);

      if (file.content.trim() === '') {
        logger.info(`- Skipped indexing empty file: ${file.path}`);
        return true;
      }

      const content = file.content;
      const lines = content.split('\n').length;
      const embedding = await this.embed(content);

      if (embedding) {
        await this.store.indexWithEmbedding(content, embedding, {
          filePath: file.path,
          startLine: 1,
          endLine: lines,
          ...metadata,
        });
      } else {
        throw new AIErrors.EmbeddingError(
          `Ollama returned an empty embedding for ${file.path}.`,
        );
      }

      return true;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      logger.error(`Failed to index file: ${file.path}`, errorMessage);
      return false;
    }
  }

  /**
   * Indexes a file only if it hasn't been indexed for the user before.
   * @param {{ path: string, content: string }} file
   * @param {object & {userId?: string | number}} [metadata={}]
   */
  async indexFileIfNotExists(file, metadata = {}) {
    if (!this.store.db)
      throw new AIErrors.StoreError('Database not initialized.');

    const userId = metadata.userId ?? null;
    const isIndexed = this.store.db
      .query(
        'SELECT vec_id FROM text_meta WHERE file_path = ? AND (user_id = ? OR (? IS NULL AND user_id IS NULL))',
      )
      .get(file.path, userId, userId);

    if (!isIndexed) {
      logger.info(`Indexing dev file: '${file.path}'...`);
      return this.indexFile(file, metadata);
    }

    logger.debug(`Skipping already indexed dev file: '${file.path}'`);
    return true;
  }

  /**
   * @param {string} filePath
   * @param {object & {userId?: string | number}} [metadata={}]
   */
  async removeFileIndex(filePath, metadata = {}) {
    logger.info(`Removing index for file: ${filePath}`);
    try {
      await this.store.remove(filePath, metadata.userId);
    } catch (error) {
      logger.error(`Failed to remove index for ${filePath}:`, error);
    }
  }

  /** @param {string} text */
  async embed(text) {
    try {
      const res = await retryWithBackoff(() =>
        this.ollama.embed({
          model: this.config.models.embedding,
          input: text,
        }),
      );

      const embedding = res.embeddings && res.embeddings[0];
      if (!embedding || embedding.length === 0) {
        throw new AIErrors.EmbeddingError(
          'Ollama returned an empty embedding.',
        );
      }
      return new Float32Array(embedding);
    } catch (error) {
      throw new AIErrors.EmbeddingError(
        'Failed to generate embedding.',
        error instanceof Error ? error : new Error(String(error)),
      );
    }
  }

  /** @param {string[]} texts */
  async embedBatch(texts) {
    if (!texts || texts.length === 0) {
      return [];
    }
    try {
      const res = await retryWithBackoff(() =>
        this.ollama.embed({
          model: this.config.models.embedding,
          input: texts,
        }),
      );

      if (!res.embeddings || res.embeddings.length !== texts.length) {
        throw new AIErrors.EmbeddingError(
          'Ollama returned mismatched number of embeddings for batch.',
        );
      }
      return res.embeddings.map((e) => (e ? new Float32Array(e) : undefined));
    } catch (error) {
      throw new AIErrors.EmbeddingError(
        'Failed to generate batch embeddings.',
        error instanceof Error ? error : new Error(String(error)),
      );
    }
  }

  /**
   * @param {string} prompt
   * @param {object} [options={}]
   * @returns {AsyncGenerator<string>}
   */
  async *generate(prompt, options = {}) {
    try {
      if (!prompt) {
        throw new AIErrors.ChatError('Prompt cannot be empty.');
      }

      const modelToUse =
        /** @type {any} */ (options).model || this.config.models.chat;
      const stream = await retryWithBackoff(() =>
        this.ollama.generate({
          model: modelToUse,
          prompt,
          stream: true,
          options,
        }),
      );

      for await (const chunk of stream) {
        yield chunk.response;
      }
    } catch (error) {
      if (error instanceof AIError) {
        throw error;
      }
      throw new AIError(
        'An unknown error occurred during generation.',
        error instanceof Error ? error : null,
      );
    }
  }

  /**
   * @param {ChatMessage[]} messages
   * @param {object} [options={}]
   * @returns {AsyncGenerator<string>}
   */
  async *chat(messages, options = {}) {
    try {
      if (!messages || messages.length === 0) {
        throw new AIErrors.ChatError('Messages array cannot be empty.');
      }

      const modelToUse =
        /** @type {any} */ (options).model || this.config.models.chat;
      const stream = await retryWithBackoff(() =>
        this.ollama.chat({
          model: modelToUse,
          messages,
          stream: true,
          options,
        }),
      );

      for await (const chunk of stream) {
        if (chunk.message.content) {
          yield chunk.message.content;
        }
      }
    } catch (error) {
      if (error instanceof AIError) {
        throw error;
      }
      throw new AIError(
        'An unknown error occurred during chat.',
        error instanceof Error ? error : null,
      );
    }
  }

  /**
   * @param {{message: ChatMessage, options?: { model?: string }}} params
   * @param {ChatContext} context
   * @returns {Promise<{chatId: string, title: string}>}
   */
  async createChat({ message }, context) {
    const { user, syncActions } = context;
    const chatId = generateUUID();

    const titlePrompt = `Based on the following user query, suggest a short, URL-friendly (kebab-case) title for the chat session: "${message.content}"`;
    const titleResponse = await this.ollama.generate({
      model: this.config.models.labeling,
      prompt: titlePrompt,
    });

    const title = titleResponse.response
      .trim()
      .toLowerCase()
      .replace(/['"]/g, '')
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '');

    const chat = {
      id: chatId,
      name: title,
      topic: message.content.substring(0, 100),
      owner_id: user.id,
      created_at: new Date().toISOString(),
    };
    if (syncActions.upsertChats) {
      syncActions.upsertChats({ user }, chat);
    }

    const userMessage = {
      id: generateUUID(),
      chat_id: chatId,
      username: user.username,
      message: message.content,
      user_id: user.id,
      created_at: new Date().toISOString(),
    };
    if (syncActions.upsertChat_messages) {
      syncActions.upsertChat_messages({ user }, userMessage);
    }

    return { chatId, title };
  }

  /** @param {ChatContext} context */
  getChats(context) {
    const { db, user } = context;
    return db
      .query('SELECT * FROM chats WHERE owner_id = ? ORDER BY created_at DESC')
      .all(user.id);
  }

  /**
   * @param {string} id
   * @param {Partial<{name: string, topic: string}>} updates
   * @param {ChatContext} context
   */
  updateChat(id, updates, context) {
    const { db, user, syncActions } = context;
    const chat = db
      .query('SELECT * FROM chats WHERE id = ? AND owner_id = ?')
      .get(id, user.id);
    if (!chat) throw new AIError('Chat not found or access denied.');

    const finalUpdates = { ...chat, ...updates, id };
    if (syncActions.upsertChats) {
      syncActions.upsertChats({ user }, finalUpdates);
    }
    return db.query('SELECT * FROM chats WHERE id = ?').get(id);
  }

  /**
   * @param {string} id
   * @param {ChatContext} context
   */
  deleteChat(id, context) {
    const { db, user, syncActions } = context;
    const chat = db
      .query('SELECT id FROM chats WHERE id = ? AND owner_id = ?')
      .get(id, user.id);
    if (!chat) throw new AIError('Chat not found or access denied.');

    if (syncActions.deleteChats) {
      syncActions.deleteChats({ user }, { id });
    }
    return { success: true };
  }

  /**
   * @param {ChatMessage[]} messages
   * @param {AgentDefinition} agentDef
   * @param {any} toolContext
   * @param {object} [options={}]
   * @returns {AsyncGenerator<string>}
   */
  async *agent(messages, agentDef, toolContext, options = {}) {
    try {
      const agentComponent = agentDef.component;
      const model =
        agentDef.model ||
        /** @type {any} */ (options).model ||
        this.config.models.agent;
      const maxIterations = agentDef.config?.maxIterations ?? 5;

      let currentMessages = [...messages];
      if (agentDef.system_prompt) {
        currentMessages.unshift({
          role: 'system',
          content: agentDef.system_prompt,
        });
      }

      for (let i = 0; i < maxIterations; i++) {
        const stream = await retryWithBackoff(() =>
          this.ollama.chat({
            model: /** @type {string} */ (model),
            messages: currentMessages,
            tools: agentDef.tools,
            stream: true,
            options,
          }),
        );

        let responseMessage = {
          role: /** @type {const} */ ('assistant'),
          content: '',
          tool_calls: /** @type {ToolCall[]} */ ([]),
        };

        for await (const chunk of stream) {
          const chunkMessage = chunk.message;
          if (chunkMessage.content) {
            responseMessage.content += chunkMessage.content;
            yield JSON.stringify({
              type: 'chunk',
              content: chunkMessage.content,
            }) + '\n';
          }
          if (chunkMessage.tool_calls) {
            responseMessage.tool_calls = chunkMessage.tool_calls;
          }
        }

        if (
          !responseMessage.tool_calls ||
          responseMessage.tool_calls.length === 0
        ) {
          break;
        }

        currentMessages.push(responseMessage);
        const toolResults = [];
        for (const toolCall of responseMessage.tool_calls) {
          const toolName = toolCall.function.name;
          const toolArgs = toolCall.function.arguments;
          const toolFn = agentComponent[toolName];

          if (typeof toolFn === 'function') {
            yield JSON.stringify({
              type: 'tool_start',
              name: toolName,
              args: toolArgs,
            }) + '\n';
            const result = await toolFn(toolContext, toolArgs);
            yield JSON.stringify({
              type: 'tool_end',
              name: toolName,
              result: result,
            }) + '\n';
            toolResults.push({
              role: 'tool',
              content: JSON.stringify(result),
              tool_call_id: /** @type {any} */ (toolCall).id,
            });
          }
        }
        currentMessages.push(...toolResults);
      }
    } catch (error) {
      if (error instanceof AIError) {
        throw error;
      }
      throw new AIError(
        'An unknown error occurred during agent execution.',
        error instanceof Error ? error : null,
      );
    }
  }

  /**
   * @param {string} query
   * @param {number} [limit=5]
   * @param {object} [where={}]
   */
  async search(query, limit = 5, where = {}) {
    return this.store.search(query, limit, where);
  }

  async list() {
    const response = await this.ollama.list();
    return response.models;
  }

  /**
   * @param {string} model
   * @param {any} [options]
   * @returns {AsyncGenerator<string>}
   */
  async *pull(model, options) {
    const stream = await this.ollama.pull({ model, stream: true, ...options });

    for await (const chunk of stream) {
      yield JSON.stringify(chunk) + '\n';
    }
  }

  /** @param {string} model */
  async delete(model) {
    return this.ollama.delete({ model });
  }
}

/**
 * @file Provides a standard library of general-purpose tools for AI agents.
 * These tools are designed to integrate seamlessly with the framework's core features,
 * such as the user-scoped file system, database, and vector search.
 */

/**
 * @typedef {import('../server/fs.server.js').ServerFsApi} ServerFsApi
 * @typedef {import('../server/authentication.js').UserInfo} UserInfo
 */

/**
 * The execution context provided to every tool implementation.
 * @typedef {object} ToolExecutionContext
 * @property {BunDatabase} db - The server-side database instance.
 * @property {UserInfo} user - The currently authenticated user.
 * @property {ServerFsApi} fs - The file system API, sandboxed to the current user.
 * @property {AI} ai - The core AI service for capabilities like semantic search.
 * @property {Record<string, Function>} syncActions - Real-time synchronization actions.
 * @property {import('bun').Server} server - The Bun server instance.
 */

const getChatsDefinition = {
  type: 'function',
  function: {
    name: 'getChats',
    description: "Retrieves a list of the user's past chats.",
    parameters: { type: 'object', properties: {} },
  },
};

/** @param {ToolExecutionContext} context */
function getChats(context) {
  toolLogger.info(`[Tool] Executing getChats for user ${context.user.id}`);
  try {
    return context.ai.getChats(context);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while fetching chats: ${message}`;
  }
}

const updateChatDefinition = {
  type: 'function',
  function: {
    name: 'updateChat',
    description: 'Updates the title or topic of a specific chat.',
    parameters: {
      type: 'object',
      properties: {
        id: { type: 'string', description: 'The ID of the chat to update.' },
        name: {
          type: 'string',
          description: 'The new name/title for the chat.',
        },
        topic: { type: 'string', description: 'The new topic for the chat.' },
      },
      required: ['id'],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ id: string, name?: string, topic?: string }} args
 */
function updateChat(context, args) {
  const { id, ...updates } = args;
  toolLogger.info(
    `[Tool] Executing updateChat for user ${context.user.id} on chat ${id}`,
  );
  try {
    return context.ai.updateChat(id, updates, context);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while updating the chat: ${message}`;
  }
}

const deleteChatDefinition = {
  type: 'function',
  function: {
    name: 'deleteChat',
    description: 'Deletes a chat and all of its associated messages.',
    parameters: {
      type: 'object',
      properties: {
        id: { type: 'string', description: 'The ID of the chat to delete.' },
      },
      required: ['id'],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ id: string }} args
 */
function deleteChat(context, args) {
  toolLogger.info(
    `[Tool] Executing deleteChat for user ${context.user.id} on chat ${args.id}`,
  );
  try {
    return context.ai.deleteChat(args.id, context);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while deleting the chat: ${message}`;
  }
}

const listFilesDefinition = {
  type: 'function',
  function: {
    name: 'listFiles',
    description:
      "List files and directories at a given path within the user's private file system.",
    parameters: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description:
            "The directory path to list. Defaults to the user's root directory.",
        },
      },
      required: [],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ path?: string }} args
 */
async function listFiles(context, args) {
  toolLogger.info(
    `[Tool] Executing listFiles for user ${context.user.id} at path '${
      args.path || '.'
    }'`,
  );
  try {
    const files = await context.fs.ls(args.path || '.');
    if (files.length === 0) {
      return 'The directory is empty or does not exist.';
    }
    return files
      .map((f) => `${f.isDirectory ? '[DIR] ' : ''}${f.path}`)
      .join('\n');
  } catch (error) {
    toolLogger.error('listFiles tool failed:', error);
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while listing files: ${message}`;
  }
}

const readFileDefinition = {
  type: 'function',
  function: {
    name: 'readFile',
    description:
      "Read the full contents of a specific file from the user's private file system.",
    parameters: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'The full path to the file to read.',
        },
      },
      required: ['path'],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ path: string }} args
 */
async function readFile(context, args) {
  toolLogger.info(
    `[Tool] Executing readFile for user ${context.user.id} on path '${args.path}'`,
  );
  try {
    const file = await context.fs.cat(args.path);
    return await file.text();
  } catch (error) {
    toolLogger.error('readFile tool failed:', error);
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while reading the file: ${message}`;
  }
}

const writeFileDefinition = {
  type: 'function',
  function: {
    name: 'writeFile',
    description:
      "Write or overwrite a file with new content in the user's private file system. This will automatically index the file for semantic search.",
    parameters: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'The full path where the file should be written.',
        },
        content: {
          type: 'string',
          description: 'The new content of the file.',
        },
      },
      required: ['path', 'content'],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ path: string, content: string }} args
 */
async function writeFile(context, args) {
  toolLogger.info(
    `[Tool] Executing writeFile for user ${context.user.id} on path '${args.path}'`,
  );
  try {
    await context.fs.write(args.path, args.content);
    await context.ai.indexFile(
      { path: args.path, content: args.content },
      { userId: String(context.user.id) },
    );
    return `Successfully wrote ${args.content.length} bytes to ${args.path}.`;
  } catch (error) {
    toolLogger.error('writeFile tool failed:', error);
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while writing the file: ${message}`;
  }
}

const getTodosDefinition = {
  type: 'function',
  function: {
    name: 'getTodos',
    description:
      "Get the user's list of to-do items. Returns the item's content, status, and ID.",
    parameters: {
      type: 'object',
      properties: {
        status: {
          type: 'string',
          description: 'Filter by status.',
          enum: ['all', 'completed', 'pending'],
        },
      },
      required: [],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ status?: 'all' | 'completed' | 'pending' }} args
 */
function getTodos(context, args) {
  toolLogger.info(
    `[Tool] Executing getTodos for user ${context.user.id} with status '${
      args.status || 'all'
    }'`,
  );
  try {
    let query = 'SELECT id, content, completed FROM todos WHERE user_id = ?';
    const params = [context.user.id];

    if (args.status === 'completed') {
      query += ' AND completed = 1';
    } else if (args.status === 'pending') {
      query += ' AND completed = 0';
    }

    const todos = context.db.query(query).all(...params);
    if (todos.length === 0) {
      return 'The user has no to-do items matching the criteria.';
    }
    return todos
      .map((t) => `${t.completed ? '[x]' : '[ ]'} ${t.content} (ID: ${t.id})`)
      .join('\n');
  } catch (error) {
    toolLogger.error('getTodos tool failed:', error);
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while fetching todos: ${message}`;
  }
}

const addTodoDefinition = {
  type: 'function',
  function: {
    name: 'addTodo',
    description: "Adds a new to-do item to the user's list.",
    parameters: {
      type: 'object',
      properties: {
        content: {
          type: 'string',
          description: 'The content of the to-do item.',
        },
      },
      required: ['content'],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ content: string }} args
 */
function addTodo(context, args) {
  toolLogger.info(
    `[Tool] Executing addTodo for user ${context.user.id} with content "${args.content}"`,
  );
  try {
    if (!context.syncActions.upsertTodos) {
      return 'Error: The upsertTodos action is not available.';
    }
    const newTodo = {
      id: generateUUID(),
      content: args.content,
      completed: 0,
      user_id: context.user.id,
    };
    context.syncActions.upsertTodos({ user: context.user }, newTodo);
    return `Successfully added new to-do with ID: ${newTodo.id}.`;
  } catch (error) {
    toolLogger.error('addTodo tool failed:', error);
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while adding the todo: ${message}`;
  }
}

const updateTodoDefinition = {
  type: 'function',
  function: {
    name: 'updateTodo',
    description:
      'Updates an existing to-do item, such as changing its content or marking it as complete.',
    parameters: {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'The ID of the to-do item to update.',
        },
        content: {
          type: 'string',
          description: 'The new content for the to-do item.',
        },
        completed: {
          type: 'boolean',
          description:
            'The new completion status (true for complete, false for pending).',
        },
      },
      required: ['id'],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ id: string, content?: string, completed?: boolean }} args
 */
function updateTodo(context, args) {
  toolLogger.info(
    `[Tool] Executing updateTodo for user ${context.user.id} on todo ${args.id}`,
  );
  try {
    if (!context.syncActions.upsertTodos) {
      return 'Error: The upsertTodos action is not available.';
    }
    const existingTodo = context.db
      .query('SELECT * FROM todos WHERE id = ? AND user_id = ?')
      .get(args.id, context.user.id);

    if (!existingTodo) {
      return `Error: To-do with ID ${args.id} not found.`;
    }

    const updatedTodo = {
      ...existingTodo,
      content: args.content !== undefined ? args.content : existingTodo.content,
      completed:
        args.completed !== undefined
          ? args.completed
            ? 1
            : 0
          : existingTodo.completed,
    };

    context.syncActions.upsertTodos({ user: context.user }, updatedTodo);
    return `Successfully updated to-do with ID: ${args.id}.`;
  } catch (error) {
    toolLogger.error('updateTodo tool failed:', error);
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while updating the todo: ${message}`;
  }
}

const deleteTodoDefinition = {
  type: 'function',
  function: {
    name: 'deleteTodo',
    description: "Deletes a to-do item from the user's list.",
    parameters: {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'The ID of the to-do item to delete.',
        },
      },
      required: ['id'],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ id: string }} args
 */
function deleteTodo(context, args) {
  toolLogger.info(
    `[Tool] Executing deleteTodo for user ${context.user.id} on todo ${args.id}`,
  );
  try {
    if (!context.syncActions.deleteTodos) {
      return 'Error: The deleteTodos action is not available.';
    }
    const existingTodo = context.db
      .query('SELECT id FROM todos WHERE id = ? AND user_id = ?')
      .get(args.id, context.user.id);

    if (!existingTodo) {
      return `Error: To-do with ID ${args.id} not found or you do not have permission to delete it.`;
    }

    context.syncActions.deleteTodos({ user: context.user }, { id: args.id });
    return `Successfully deleted to-do with ID: ${args.id}.`;
  } catch (error) {
    toolLogger.error('deleteTodo tool failed:', error);
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred while deleting the todo: ${message}`;
  }
}

const semanticSearchDefinition = {
  type: 'function',
  function: {
    name: 'semanticSearch',
    description:
      "Search the user's indexed files based on semantic meaning, not just keywords. Useful for finding documents related to a concept.",
    parameters: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'The conceptual query to search for.',
        },
      },
      required: ['query'],
    },
  },
};

/**
 * @param {ToolExecutionContext} context
 * @param {{ query: string }} args
 */
async function semanticSearch(context, args) {
  toolLogger.info(
    `[Tool] Executing semanticSearch for user ${context.user.id} with query '${args.query}'`,
  );
  try {
    const results = await context.ai.search(args.query, 3, {
      userId: context.user.id,
    });
    if (!results || results.length === 0) {
      return 'No relevant files found for that query.';
    }
    return (
      `Found ${results.length} relevant file(s):\n` +
      results
        .map(
          (r) =>
            `- ${r.metadata.filePath} (relevance score: ${r.score.toFixed(3)})`,
        )
        .join('\n')
    );
  } catch (error) {
    toolLogger.error('semanticSearch tool failed:', error);
    const message = error instanceof Error ? error.message : String(error);
    return `An error occurred during semantic search: ${message}`;
  }
}

/**
 * An object containing all core tool implementations, keyed by their function name.
 * This can be spread into an agent's default export.
 */
export const coreTools = {
  getChats,
  updateChat,
  deleteChat,
  listFiles,
  readFile,
  writeFile,
  getTodos,
  addTodo,
  updateTodo,
  deleteTodo,
  semanticSearch,
};

/**
 * An array containing all core tool definitions.
 * This can be spread into an agent's `tools` export.
 */
export const allTools = [
  getChatsDefinition,
  updateChatDefinition,
  deleteChatDefinition,
  listFilesDefinition,
  readFileDefinition,
  writeFileDefinition,
  getTodosDefinition,
  addTodoDefinition,
  updateTodoDefinition,
  deleteTodoDefinition,
  semanticSearchDefinition,
];

---------- END: server/ai.server.js ----------

---------- START: server/api.js ----------
import { registerUser, loginUser, logoutUser } from './authentication.js';
import { createFileSystemForUser } from './fs.server.js';
import { createLogger } from '../shared/logger.js';

const logger = createLogger('[API]');

/**
 * Converts an async generator into a streaming Response object.
 * @param {AsyncGenerator<any>} generator The async generator to stream.
 * @param {HeadersInit} headers Headers for the Response.
 * @returns {Response} A streaming Response.
 */
function generatorToStreamResponse(generator, headers) {
  const stream = new ReadableStream({
    async start(controller) {
      const encoder = new TextEncoder();
      try {
        for await (const value of generator) {
          controller.enqueue(encoder.encode(String(value)));
        }
      } catch (e) {
        logger.error('Error in streaming generator response:', e);
        // The error will be propagated to the client through the stream.
        controller.error(e);
      } finally {
        controller.close();
      }
    },
  });
  return new Response(stream, { headers });
}

/**
 * @typedef {import('bun:sqlite').Database} BunDatabase
 * @typedef {import('./ai.server.js').AgentDefinition} AgentDefinition
 * @typedef {import('./ai.server.js').ChatContext} ChatContext
 */

/**
 * @typedef {'public' | 'private'} FileAccessLevel
 */

/**
 * @typedef {object} ApiContext
 * @property {BunDatabase} db
 * @property {import('./ai.server.js').AI} ai
 * @property {Record<string, Function>} syncActions
 * @property {string} SYNC_TOPIC
 * @property {Record<string, AgentDefinition>} [agentRoutes]
 * @property {ChatContext} [chatContext]
 */

/**
 * @param {Request & { user?: any }} req
 * @param {import('bun').Server} server
 * @param {ApiContext} context
 */
export async function handleApiRequest(req, server, context) {
  const { db, ai, syncActions, agentRoutes } = context;
  const url = new URL(req.url);
  const { pathname } = url;

  if (pathname.startsWith('/api/ai/')) {
    if (!req.user) return new Response('Unauthorized', { status: 401 });
    try {
      if (pathname.endsWith('/generate') && req.method === 'POST') {
        const { prompt, options } = await req.json();
        const generator = ai.generate(prompt, options);
        return generatorToStreamResponse(generator, {
          'Content-Type': 'text/plain; charset=utf-8',
        });
      }

      const chatMatch = pathname.match(/^\/api\/ai\/chats\/?([a-zA-Z0-9-]+)?$/);
      if (chatMatch) {
        const chatId = chatMatch[1];
        const chatContext = { db, user: req.user, syncActions, server };

        if (req.method === 'GET' && !chatId) {
          const chats = await ai.getChats(chatContext);
          return Response.json(chats);
        }
        if (req.method === 'PATCH' && chatId) {
          const updates = await req.json();
          const updated = await ai.updateChat(chatId, updates, chatContext);
          return Response.json(updated);
        }
        if (req.method === 'DELETE' && chatId) {
          const result = await ai.deleteChat(chatId, chatContext);
          return Response.json(result);
        }
      }

      if (pathname.endsWith('/chats/new') && req.method === 'POST') {
        const { message, options } = await req.json();
        const { chatId } = await ai.createChat(
          { message, options },
          { db, user: req.user, syncActions, server },
        );
        return new Response(null, {
          status: 302,
          headers: { Location: `/chat/${chatId}` },
        });
      }

      if (pathname.endsWith('/chat') && req.method === 'POST') {
        const { messages, options } = await req.json();
        const generator = ai.chat(messages, options);
        return generatorToStreamResponse(generator, {
          'Content-Type': 'text/plain; charset=utf-8',
        });
      }

      const agentRunMatch = pathname.match(/^\/api\/ai\/agent\/run\/(.+)$/);
      if (agentRunMatch && req.method === 'POST') {
        const agentName = agentRunMatch[1];
        if (!agentName) {
          return new Response(`Agent name is missing.`, {
            status: 400,
          });
        }
        const agentDef = agentRoutes && agentRoutes[agentName];

        if (!agentDef) {
          return new Response(`Agent '${agentName}' not found.`, {
            status: 404,
          });
        }

        const { messages, options } = await req.json();

        const toolContext = {
          db,
          user: req.user,
          fs: createFileSystemForUser(req.user.id),
          ai,
        };

        const generator = ai.agent(messages, agentDef, toolContext, options);
        return generatorToStreamResponse(generator, {
          'Content-Type': 'application/x-ndjson; charset=utf-8',
        });
      }

      if (pathname.endsWith('/search/files') && req.method === 'POST') {
        const { query, limit } = await req.json();
        const results = await ai.search(query, limit, {
          userId: req.user.id,
        });
        return Response.json(results);
      }

      if (pathname.startsWith('/api/ai/models/')) {
        if (pathname.endsWith('/list'))
          return Response.json((await ai.list()) || []);
        if (pathname.endsWith('/pull') && req.method === 'POST') {
          const { model } = await req.json();
          const pullGenerator = ai.pull(model);
          return generatorToStreamResponse(pullGenerator, {
            'Content-Type': 'application/x-ndjson; charset=utf-8',
          });
        }
        if (pathname.endsWith('/delete') && req.method === 'POST') {
          const { model } = await req.json();
          await ai.delete(model);
          return Response.json({ success: true, model });
        }
      }
    } catch (err) {
      logger.error('AI API Error:', err);
      const error = /** @type {Error} */ (err);
      return new Response(error.message, { status: 500 });
    }
  }

  if (pathname.startsWith('/api/fs/') && req.method === 'PUT') {
    if (!req.user) return new Response('Unauthorized', { status: 401 });
    const filePath = decodeURIComponent(pathname.substring('/api/fs/'.length));
    if (!filePath)
      return new Response('File path is required', { status: 400 });

    try {
      const fs = createFileSystemForUser(req.user.id);
      /** @type {FileAccessLevel} */
      const access =
        url.searchParams.get('access') === 'private' ? 'private' : 'public';

      if (!req.body) {
        return new Response('Request body is missing', { status: 400 });
      }
      await fs.write(filePath, req.body, { access });

      const fileBlob = await fs.cat(filePath, { access });
      const fileContent = await fileBlob.text();
      const stats = await fs.stat(filePath, { access });

      await ai.indexFile(
        { path: filePath, content: fileContent },
        { userId: req.user.id },
      );

      const record = {
        path: filePath,
        user_id: req.user.id,
        content: fileContent,
        access: access,
        size: stats.size,
        last_modified: new Date().toISOString(),
      };

      if (syncActions.upsertFiles) {
        const result = syncActions.upsertFiles({ user: req.user }, record);
        if (result?.broadcast) {
          server.publish(
            context.SYNC_TOPIC,
            JSON.stringify({ type: 'sync', data: result.broadcast }),
          );
        }
      }

      return new Response(JSON.stringify({ success: true, path: filePath }), {
        status: 201,
      });
    } catch (err) {
      logger.error('Upload Error:', err);
      const error = /** @type {Error} */ (err);
      return new Response(`Upload failed: ${error.message}`, { status: 500 });
    }
  }

  if (pathname.startsWith('/api/auth/')) {
    if (pathname.endsWith('/register')) return registerUser(req, db);
    if (pathname.endsWith('/login')) return loginUser(req, db);
    if (pathname.endsWith('/logout')) return logoutUser(req, db);
  }

  return null;
}

---------- END: server/api.js ----------

---------- START: server/authentication.js ----------
import { generateUUID } from '../shared/utils.js';
import { createLogger } from '../shared/logger.js';

const logger = createLogger('[Auth]');
const SESSION_DURATION_MS = 1000 * 60 * 60 * 24 * 7;

/**
 * @typedef {import("bun:sqlite").Database} BunDatabase
 */

/**
 * @typedef {object} UserCredentials
 * @property {string} email
 * @property {string} username
 * @property {string} password
 */

/**
 * @typedef {object} UserInfo
 * @property {number} id
 * @property {string} username
 * @property {string} email
 */

/**
 * @param {string} password
 * @returns {Promise<string>}
 */
export async function hashPassword(password) {
  return Bun.password.hash(password, { algorithm: 'bcrypt', cost: 10 });
}

/**
 * @param {string} password
 * @param {string} hash
 * @returns {Promise<boolean>}
 */
async function verifyPassword(password, hash) {
  return Bun.password.verify(password, hash);
}

/**
 * @param {BunDatabase} db
 * @param {number} userId
 * @returns {string}
 */
export function createSession(db, userId) {
  const sessionId = generateUUID();
  const expiresAt = new Date(Date.now() + SESSION_DURATION_MS);
  db.query(
    'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
  ).run(sessionId, userId, expiresAt.toISOString());
  return sessionId;
}

/**
 * @param {BunDatabase} db
 * @param {string} sessionId
 */
function deleteSession(db, sessionId) {
  db.query('DELETE FROM sessions WHERE id = ?').run(sessionId);
}

/**
 * @param {BunDatabase} db
 * @param {string | undefined} sessionId
 * @returns {any}
 */
export function getUserFromSession(db, sessionId) {
  if (!sessionId) return null;
  const session = db
    .query('SELECT user_id, expires_at FROM sessions WHERE id = ?')
    .get(sessionId);

  if (!session || new Date(session.expires_at) < new Date()) {
    if (session) deleteSession(db, sessionId);
    return null;
  }
  return db
    .query('SELECT id, username, email FROM users WHERE id = ?')
    .get(session.user_id);
}

/**
 * @param {BunDatabase} db
 * @param {UserCredentials} credentials
 */
async function createUser(db, { email, username, password }) {
  const hashedPassword = await hashPassword(password);
  return db
    .query(
      'INSERT INTO users (email, username, password) VALUES ($email, $username, $password) RETURNING id, email, username',
    )
    .get({ $email: email, $username: username, $password: hashedPassword });
}

/**
 * @param {Request} req
 * @param {BunDatabase} db
 * @returns {Promise<Response>}
 */
export async function registerUser(req, db) {
  try {
    const { email, username, password } = await req.json();
    if (!email || !username || !password || password.length < 8) {
      return new Response(
        'Email, username, and a password of at least 8 characters are required.',
        { status: 400 },
      );
    }
    const existingUser = db
      .query('SELECT id FROM users WHERE email = ? OR username = ?')
      .get(email, username);
    if (existingUser) {
      return new Response(
        'A user with this email or username already exists.',
        { status: 409 },
      );
    }
    const user = await createUser(db, { email, username, password });
    return Response.json(
      { id: user.id, username: user.username, email: user.email },
      { status: 201 },
    );
  } catch (error) {
    logger.error('Registration error:', error);
    return new Response('An internal error occurred.', { status: 500 });
  }
}

/**
 * @param {Request} req
 * @param {BunDatabase} db
 * @returns {Promise<Response>}
 */
export async function loginUser(req, db) {
  try {
    const { email, password } = await req.json();
    if (!email || !password)
      return new Response('Email and password are required.', { status: 400 });

    const user = db
      .query('SELECT id, username, email, password FROM users WHERE email = ?')
      .get(email);
    if (!user) return new Response('Invalid credentials.', { status: 401 });

    const passwordIsValid = await verifyPassword(password, user.password);
    if (!passwordIsValid) {
      return new Response('Invalid credentials.', { status: 401 });
    }

    const sessionId = createSession(db, user.id);
    const headers = new Headers();
    headers.append(
      'Set-Cookie',
      `session_id=${sessionId}; HttpOnly; Path=/; SameSite=Strict; Max-Age=${
        SESSION_DURATION_MS / 1000
      }`,
    );
    return new Response(
      JSON.stringify({
        id: user.id,
        email: user.email,
        username: user.username,
      }),
      { headers },
    );
  } catch (error) {
    logger.error('Login error:', error);
    const typedError = /** @type {Error & { code?: string }} */ (error);
    if (
      typedError.name === 'PasswordVerificationFailed' &&
      typedError.code === 'PASSWORD_UNSUPPORTED_ALGORITHM'
    ) {
      logger.error(
        'Password verification failed: The stored password hash is in an unsupported format.',
      );
      return new Response(
        'Password verification failed: The stored password hash is in an unsupported format.',
        { status: 500 },
      );
    }
    return new Response('An internal error occurred.', { status: 500 });
  }
}
/**
 * @param {Request} req
 * @param {BunDatabase} db
 * @returns {Promise<Response>}
 */
export async function logoutUser(req, db) {
  const sessionId = req.headers.get('cookie')?.match(/session_id=([^;]+)/)?.[1];
  if (sessionId) deleteSession(db, sessionId);
  const headers = new Headers();
  headers.append(
    'Set-Cookie',
    'session_id=; HttpOnly; Path=/; SameSite=Strict; Max-Age=0',
  );
  return new Response(null, { status: 204, headers });
}

---------- END: server/authentication.js ----------

---------- START: server/bundler.js ----------
#!/usr/bin/env bun

/**
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('bun').BuildOutput} BuildOutput
 */

/**
 * Database configuration specifically for the client-side bundle.
 * @typedef {object} DbConfigForClient
 * @property {number} version - The database schema version.
 * @property {any[]} clientTables - An array of table schemas for the client-side database.
 */

/**
 * Represents a layout wrapper component entrypoint.
 * @typedef {object} LayoutWrapperEntrypoint
 * @property {string} name - The unique name of the layout wrapper.
 * @property {string} path - The path to the generated layout wrapper file.
 */
import { writeFile } from 'fs/promises';
import { join, relative, dirname, resolve, basename } from 'path';
import { createLogger } from '../shared/logger.js';
import bunPluginTailwind from 'bun-plugin-tailwind';

const logger = createLogger('[Bundler]');

/**
 * Prepares the main client-side entrypoint file.
 * @param {string[]} sourceEntrypoints - Array of paths to .webs source files.
 * @param {LayoutWrapperEntrypoint[]} layoutWrapperEntrypoints - Array of layout wrapper objects.
 * @param {DbConfigForClient} dbConfig - The database configuration.
 * @param {Config} config - The global server configuration.
 * @returns {Promise<void>}
 */
async function prepareClientEntrypoint(
  sourceEntrypoints,
  layoutWrapperEntrypoints,
  dbConfig,
  config,
) {
  const appJsDir = dirname(config.TMP_APP_JS);

  const sourceLoaderEntries = sourceEntrypoints.map((fullPath) => {
    const componentName = relative(config.SRC_DIR, fullPath)
      .replace(/\\/g, '/')
      .replace('.webs', '');

    const compiledPath = resolve(
      config.TMP_COMPILED_DIR,
      relative(config.SRC_DIR, fullPath).replace('.webs', '.js'),
    );
    let relPath = relative(appJsDir, compiledPath).replace(/\\/g, '/');

    if (!relPath.startsWith('.')) relPath = './' + relPath;

    logger.debug(
      `Adding client entry for component: '${componentName}' -> '${relPath}'`,
    );
    return `['${componentName}', () => import('${relPath}')]`;
  });

  const layoutWrapperLoaderEntries = layoutWrapperEntrypoints.map(
    ({ name, path }) => {
      let relPath = relative(appJsDir, path).replace(/\\/g, '/');
      if (!relPath.startsWith('.')) relPath = './' + relPath;

      logger.debug(
        `Adding client entry for layout wrapper: '${name}' -> '${relPath}'`,
      );
      return `['${name}', () => import('${relPath}')]`;
    },
  );

  const allLoaderEntries = [
    ...sourceLoaderEntries,
    ...layoutWrapperLoaderEntries,
  ];

  const entrypointContent = `
    import { hydrate } from '@conradklek/webs';
    const dbConfig = ${JSON.stringify({
      version: dbConfig.version,
      clientTables: dbConfig.clientTables,
    })};
    const componentLoaders = new Map([${allLoaderEntries.join(',\n    ')}]);
    hydrate(componentLoaders, dbConfig);
  `;
  await writeFile(config.TMP_APP_JS, entrypointContent);
}

/**
 * Builds the client-side JavaScript and CSS bundles.
 * @param {string[]} sourceEntrypoints - Array of paths to .webs source files.
 * @param {LayoutWrapperEntrypoint[]} layoutWrapperEntrypoints - Array of layout wrapper objects.
 * @param {string[]} publicCssEntrypoints - Array of paths to public CSS files.
 * @param {DbConfigForClient} dbConfig - The database configuration.
 * @param {Config} config - The global server configuration.
 * @returns {Promise<BuildOutput['outputs'] | null>} The build outputs or null if failed.
 */
export async function buildClientBundle(
  sourceEntrypoints,
  layoutWrapperEntrypoints,
  publicCssEntrypoints,
  dbConfig,
  config,
) {
  logger.info('Starting client bundle...');
  await prepareClientEntrypoint(
    sourceEntrypoints,
    layoutWrapperEntrypoints,
    dbConfig,
    config,
  );

  const clientBuildResult = await Bun.build({
    entrypoints: [config.TMP_APP_JS, ...publicCssEntrypoints],
    outdir: config.OUTDIR,
    target: 'browser',
    minify: config.IS_PROD,
    naming: config.IS_PROD ? '[name]-[hash].[ext]' : '[name].[ext]',
    plugins: [bunPluginTailwind],
    sourcemap: config.IS_PROD ? 'none' : 'inline',
    define: {
      'process.env.NODE_ENV': `"${process.env.NODE_ENV || 'development'}"`,
    },
  });

  if (!clientBuildResult.success) {
    logger.error('Client build failed.');
    clientBuildResult.logs.forEach((log) => console.error(log));
    return null;
  }

  logger.info('Client bundle complete.');
  return clientBuildResult.outputs;
}

/**
 * Generates the service worker file.
 * @param {BuildOutput['outputs']} buildOutputs - The outputs from the client bundle build.
 * @param {Config} config - The global server configuration.
 * @returns {Promise<string | null>} The path to the generated service worker or null.
 */
export async function generateServiceWorker(buildOutputs, config) {
  if (!buildOutputs || buildOutputs.length === 0) return null;
  logger.info('Generating service worker...');

  const swTemplatePath = resolve(config.LIB_DIR, './client/service-worker.js');
  if (!(await Bun.file(swTemplatePath).exists())) {
    logger.warn('Service worker template not found. Skipping SW generation.');
    return null;
  }
  const swTemplate = await Bun.file(swTemplatePath).text();

  const manifestForSw = JSON.stringify(
    buildOutputs
      .filter(
        (o) =>
          (o.kind === 'entry-point' || o.kind === 'chunk') &&
          (o.path.endsWith('.js') || o.path.endsWith('.css')),
      )
      .map((o) => ({ url: '/' + basename(o.path) }))
      .filter((entry) => !entry.url.includes('[...'))
      .concat({ url: '/' }),
  );
  const finalSwContent = `const IS_PROD = ${
    config.IS_PROD
  };\nself.__WEBS_MANIFEST = ${manifestForSw};\n\n${swTemplate}`;

  const swOutputPath = join(config.OUTDIR, 'sw.js');
  await writeFile(swOutputPath, finalSwContent);
  logger.info(`Service worker generated at: ${swOutputPath}`);
  return swOutputPath;
}

---------- END: server/bundler.js ----------

---------- START: server/cli.js ----------
#!/usr/bin/env bun

/**
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('./server-config.js').DbConfig} DbConfig
 * @typedef {import('bun').BuildArtifact} BuildArtifact
 * @typedef {import('./ai.server.js').AgentDefinition} AgentDefinition
 * @typedef {import('./router.js').ServerContext} ServerContext
 * @typedef {import('bun').Server & { serverContext?: ServerContext }} BunServerWithContext
 */

/**
 * Represents a single page component's source and compiled file paths.
 * @typedef {object} PageEntrypoint
 * @property {string} source - The absolute path to the source .webs file.
 * @property {string} compiled - The absolute path to the pre-compiled .js file in the temporary directory.
 */

/**
 * Represents the definition of a server route.
 * @typedef {object} RouteDefinition
 * @property {string} path - The URL path for the route (e.g., '/users/:id').
 * @property {object} definition - The route's handler and component information.
 * @property {any} definition.component - The compiled component (or layout wrapper) to render.
 * @property {string} definition.componentName - The unique name of the component.
 * @property {Record<string, Function>} definition.actions - Server-side actions associated with the component.
 * @property {Record<string, Function>} definition.handlers - HTTP method handlers (post, patch, etc.).
 * @property {Record<string, Function>} [definition.wsHandlers] - WebSocket lifecycle handlers.
 * @property {any} [definition.cc] - Compiled native C functions for this route.
 */

/**
 * Represents all the entrypoints and file collections required for a build.
 * @typedef {object} BuildEntries
 * @property {string[]} sourceEntrypoints - All discovered .webs source files.
 * @property {PageEntrypoint[]} pageEntrypoints - .webs files that are pages.
 * @property {string[]} publicCssEntrypoints - CSS files from the public directory.
 * @property {Array<{ name: string; path: string; }>} layoutWrapperEntrypoints - Dynamically generated layout wrapper components.
 */
import { rm, writeFile, exists, readdir } from 'fs/promises';
import { join, relative, dirname, resolve, basename } from 'path';
import {
  config as defaultConfig,
  getDbConfig,
  aiConfig as defaultAiConfig,
} from './server-config.js';
import { setupDatabase } from './db.server.js';
import { AI } from './ai.server.js';
import { startServer } from './server.js';
import { seedDevDatabase, ensureDir } from './server-setup.js';
import { createLogger } from '../shared/logger.js';
import tailwind from 'bun-plugin-tailwind';
import {
  runAnalysis,
  createLockfile,
  generateInspectionReport,
  runGrep,
} from './profiler.js';
import { startDevShell } from './shell.js';
import { cc } from 'bun:ffi';

const logger = createLogger('[Main]');

const colors = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
};

/**
 * @param {keyof typeof colors} color
 * @param {string | number} text
 * @returns {string}
 */
const c = (color, text) => `${colors[color]}${text}${colors.reset}`;

/**
 * @param {Config} config
 */
async function compileFrameworkNativeModules(config) {
  const nativeDir = resolve(config.LIB_DIR, 'native');
  if (!(await exists(nativeDir))) {
    return null;
  }

  logger.info('Compiling framework-level native modules...');
  /** @type {Record<string, any>} */
  const nativeModules = {};
  const files = await readdir(nativeDir);

  for (const file of files) {
    if (file.endsWith('.c')) {
      const baseName = basename(file, '.c');
      const cSourcePath = join(nativeDir, file);
      const symbolsPath = join(nativeDir, `${baseName}.symbols.js`);

      if (await exists(symbolsPath)) {
        try {
          const { symbols: symbolDef } = await import(
            `${symbolsPath}?t=${Date.now()}`
          );

          const { symbols } = cc({
            source: cSourcePath,
            symbols: symbolDef,
          });

          nativeModules[baseName] = symbols;
          logger.info(
            `[CC] Successfully compiled framework module: ${baseName}`,
          );
        } catch (e) {
          logger.error(
            `[CC] Failed to compile framework module ${baseName}:`,
            e,
          );
        }
      }
    }
  }
  return Object.keys(nativeModules).length > 0 ? nativeModules : null;
}

/**
 * @param {string} componentName
 */
function toPascalCase(componentName) {
  return (componentName.split('/').pop() || '')
    .split('-')
    .map((/** @type {string} */ s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');
}

/**
 * @param {string} scriptContent
 * @param {string} filePath
 * @param {string} componentName
 * @param {Config} config
 */
async function getPrimaryExportIdentifier(
  scriptContent,
  filePath,
  componentName,
  config,
) {
  if (/export\s+default\s+\{/.test(scriptContent)) {
    return 'default_inline';
  }

  const tempScriptPath = join(
    config.TMPDIR,
    `${basename(filePath)}.${Date.now()}.mjs`,
  );
  await writeFile(tempScriptPath, scriptContent);

  try {
    const mod = await import(`${tempScriptPath}?v=${Date.now()}`);

    if ('default' in mod) {
      return 'default';
    }

    const namedExports = Object.keys(mod).filter((key) => key !== '__esModule');
    if (namedExports.length === 1 && namedExports[0]) {
      return namedExports[0];
    }

    const pascalComponentName = toPascalCase(componentName);
    if (mod[pascalComponentName]) {
      return pascalComponentName;
    }

    if (namedExports.length > 1) {
      throw new Error(
        `Cannot determine primary export for ${filePath}. Found multiple exports: [${namedExports.join(
          ', ',
        )}]. Please use a default export, a single named export, or a named export matching the component's filename (expected '${pascalComponentName}').`,
      );
    }
  } catch (e) {
    logger.error(`Error analyzing script for ${filePath}:`, e);
  } finally {
    await rm(tempScriptPath, { force: true });
  }
  return null;
}

/**
 * @param {string} filePath
 * @param {string} componentName
 * @param {Config} config
 */
async function compileWebsFile(filePath, componentName, config) {
  const sourceCode = await Bun.file(filePath).text();
  const scriptMatch = /<script[^>]*>(.*?)<\/script>/s.exec(sourceCode);
  const templateMatch = /<template>(.*?)<\/template>/s.exec(sourceCode);
  const styleMatch = /<style>([\s\S]*?)<\/style>/s.exec(sourceCode);

  let scriptContent = scriptMatch?.[1]?.trim() ?? '';
  const templateContent = templateMatch?.[1]?.trim() ?? '';
  const styleContent = styleMatch?.[1]?.trim() ?? '';

  scriptContent = scriptContent.replace(/\.c\?native/g, '.js');

  scriptContent = scriptContent.replace(
    /from\s+['"](.+?)\.webs['"]/g,
    "from '$1.js'",
  );

  const primaryExportIdentifier = await getPrimaryExportIdentifier(
    scriptContent,
    filePath,
    componentName,
    config,
  );

  const isGlobalComponent =
    config.GUI_DIR && filePath.startsWith(config.GUI_DIR);
  let registryImport = '';
  let componentsInjection = '';

  if (!isGlobalComponent) {
    const outPath = resolve(
      config.TMP_COMPILED_DIR,
      relative(config.SRC_DIR, filePath).replace('.webs', '.js'),
    );
    let relPathToRegistry = relative(
      dirname(outPath),
      config.TMP_COMPONENT_REGISTRY,
    ).replace(/\\/g, '/');
    if (!relPathToRegistry.startsWith('.'))
      relPathToRegistry = './' + relPathToRegistry;
    registryImport = `import __globalComponents from '${relPathToRegistry}';\n`;
    componentsInjection = `...(__globalComponents || {})`;
  }

  const injectedProps = `name: '${componentName}', template: ${JSON.stringify(
    templateContent,
  )}, style: ${JSON.stringify(styleContent)}`;

  let finalScript;

  if (!scriptContent.trim() && !primaryExportIdentifier) {
    finalScript = `${registryImport}\nexport default { ${injectedProps}, components: { ${componentsInjection} } };`;
  } else if (primaryExportIdentifier === 'default_inline') {
    let processedScript = scriptContent.replace(
      /(export\s+default\s*\{)/,
      `$1 ${injectedProps},`,
    );
    if (processedScript.includes('components:')) {
      processedScript = processedScript.replace(
        /(components\s*:\s*\{)/,
        `$1 ${componentsInjection},`,
      );
    } else {
      processedScript = processedScript.replace(
        /(export\s+default\s*\{)/,
        `$1 components: { ${componentsInjection} },`,
      );
    }
    finalScript = `${registryImport}${processedScript}`;
  } else if (primaryExportIdentifier) {
    const exportRef =
      primaryExportIdentifier === 'default'
        ? 'default'
        : primaryExportIdentifier;

    finalScript = `
      ${registryImport}
      ${scriptContent}

      const __webs_primary_export = ${
        primaryExportIdentifier === 'default' ? '__default' : exportRef
      };
      const __webs_final_def = {
        ...__webs_primary_export,
        ${injectedProps},
        components: { ...(__webs_primary_export.components || {}), ${componentsInjection} }
      };
      export default __webs_final_def;
    `.replace('__default', 'default');
  } else {
    finalScript = `
      ${registryImport}
      ${scriptContent}
      export default { ${injectedProps}, components: { ${componentsInjection} } };
    `;
  }

  return { js: finalScript, css: styleContent };
}

/**
 * @param {Config} config
 * @returns {Promise<BuildEntries>}
 */
async function prepareBuildFiles(config) {
  logger.info('Stage 1: Starting file pre-compilation...');
  await ensureDir(config.TMP_COMPILED_DIR);

  const websGlob = new Bun.Glob('**/*.{webs,agent.webs}');
  const cssGlob = new Bun.Glob('**/*.css');
  const sourceEntrypoints = [];
  const publicCssEntrypoints = [];
  /** @type {PageEntrypoint[]} */
  const pageEntrypoints = [];

  for await (const file of websGlob.scan(config.SRC_DIR)) {
    const fullPath = join(config.SRC_DIR, file);
    sourceEntrypoints.push(fullPath);

    const relativePath = relative(config.SRC_DIR, fullPath).replace(/\\/g, '/');
    const componentName = relativePath.replace('.webs', '');

    const { js } = await compileWebsFile(fullPath, componentName, config);
    const outPath = join(
      config.TMP_COMPILED_DIR,
      relativePath.replace('.webs', '.js'),
    );

    if (fullPath.startsWith(config.APP_DIR)) {
      pageEntrypoints.push({ source: fullPath, compiled: outPath });
    }

    await ensureDir(dirname(outPath));
    await writeFile(outPath, js);
  }

  if (await exists(config.PUB_DIR)) {
    logger.info(
      'Found src/pub directory. Adding CSS files as build entrypoints...',
    );
    for await (const file of cssGlob.scan(config.PUB_DIR)) {
      publicCssEntrypoints.push(join(config.PUB_DIR, file));
    }
  }

  logger.info('Stage 1: File pre-compilation complete.');
  return {
    sourceEntrypoints,
    pageEntrypoints,
    publicCssEntrypoints,
    layoutWrapperEntrypoints:
      /** @type {Array<{ name: string; path: string; }>} */ ([]),
  };
}

/**
 * @param {Config} config
 */
async function generateComponentRegistry(config) {
  logger.info('Generating global component registry...');
  await ensureDir(dirname(config.TMP_COMPONENT_REGISTRY));
  const glob = new Bun.Glob('**/*.webs');
  const imports = [];
  const exports = [];

  if (await exists(config.GUI_DIR)) {
    for await (const file of glob.scan(config.GUI_DIR)) {
      const componentName = basename(file, '.webs');
      const pascalName = toPascalCase(componentName);

      const compiledPath = resolve(
        config.TMP_COMPILED_DIR,
        'gui',
        `${componentName}.js`,
      );
      let relativePath = relative(
        dirname(config.TMP_COMPONENT_REGISTRY),
        compiledPath,
      ).replace(/\\/g, '/');
      if (!relativePath.startsWith('.')) relativePath = './' + relativePath;

      imports.push(`import ${pascalName} from '${relativePath}';`);
      exports.push(`  '${componentName}': ${pascalName}`);
    }
  }

  const content = `${imports.join(
    '\n',
  )}\n\nexport default {\n${exports.join(',\n')}\n};`;
  await writeFile(config.TMP_COMPONENT_REGISTRY, content);
  logger.info('Global component registry generated.');
}

/**
 * @param {string} pagePath
 * @param {Config} config
 */
async function findLayoutsForPage(pagePath, config) {
  const layouts = [];
  let currentDir = dirname(pagePath);
  while (currentDir.startsWith(config.APP_DIR)) {
    const layoutPath = join(currentDir, 'layout.webs');
    if (await exists(layoutPath)) layouts.push(layoutPath);
    if (currentDir === config.APP_DIR) break;
    currentDir = dirname(currentDir);
  }
  return layouts.reverse();
}

/**
 * @param {PageEntrypoint[]} pageEntrypoints
 * @param {Config} config
 */
async function generateRoutes(pageEntrypoints, config) {
  logger.info('Generating server routes...');
  await ensureDir(config.TMP_WRAPPERS_DIR);

  const routeDefinitions = [];
  /** @type {Record<string, AgentDefinition>} */
  const agentDefinitions = {};
  /** @type {Array<{name: string, path: string}>} */
  const layoutWrapperEntrypoints = [];
  /** @type {Record<string, string>} */
  const sourceToComponentMap = {};

  for (const {
    source: sourcePagePath,
    compiled: compiledPagePath,
  } of pageEntrypoints) {
    const componentPath = relative(config.APP_DIR, sourcePagePath)
      .replace(/\\/g, '/')
      .replace('.webs', '')
      .replace('.agent', '');

    const componentName = `app/${componentPath}`;

    sourceToComponentMap[
      relative(config.SRC_DIR, sourcePagePath).replace(/\\/g, '/')
    ] = componentName;

    if (basename(componentName) === 'layout') continue;

    const mod = await import(`${compiledPagePath}?t=${Date.now()}`);

    let ccSymbols = null;
    const scriptContent = await Bun.file(sourcePagePath).text();
    const scriptMatch = /<script[^>]*>(.*?)<\/script>/s.exec(scriptContent);
    const nativeImportRegex = /from\s+['"](\.\/.*?\.c\?native)['"]/s;

    if (scriptMatch && scriptMatch[1]) {
      const nativeImportMatch = scriptMatch[1].match(nativeImportRegex);
      if (nativeImportMatch && nativeImportMatch[1]) {
        const cSourcePath = resolve(
          dirname(sourcePagePath),
          nativeImportMatch[1].replace('?native', ''),
        );
        if (mod.symbols && (await Bun.file(cSourcePath).exists())) {
          try {
            const { symbols } = cc({
              source: cSourcePath,
              symbols: mod.symbols,
            });
            ccSymbols = symbols;
            logger.info(
              `[CC] Successfully compiled native module for: ${componentName}`,
            );
          } catch (e) {
            logger.error(
              `[CC] Failed to compile native module for ${componentName}:`,
              e,
            );
          }
        } else {
          logger.warn(
            `[CC] Found native import in ${componentName} but could not find a 'symbols' export or the C source file '${cSourcePath}'.`,
          );
        }
      }
    }

    if (sourcePagePath.endsWith('.agent.webs')) {
      const shortAgentName = basename(sourcePagePath, '.agent.webs');
      const fullAgentName = componentName.replace('.agent', '');

      logger.info(
        `Found agent definition: ${fullAgentName} (using short name: '${shortAgentName}')`,
      );

      if (agentDefinitions[shortAgentName]) {
        logger.warn(
          `[!] Duplicate agent short name detected: '${shortAgentName}'. The agent at '${sourcePagePath}' will overwrite the previous definition. To avoid this, please ensure all agent filenames are unique.`,
        );
      }

      agentDefinitions[shortAgentName] = {
        name: fullAgentName,
        system_prompt: mod.system_prompt || '',
        tools: mod.tools || [],
        model: mod.model,
        component: mod.default,
      };
      continue;
    }

    const layouts = await findLayoutsForPage(sourcePagePath, config);
    let finalComponent = mod.default;
    let finalComponentName = componentName;

    if (layouts.length > 0) {
      finalComponentName = `layout/${componentName.replace(/\//g, '_')}`;
      const wrapperPath = join(
        config.TMP_WRAPPERS_DIR,
        `${finalComponentName.split('/')[1]}.js`,
      );
      layoutWrapperEntrypoints.push({
        name: finalComponentName,
        path: wrapperPath,
      });

      const layoutImports = layouts
        .map((p, i) => {
          const relativeSourcePath = relative(config.SRC_DIR, p);
          const targetPath = resolve(
            config.TMP_COMPILED_DIR,
            relativeSourcePath.replace('.webs', '.js'),
          );
          let relativeImportPath = relative(
            dirname(wrapperPath),
            targetPath,
          ).replace(/\\/g, '/');
          if (!relativeImportPath.startsWith('.'))
            relativeImportPath = './' + relativeImportPath;
          return `import Layout${i} from '${relativeImportPath}';`;
        })
        .join('\n');

      let pageComponentRelativePath = relative(
        dirname(wrapperPath),
        compiledPagePath,
      ).replace(/\\/g, '/');
      if (!pageComponentRelativePath.startsWith('.'))
        pageComponentRelativePath = './' + pageComponentRelativePath;

      const wrapperContent = `
                import { h } from '@conradklek/webs';
                ${layoutImports}
                import PageComponent from '${pageComponentRelativePath}';
                export default {
                    name: '${finalComponentName}',
                    props: { params: Object, initialState: Object, user: Object, cc: Object },
                    render() {
                        const pageNode = h(PageComponent, { ...this.$props });
                        return ${layouts.reduceRight(
                          (acc, _, i) =>
                            `h(Layout${i}, { ...this.$props }, { default: () => ${acc} })`,
                          'pageNode',
                        )};
                    }
                };
            `;
      await writeFile(wrapperPath, wrapperContent);
      finalComponent = (await import(`${wrapperPath}?t=${Date.now()}`)).default;
    }

    let urlPath =
      '/' +
      componentPath
        .replace('.webs', '')
        .replace(/index$/, '')
        .replace(/\[\.{3}(\w+)\]/g, ':$1*')
        .replace(/\[(\w+)\]/g, ':$1');

    if (urlPath.length > 1 && urlPath.endsWith('/'))
      urlPath = urlPath.slice(0, -1);

    const actions = mod.actions || (mod.default && mod.default.actions) || {};

    /** @type {Record<string, Function>} */
    const handlers = {};
    const methodNames = ['GET', 'POST', 'PATCH', 'PUT', 'DELETE'];
    for (const method of methodNames) {
      const handler = mod[method] || (mod.default && mod.default[method]);
      if (typeof handler === 'function') {
        handlers[method.toLowerCase()] = handler;
      }
    }

    /** @type {Record<string, Function>} */
    const wsHandlers = {};
    const wsHandlerNames = ['onOpen', 'onMessage', 'onClose', 'onError'];
    for (const handlerName of wsHandlerNames) {
      const handler =
        mod[handlerName] || (mod.default && mod.default[handlerName]);
      if (typeof handler === 'function') {
        wsHandlers[handlerName] = handler;
      }
    }

    routeDefinitions.push({
      path: urlPath,
      definition: {
        component: finalComponent,
        componentName: finalComponentName,
        actions: actions,
        handlers: handlers,
        wsHandlers: wsHandlers,
        cc: ccSymbols,
      },
    });
  }

  routeDefinitions.sort((a, b) => {
    const aIsCatchAll = a.path.includes('*');
    const bIsCatchAll = b.path.includes('*');
    if (aIsCatchAll && !bIsCatchAll) return 1;
    if (!aIsCatchAll && bIsCatchAll) return -1;

    const aDynamicParts = (a.path.match(/:\w+/g) || []).length;
    const bDynamicParts = (b.path.match(/:\w+/g) || []).length;
    if (aDynamicParts !== bDynamicParts) {
      return aDynamicParts - bDynamicParts;
    }

    return b.path.length - a.path.length;
  });

  logger.info('Server routes and agent definitions generated.');
  return {
    appRoutes: Object.fromEntries(
      routeDefinitions.map((r) => [r.path, r.definition]),
    ),
    agentRoutes: agentDefinitions,
    layoutWrapperEntrypoints,
    sourceToComponentMap,
  };
}

/**
 * @param {BuildEntries} entries
 * @param {DbConfig} dbConfig
 * @param {Config} config
 * @returns {Promise<BuildArtifact[] | null>}
 */
async function buildClientBundle(entries, dbConfig, config) {
  logger.info('Starting client bundle...');

  const { sourceEntrypoints, layoutWrapperEntrypoints, publicCssEntrypoints } =
    entries;

  const allLoaderEntries = [
    ...sourceEntrypoints.map((/** @type {string} */ fullPath) => {
      const componentName = relative(config.SRC_DIR, fullPath)
        .replace(/\\/g, '/')
        .replace('.webs', '');
      const compiledPath = join(
        config.TMP_COMPILED_DIR,
        relative(config.SRC_DIR, fullPath).replace('.webs', '.js'),
      );
      let relPath = relative(dirname(config.TMP_APP_JS), compiledPath).replace(
        /\\/g,
        '/',
      );
      if (!relPath.startsWith('.')) relPath = './' + relPath;
      return `['${componentName}', () => import('${relPath}')]`;
    }),
    ...layoutWrapperEntrypoints.map(({ name, path }) => {
      let relPath = relative(dirname(config.TMP_APP_JS), path).replace(
        /\\/g,
        '/',
      );
      if (!relPath.startsWith('.')) relPath = './' + relPath;
      return `['${name}', () => import('${relPath}')]`;
    }),
  ];

  const entrypointContent = `
        import { hydrate } from '@conradklek/webs';
        const dbConfig = ${JSON.stringify({
          version: dbConfig.version,
          clientTables: dbConfig.clientTables,
        })};
        const componentLoaders = new Map([${allLoaderEntries.join(',\n    ')}]);
        hydrate(componentLoaders, dbConfig);
    `;
  await writeFile(config.TMP_APP_JS, entrypointContent);

  const clientBuildResult = await Bun.build({
    entrypoints: [config.TMP_APP_JS, ...publicCssEntrypoints],
    outdir: config.OUTDIR,
    target: 'browser',
    splitting: true,
    minify: config.IS_PROD,
    naming: config.IS_PROD ? '[name]-[hash].[ext]' : '[name].[ext]',
    plugins: [tailwind],
    loader: { '.js': 'jsx' },
    sourcemap: config.IS_PROD ? 'none' : 'inline',
    define: {
      'process.env.NODE_ENV': `"${process.env.NODE_ENV || 'development'}"`,
    },
  });

  if (!clientBuildResult.success) {
    logger.error('Client build failed.');
    clientBuildResult.logs.forEach((log) => console.error(log));
    return null;
  }

  logger.info('Client bundle complete.');
  return clientBuildResult.outputs;
}

/**
 * @param {BuildArtifact[] | null} buildOutputs
 * @param {Config} config
 */
async function generateServiceWorker(buildOutputs, config) {
  if (!buildOutputs) return null;
  logger.info('Generating service worker...');
  const swTemplatePath = resolve(config.LIB_DIR, './client/service-worker.js');
  if (!(await exists(swTemplatePath))) {
    logger.warn('Service worker template not found.');
    return null;
  }
  const swTemplate = await Bun.file(swTemplatePath).text();
  const manifestForSw = JSON.stringify(
    buildOutputs
      .filter(
        (/** @type {BuildArtifact} */ o) =>
          (o.kind === 'entry-point' || o.kind === 'chunk') &&
          (o.path.endsWith('.js') || o.path.endsWith('.css')),
      )
      .map((/** @type {BuildArtifact} */ o) => ({
        url: '/' + basename(o.path),
      }))
      .concat({ url: '/' }),
  );
  const finalSwContent = `const IS_PROD = ${
    config.IS_PROD
  };\nself.__WEBS_MANIFEST = ${manifestForSw};\n\n${swTemplate}`;
  const swOutputPath = join(config.OUTDIR, 'sw.js');
  await writeFile(swOutputPath, finalSwContent);
  logger.info(`Service worker generated at: ${swOutputPath}`);
  return swOutputPath;
}

/**
 * @param {Config} config
 * @param {boolean} interactive
 */
async function runBuildAndServe(config, interactive = false) {
  const devInfoPath = join(config.TMPDIR, 'dev.json');

  const cleanup = async () => {
    if (await exists(devInfoPath)) {
      await rm(devInfoPath, { force: true });
    }
    if (!interactive) process.exit();
  };
  process.on('SIGINT', cleanup);
  process.on('exit', cleanup);

  await rm(config.TMPDIR, { recursive: true, force: true });
  await ensureDir(config.TMPDIR);

  const frameworkNativeModules = await compileFrameworkNativeModules(config);

  const dbConfig = getDbConfig();
  const aiConfig = {
    ...defaultAiConfig,
    db: { ...defaultAiConfig.db, path: join(config.TMPDIR, 'ai.db') },
  };
  const ai = new AI(aiConfig);
  await ai.init();
  logger.info('AI module initialized.');

  let buildEntries = await prepareBuildFiles(config);
  await generateComponentRegistry(config);

  const { default: globalComponents } = await import(
    `${config.TMP_COMPONENT_REGISTRY}?t=${Date.now()}`
  );

  const db = await setupDatabase(dbConfig, config.CWD, writeFile, config);
  if (!config.IS_PROD) {
    /** @type {Record<string, string>} */
    const docFiles = {};
    const docsDir = resolve(config.CWD, 'docs');
    if (await exists(docsDir)) {
      logger.info(
        'Found ./docs directory, loading markdown files for seeding...',
      );
      const docGlob = new Bun.Glob('**/*.md');
      for await (const file of docGlob.scan(docsDir)) {
        const fullPath = join(docsDir, file);
        const content = await Bun.file(fullPath).text();
        const relativePath = join('docs', file).replace(/\\/g, '/');
        docFiles[relativePath] = content;
      }
    }
    await seedDevDatabase(db, config, ai, docFiles);
  }

  let {
    appRoutes,
    agentRoutes,
    layoutWrapperEntrypoints,
    sourceToComponentMap,
  } = await generateRoutes(buildEntries.pageEntrypoints, config);
  buildEntries.layoutWrapperEntrypoints = layoutWrapperEntrypoints;

  const buildOutputs = await buildClientBundle(buildEntries, dbConfig, config);

  const jsOutput = buildOutputs?.find(
    (o) => o.kind === 'entry-point' && o.path.endsWith('.js'),
  );
  const cssOutput = buildOutputs?.find((o) => o.path.endsWith('.css'));
  let manifest = {
    js: jsOutput?.path,
    css: cssOutput?.path,
    sw: (await generateServiceWorker(buildOutputs, config)) || undefined,
  };

  /** @type {ServerContext} */
  const serverContext = {
    db,
    ai,
    dbConfig,
    manifest,
    appRoutes,
    agentRoutes,
    config,
    isProd: config.IS_PROD,
    SYNC_TOPIC: 'webs-sync',
    actionsPath: config.TMP_GENERATED_ACTIONS,
    globalComponents,
    sourceToComponentMap,
    frameworkNativeModules,
    syncActions: (
      await import(`${config.TMP_GENERATED_ACTIONS}?t=${Date.now()}`)
    ).registerActions(db),
    sourceEntrypoints: buildEntries.sourceEntrypoints,
  };

  const serverOptions = await startServer(serverContext);
  /** @type {BunServerWithContext} */
  const server = Bun.serve(serverOptions);
  ai.initialize(server, agentRoutes);
  server.serverContext = serverContext;

  await writeFile(
    devInfoPath,
    JSON.stringify({ pid: process.pid, port: server.port }),
  );

  if (!config.IS_PROD) {
    if (interactive) {
      await startDevShell(config, server, ai, serverContext);
      await cleanup();
      server.stop(true);
      process.exit();
    }
  }
}

/**
 * @param {Config} config
 */
async function runInspection(config) {
  await rm(config.TMPDIR, { recursive: true, force: true });
  await ensureDir(config.TMPDIR);

  const buildEntries = await prepareBuildFiles(config);
  await generateComponentRegistry(config);

  const { appRoutes, agentRoutes, sourceToComponentMap } = await generateRoutes(
    buildEntries.pageEntrypoints,
    config,
  );

  await generateInspectionReport({
    appRoutes,
    agentRoutes,
    sourceEntrypoints: buildEntries.sourceEntrypoints,
    config,
    sourceToComponentMap,
  });
}

/**
 * @param {string[]} args
 * @param {string} flag
 */
function getFlagValues(args, flag) {
  const flagIndex = args.indexOf(flag);
  const values = [];
  if (flagIndex !== -1) {
    for (let i = flagIndex + 1; i < args.length; i++) {
      const arg = args[i];
      if (arg && arg.startsWith('--')) {
        break;
      }
      if (arg) {
        values.push(arg);
      }
    }
  }
  return values;
}

/**
 * @param {string[]} args
 */
async function getTargetDirectory(args) {
  const targetFlagIndex = args.indexOf('--target');
  const targetArg = args[targetFlagIndex + 1];
  if (targetFlagIndex !== -1 && targetArg) {
    return resolve(targetArg);
  }

  const pkgPath = resolve(process.cwd(), 'package.json');
  if (await exists(pkgPath)) {
    const pkg = await Bun.file(pkgPath).json();
    if (
      pkg.name === '@conradklek/webs' &&
      (await exists(resolve(process.cwd(), 'lib')))
    ) {
      logger.info(
        "Detected execution within framework repository, targeting 'lib'.",
      );
      const libSrcExists = await exists(resolve(process.cwd(), 'lib', 'src'));
      return libSrcExists ? resolve(process.cwd(), 'lib') : process.cwd();
    }
  }

  logger.info(
    'Assuming execution in a consumer project, targeting current directory.',
  );
  return process.cwd();
}

async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || (defaultConfig.IS_PROD ? 'start' : 'dev');

  const targetDir = await getTargetDirectory(args);

  const config = {
    ...defaultConfig,
    CWD: targetDir,
    OUTDIR: resolve(targetDir, 'dist'),
    TMPDIR: resolve(targetDir, '.webs'),
    TMP_COMPILED_DIR: resolve(targetDir, '.webs/compiled'),
    TMP_WRAPPERS_DIR: resolve(targetDir, '.webs/layout'),
    TMP_APP_JS: resolve(targetDir, '.webs/app.js'),
    TMP_APP_CSS: resolve(targetDir, '.webs/app.css'),
    SRC_DIR: resolve(targetDir, 'src'),
    APP_DIR: resolve(targetDir, 'src/app'),
    PUB_DIR: resolve(targetDir, 'src/pub'),
    GUI_DIR: resolve(targetDir, 'src/gui'),
    USER_FILES_ROOT: resolve(targetDir, '.webs/files'),
    TMP_GENERATED_ACTIONS: resolve(targetDir, '.webs/actions.js'),
    TMP_COMPONENT_REGISTRY: resolve(targetDir, '.webs/registry.js'),
  };

  switch (command) {
    case 'dev':
      await runBuildAndServe(config, true);
      break;
    case 'start':
      await runBuildAndServe(config, false);
      break;
    case 'inspect':
      await runInspection(config);
      break;
    case 'shell':
      console.log(
        "'webs shell' is now integrated into 'webs dev'.\nStarting dev server and shell...",
      );
      await runBuildAndServe(config, true);
      break;
    case 'grep': {
      const [pattern, path = config.CWD, ...rest] = args.slice(1);
      const includeIndex = rest.indexOf('--include');
      const filePattern =
        includeIndex > -1 ? rest[includeIndex + 1] : undefined;
      if (!pattern) {
        console.error('Usage: webs grep <pattern> [path] [--include <glob>]');
        process.exit(1);
      }
      await runGrep(pattern, path, filePattern);
      break;
    }
    case 'analyze':
      console.log(`Analyzing directory: ${targetDir}`);
      await runAnalysis(targetDir);
      break;
    case 'lock': {
      let lockTarget = args[1];
      let lockTargetDir;

      if (lockTarget === 'lib' || lockTarget === 'src') {
        lockTargetDir = resolve(process.cwd(), lockTarget);
        if (!(await exists(lockTargetDir))) {
          console.error(`Error: Directory './${lockTarget}' not found.`);
          process.exit(1);
        }
      } else {
        lockTargetDir = targetDir;
        if (lockTarget && !lockTarget.startsWith('--')) {
          console.warn(
            `Warning: Unknown lock target '${lockTarget}'. Using default target. Supported: 'lib', 'src'.`,
          );
        }
      }

      console.log(
        `Creating lockfile for: ./${relative(process.cwd(), lockTargetDir)}`,
      );

      const includedFiles = getFlagValues(args, '--include');
      const excludedPatterns = getFlagValues(args, '--exclude');

      await createLockfile(lockTargetDir, includedFiles, excludedPatterns);
      break;
    }
    case 'ai': {
      const aiCommand = args[1];
      if (aiCommand === 'query') {
        const queryText = args.slice(2).join(' ');
        if (!queryText) {
          console.error(c('red', 'Usage: webs ai query "<your query>"'));
          process.exit(1);
        }

        console.log(c('dim', 'Initializing AI engine...'));
        const dbConfig = getDbConfig();
        const db = await setupDatabase(dbConfig, config.CWD, writeFile, config);
        const aiConfig = {
          ...defaultAiConfig,
          db: { ...defaultAiConfig.db, path: join(config.TMPDIR, 'ai.db') },
        };
        const ai = new AI(aiConfig);
        await ai.init();

        const anonUser = db
          .query('SELECT id FROM users WHERE username = ?')
          .get('anon');

        if (!anonUser) {
          console.error(c('red', "Could not find 'anon' user for searching."));
          await ai.shutdown();
          process.exit(1);
        }

        console.log(c('bold', `\nSearching for: "${queryText}"`));
        const results = await ai.search(queryText, 5, {
          userId: /** @type {{id: number}} */ (anonUser).id,
        });

        if (results.length > 0) {
          console.log(c('green', `Found ${results.length} results:`));
          results.forEach((r, i) => {
            console.log(
              `\n${i + 1}. ${c('bold', c('yellow', r.metadata.filePath))} ${c(
                'dim',
                `(Score: ${r.score.toFixed(4)})`,
              )}`,
            );
            const snippet = r.text
              .split('\n')
              .filter((line) => line.trim())
              .slice(0, 3)
              .join('\n');
            console.log(
              c('dim', snippet + (r.text.split('\n').length > 3 ? '...' : '')),
            );
          });
        } else {
          console.log(c('yellow', 'No results found.'));
        }

        await ai.shutdown();
        process.exit(0);
      }
      console.log(
        "'webs ai' is now integrated into 'webs dev'.\nStarting dev server and shell...",
      );
      await runBuildAndServe(config, true);
      break;
    }
    default:
      console.error(`Unknown command: ${command}`);
      console.log(
        'Available commands: dev, start, inspect, grep, analyze, lock',
      );
      process.exit(1);
  }
}

main().catch((e) => {
  logger.error('Fatal error:', e);
  process.exit(1);
});

---------- END: server/cli.js ----------

---------- START: server/db.server.js ----------
import { resolve as pathResolve } from 'path';
import { Database } from 'bun:sqlite';
import { createLogger } from '../shared/logger.js';

/**
 * @typedef {object} Field
 * @property {string} type
 * @property {boolean} [primaryKey]
 * @property {boolean} [notNull]
 * @property {boolean} [unique]
 * @property {any} [default]
 * @property {string} [references]
 * @property {string} [onDelete]
 */

/**
 * @typedef {object} Table
 * @property {string[]} [primaryKeys]
 * @property {string} [keyPath]
 * @property {Record<string, Field | string>} fields
 * @property {boolean} [sync]
 * @property {{ name: string, keyPath: string }[]} [indexes]
 */

const logger = createLogger('[DB]');

/**
 * @param {string} type
 */
function toSqliteType(type) {
  switch (type) {
    case 'string':
    case 'text':
      return 'TEXT';
    case 'number':
    case 'integer':
      return 'INTEGER';
    case 'boolean':
      return 'INTEGER';
    case 'float':
    case 'real':
      return 'REAL';
    case 'buffer':
    case 'blob':
      return 'BLOB';
    case 'timestamp':
      return 'TIMESTAMP';
    default:
      return 'TEXT';
  }
}
/**
 * @param {string} name
 * @param {Field | string} props
 */
function getColumnSql(name, props) {
  const definition = typeof props === 'string' ? { type: props } : props;
  let columnSql = `"${name}" ${toSqliteType(definition.type)}`;
  if (definition.primaryKey) columnSql += ' PRIMARY KEY';
  if (definition.notNull) columnSql += ' NOT NULL';
  if (definition.unique) columnSql += ' UNIQUE';
  if (definition.default !== undefined) {
    columnSql += ` DEFAULT ${
      typeof definition.default === 'string'
        ? `'${definition.default}'`
        : definition.default
    }`;
  }
  return columnSql;
}

/**
 * @param {string} tableName
 * @param {Table} table
 */
function createTableSql(tableName, table) {
  const fields = Object.entries(table.fields).map(([name, props]) =>
    getColumnSql(name, props),
  );

  const foreignKeys = Object.entries(table.fields)
    .filter(([, props]) => typeof props !== 'string' && props.references)
    .map(([fieldName, props]) => {
      let fkSql = `FOREIGN KEY ("${fieldName}") REFERENCES ${
        /** @type {Field} */ (props).references
      }`;
      if (/** @type {Field} */ (props).onDelete)
        fkSql += ` ON DELETE ${/** @type {Field} */ (props).onDelete}`;
      return fkSql;
    });

  const constraints = [...foreignKeys];
  if (table.primaryKeys && table.primaryKeys.length > 0) {
    constraints.push(
      `PRIMARY KEY (${table.primaryKeys.map((pk) => `"${pk}"`).join(', ')})`,
    );
  }

  const constraintsSql =
    constraints.length > 0 ? `, ${constraints.join(', ')}` : '';

  return `CREATE TABLE IF NOT EXISTS "${tableName}" (${fields.join(
    ', ',
  )}${constraintsSql});`;
}
/**
 * @param {[string, Table][]} syncableTables
 */
function createActionsFileContent(syncableTables) {
  const actions = syncableTables
    .map(([tableName, table]) => {
      const upperCaseName =
        tableName.charAt(0).toUpperCase() + tableName.slice(1);
      const fieldNames = Object.keys(table.fields);

      let updateSet = fieldNames
        .filter((f) => {
          const pks =
            table.primaryKeys || (table.keyPath ? [table.keyPath] : []);
          return !pks.includes(f) && f !== 'created_at';
        })
        .map((f) => `"${f}" = excluded."${f}"`);

      if (table.fields.updated_at)
        updateSet.push(`updated_at = CURRENT_TIMESTAMP`);

      const conflictTarget = (
        table.primaryKeys || (table.keyPath ? [table.keyPath] : [])
      )
        .map((pk) => `"${pk}"`)
        .join(', ');

      const upsertSql = `INSERT INTO "${tableName}" (${fieldNames
        .map((f) => `"${f}"`)
        .join(', ')}) VALUES (${fieldNames
        .map((f) => `$${f}`)
        .join(
          ', ',
        )}) ON CONFLICT(${conflictTarget}) DO UPDATE SET ${updateSet.join(
        ', ',
      )}`
        .trim()
        .replace(/\s+/g, ' ');

      const deleteKeys =
        table.primaryKeys || (table.keyPath ? [table.keyPath] : []);
      const deleteWhereClause = deleteKeys
        .map((key) => `"${key}" = $${key}`)
        .join(' AND ');
      const deleteSql = `DELETE FROM "${tableName}" WHERE ${deleteWhereClause};`;

      const deleteActionBody =
        tableName === 'files'
          ? `
      if (!user?.id) throw new Error('Authorization error.');
      const recordToDelete = db.query('SELECT user_id FROM files WHERE path = ? AND user_id = ?').get(record.path, user.id);
      if (!recordToDelete) return { error: 'File not found or permission denied.'};
      delete${upperCaseName}Stmt.run({ $path: record.path, $user_id: user.id });
      return { broadcast: { tableName: '${tableName}', type: 'delete', id: [record.path, user.id] } };
    `
          : `
      if (!user?.id) throw new Error('Authorization error.');
      const recordToDelete = db.query('SELECT user_id FROM "${tableName}" WHERE id = ? AND user_id = ?').get(record.id, user.id);
      if (!recordToDelete) return { error: 'Record not found or permission denied.' };
      delete${upperCaseName}Stmt.run({ $id: record.id, $user_id: user.id });
      return { broadcast: { tableName: '${tableName}', type: 'delete', id: record.id } };
    `;

      return `
    const upsert${upperCaseName}Stmt = db.prepare(\`${upsertSql}\`);
    const delete${upperCaseName}Stmt = db.prepare(\`${deleteSql}\`);
    actions.upsert${upperCaseName} = ({ user }, record) => {
      if (!user?.id || (record.user_id && user.id !== record.user_id)) throw new Error('Authorization error.');
      const finalRecord = { ...record, user_id: user.id, updated_at: new Date().toISOString() };
      const params = Object.fromEntries(Object.entries(finalRecord).map(([key, value]) => [\`$\${key}\`, value]));
      upsert${upperCaseName}Stmt.run(params);
      return { broadcast: { tableName: '${tableName}', type: 'put', data: finalRecord } };
    };
    actions.delete${upperCaseName} = ({ user }, record) => {
      ${deleteActionBody}
    };`;
    })
    .join('');

  return `export function registerActions(db) { const actions = {}; ${actions} return actions; };`;
}
/**
 * @param {object} dbConfig
 * @param {string} dbConfig.name
 * @param {number} dbConfig.version
 * @param {Record<string, Table>} dbConfig.tables
 * @param {string} cwd
 * @param {(path: string, content: string) => Promise<void>} writeFile
 * @param {object} config
 * @param {string} config.TMP_GENERATED_ACTIONS
 * @returns {Promise<Database>}
 */
export async function setupDatabase(dbConfig, cwd, writeFile, config) {
  if (!dbConfig?.name) throw new Error('Database file name not specified.');
  const dbFilePath = pathResolve(cwd, `.webs/${dbConfig.name}`);
  const db = new Database(dbFilePath, { create: true });
  db.run('PRAGMA journal_mode = WAL; PRAGMA foreign_keys = ON;');
  db.run(
    `CREATE TABLE IF NOT EXISTS _migrations (version INTEGER PRIMARY KEY);`,
  );

  const lastVersion =
    db
      .query('SELECT version FROM _migrations ORDER BY version DESC LIMIT 1')
      .get()?.version || 0;

  if (dbConfig.version > lastVersion) {
    logger.info(
      `Migrating database from v${lastVersion} to v${dbConfig.version}...`,
    );
    const migrationTx = db.transaction(() => {
      Object.entries(dbConfig.tables).forEach(([tableName, tableDef]) => {
        db.run(createTableSql(tableName, tableDef));
        const existingColumns = db
          .prepare(`PRAGMA table_info("${tableName}")`)
          .all()
          .map((/** @type {{ name: any; }} */ col) => col.name);
        Object.entries(tableDef.fields).forEach(([fieldName, fieldProps]) => {
          if (!existingColumns.includes(fieldName)) {
            logger.debug(
              `Adding column '${fieldName}' to table '${tableName}'.`,
            );
            db.run(
              `ALTER TABLE "${tableName}" ADD COLUMN ${getColumnSql(
                fieldName,
                fieldProps,
              )}`,
            );
          }
        });
        if (tableDef.indexes) {
          tableDef.indexes.forEach((index) => {
            logger.debug(
              `Creating index '${index.name}' on table '${tableName}'.`,
            );
            db.run(
              `CREATE INDEX IF NOT EXISTS "${index.name}" ON "${tableName}" ("${index.keyPath}")`,
            );
          });
        }
      });
      db.query('INSERT INTO _migrations (version) VALUES (?)').run(
        dbConfig.version,
      );
    });
    migrationTx();
    logger.info('Database migration complete.');
  }

  const syncableTables = Object.entries(dbConfig.tables).filter(
    ([, def]) => def.sync,
  );
  const generatedActionsContent = createActionsFileContent(syncableTables);
  await writeFile(config.TMP_GENERATED_ACTIONS, generatedActionsContent);
  logger.info('Generated sync actions file.');
  return db;
}

---------- END: server/db.server.js ----------

---------- START: server/fs.server.js ----------
import { join, resolve, dirname } from 'path';
import {
  cp as copy,
  mkdir as fsMkdir,
  rename,
  rm as fsRm,
  stat as fsStat,
  readdir,
} from 'node:fs/promises';
import { createLogger } from '../shared/logger.js';
import { write, file as bunFile } from 'bun';

/** @typedef {import('bun:sqlite').Database} BunDatabase */
/** @typedef {import('bun').BunFile} BunFile */

/**
 * @typedef {'public' | 'private'} FileAccessLevel
 */

/**
 * @typedef {object} FsOptions
 * @property {FileAccessLevel} [access='public'] - The access level for the file operation.
 */

/**
 * @typedef {object} FileStats
 * @property {boolean} isFile - True if the path points to a file.
 * @property {boolean} isDirectory - True if the path points to a directory.
 * @property {number} size - The size of the file in bytes.
 * @property {Date} mtime - The last modification time.
 * @property {Date} birthtime - The creation time.
 */

/**
 * @typedef {object} ServerFsApi
 * @property {() => string} getPrivateRootPath - Gets the absolute path to the user's private directory.
 * @property {(path: string, options?: FsOptions) => Promise<boolean>} exists - Checks if a file or directory exists.
 * @property {(path: string, options?: FsOptions) => Promise<FileStats>} stat - Retrieves stats for a file or directory.
 * @property {(path: string, options?: FsOptions) => Promise<import('bun').BunFile>} cat - Reads a file and returns a `BunFile` object for streaming or consumption.
 * @property {(path?: string, options?: FsOptions) => Promise<Array<{name: string, isDirectory: boolean, path: string}>>} ls - Lists the contents of a directory.
 * @property {(path: string, options?: FsOptions) => Promise<string | undefined>} mkdir - Creates a new directory.
 * @property {(path: string, data: import('bun').file | Blob | string | Buffer | ArrayBuffer | ReadableStream, options?: FsOptions) => Promise<number | void>} write - Writes data to a file.
 * @property {(from: string, to: string, options?: FsOptions) => Promise<void>} mv - Moves or renames a file or directory.
 * @property {(path: string, options?: FsOptions) => Promise<void>} rm - Removes a file or directory.
 * @property {(from: string, to: string, options?: FsOptions) => Promise<void>} cp - Copies a file or directory.
 */

const logger = createLogger('[FS]');

/**
 * The root directory for all user files on the server.
 * @internal
 * @type {string}
 */
const USER_FILES_ROOT = resolve(process.cwd(), '.webs/files');

/**
 * Creates a sandboxed file system API for a specific user.
 * All paths are resolved relative to the user's dedicated directory to prevent path traversal attacks.
 * @param {string | number} userId - The unique identifier for the user.
 * @returns {ServerFsApi} An object with secure methods for file system manipulation.
 */
export function createFileSystemForUser(userId) {
  if (!userId) throw new Error('A valid userId is required.');
  const userRootPath = join(USER_FILES_ROOT, String(userId));
  const publicPath = join(userRootPath, 'public');
  const privatePath = join(userRootPath, 'private');

  /**
   * @internal
   * Resolves a user-provided path to an absolute path within the user's sandboxed directory.
   * @param {string} [userPath='.'] - The path provided by the user.
   * @param {FileAccessLevel} [access='public'] - The access level.
   * @returns {string} The secure, absolute path.
   * @throws {Error} If the path attempts to traverse outside the user's directory.
   */
  const secureResolvePath = (userPath = '.', access = 'public') => {
    const basePath = access === 'private' ? privatePath : publicPath;
    const absolutePath = resolve(basePath, userPath);
    if (!absolutePath.startsWith(basePath)) {
      throw new Error('Permission denied: Path traversal attempt detected.');
    }
    return absolutePath;
  };

  /**
   * @internal
   * Ensures the parent directory of a given file path exists.
   * @param {string} filePath - The full path to the file.
   * @returns {Promise<void>}
   */
  const ensureDirectoryExists = async (filePath) => {
    const dir = dirname(filePath);
    try {
      await fsStat(dir);
    } catch (e) {
      const nodeError = /** @type {NodeJS.ErrnoException} */ (e);
      if (nodeError.code === 'ENOENT') {
        await fsMkdir(dir, { recursive: true });
      } else {
        throw e;
      }
    }
  };

  return {
    getPrivateRootPath: () => privatePath,

    exists: async (path, { access = 'public' } = {}) => {
      try {
        await fsStat(secureResolvePath(path, access));
        return true;
      } catch (error) {
        const nodeError = /** @type {NodeJS.ErrnoException} */ (error);
        if (nodeError.code === 'ENOENT') {
          return false;
        }
        throw error;
      }
    },
    stat: async (path, { access = 'public' } = {}) => {
      const stats = await fsStat(secureResolvePath(path, access));
      return {
        isFile: stats.isFile(),
        isDirectory: stats.isDirectory(),
        size: stats.size,
        mtime: stats.mtime,
        birthtime: stats.birthtime,
      };
    },
    cat: async (path, { access = 'public' } = {}) => {
      const resolvedPath = secureResolvePath(path, access);
      const file = bunFile(resolvedPath);
      if (!(await file.exists())) throw new Error(`File not found at: ${path}`);
      return file;
    },
    ls: async (path = '.', { access = 'public' } = {}) => {
      const resolvedPath = secureResolvePath(path, access);
      logger.debug(`[FS] Listing directory: "${resolvedPath}"`);
      try {
        const stats = await fsStat(resolvedPath);
        if (!stats.isDirectory()) {
          logger.warn(`[FS] Path "${resolvedPath}" is not a directory.`);
          return [];
        }

        const entries = await readdir(resolvedPath, { withFileTypes: true });
        return entries
          .map((entry) => ({
            name: entry.name,
            isDirectory: entry.isDirectory(),
            path: join(path, entry.name).replace(/\\/g, '/'),
          }))
          .sort((a, b) => a.name.localeCompare(b.name));
      } catch (error) {
        const nodeError = /** @type {NodeJS.ErrnoException} */ (error);
        if (nodeError.code === 'ENOENT') {
          return [];
        }
        logger.error(
          `[FS] Error in ls for path "${resolvedPath}" (code: ${nodeError.code}):`,
          error,
        );
        throw error;
      }
    },
    mkdir: async (path, { access = 'public' } = {}) => {
      const p = secureResolvePath(path, access);
      return fsMkdir(p, { recursive: true });
    },

    write: async (path, data, { access = 'public' } = {}) => {
      const resolvedPath = secureResolvePath(path, access);
      await ensureDirectoryExists(resolvedPath);

      if (data instanceof ReadableStream) {
        const writer = bunFile(resolvedPath).writer();
        const reader = data.getReader();
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            writer.end();
            break;
          }
          writer.write(value);
        }
        await writer.flush();
      } else {
        return write(
          resolvedPath,
          /** @type {Blob | Buffer | string | ArrayBuffer} */ (data),
        );
      }
    },

    mv: async (from, to, { access = 'public' } = {}) => {
      const fromPath = secureResolvePath(from, access);
      const toPath = secureResolvePath(to, access);
      await ensureDirectoryExists(toPath);
      return rename(fromPath, toPath);
    },
    rm: async (path, { access = 'public' } = {}) => {
      const p = secureResolvePath(path, access);
      return fsRm(p, { recursive: true, force: true });
    },
    cp: async (from, to, { access = 'public' } = {}) => {
      const fromPath = secureResolvePath(from, access);
      const toPath = secureResolvePath(to, access);
      await ensureDirectoryExists(toPath);
      const stats = await fsStat(fromPath);
      return copy(fromPath, toPath, { recursive: stats.isDirectory() });
    },
  };
}

---------- END: server/fs.server.js ----------

---------- START: server/profiler.js ----------
#!/usr/bin/env bun

import { relative, join, resolve, basename } from 'node:path';
import { readdir, stat, writeFile } from 'node:fs/promises';
import { Glob } from 'bun';
import * as readline from 'node:readline';
import { $ } from 'bun';

/**
 * @file Contains type definitions for the profiler and analysis tools.
 */

/**
 * Represents a node in the project's file structure tree.
 * @typedef {object} FileTreeNode
 * @property {string} name - The name of the file or directory.
 * @property {string} path - The absolute path to the file or directory.
 * @property {FileTreeNode[]} [children] - An array of child nodes if it's a directory.
 */

/**
 * The result object from running the test suite.
 * @typedef {object} TestAnalysis
 * @property {number} exitCode - The exit code of the test process.
 * @property {number} passed - The number of passed tests.
 * @property {number} failed - The number of failed tests.
 * @property {string} output - The standard output from the test runner.
 * @property {string} errorOutput - The standard error output from the test runner.
 */

/**
 * The result object from running the TypeScript compiler for type analysis.
 * @typedef {object} TypeAnalysis
 * @property {number} totalFilesWithErrors - The number of files containing type errors.
 * @property {number} totalErrors - The total number of type errors found.
 * @property {Record<string, string[]>} errorsByFile - An object mapping file paths to an array of error messages.
 * @property {number} exitCode - The exit code of the TypeScript compiler process.
 */

const colors = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
};

/**
 * @param {keyof typeof colors} color
 * @param {string | number} text
 * @returns {string}
 */
const c = (color, text) => `${colors[color]}${text}${colors.reset}`;
/** @param {string} str */
const stripAnsi = (str) => str.replace(/\x1b\[[0-9;]*m/g, '');

const log = {
  /** @param {string} label */
  cardLine: (label, value = '') => {
    console.log(`${label}  ${c('bold', String(value))}`);
  },
  /** @param {string} message */
  error: (message) => {
    const formatted = ` ${c('bold', c('red', '✖'))} ${c('red', message)} `;
    console.log(formatted);
  },
};

/**
 * Builds a file tree from the source for project structure display.
 * @param {string} dirPath
 * @returns {Promise<FileTreeNode | null>}
 */
async function buildProjectTree(dirPath) {
  try {
    const stats = await stat(dirPath);
    const name = dirPath.split('/').pop() || '';
    /** @type {FileTreeNode} */
    const node = { name, path: dirPath, children: [] };
    if (!stats.isDirectory()) {
      delete node.children;
      return node;
    }
    const dirents = await readdir(dirPath, { withFileTypes: true });
    for (const dirent of dirents) {
      const childPath = join(dirPath, dirent.name);
      const childNode = await buildProjectTree(childPath);
      if (childNode) node.children?.push(childNode);
    }
    node.children?.sort((a, b) => {
      if (a.children && !b.children) return -1;
      if (!a.children && b.children) return 1;
      return a.name.localeCompare(b.name);
    });
    return node;
  } catch {
    return null;
  }
}

/**
 * @param {FileTreeNode} node
 * @param {string} [prefix]
 * @param {boolean} [isLast]
 * @returns {string[]}
 */
function collectTreeStringLines(node, prefix = '', isLast = true) {
  const lines = [];
  const connector = isLast ? '└─' : '├─';
  const linePrefix = `${prefix}${connector} `;
  lines.push(`${linePrefix}${node.name}`);
  if (node.children) {
    const newPrefix = prefix + (isLast ? '   ' : '│  ');
    for (const [index, child] of node.children.entries()) {
      lines.push(
        ...collectTreeStringLines(
          child,
          newPrefix,
          index === node.children.length - 1,
        ),
      );
    }
  }
  return lines;
}

/**
 * Generates a plain text report of the project structure.
 * @param {FileTreeNode | null} tree
 * @returns {string}
 */
function generateTreeReport(tree) {
  if (!tree || !tree.children || !tree.children.length) {
    return 'Project Structure: No files found.\n';
  }
  let report = 'Project Structure:\n';
  const header = ` ./${tree.name}`;
  const lines = [];
  for (const [index, child] of tree.children.entries()) {
    lines.push(
      ...collectTreeStringLines(child, '', index === tree.children.length - 1),
    );
  }
  report += [header, ...lines].join('\n');
  report += '\n';
  return report;
}

/**
 * @param {string} targetDir
 * @returns {Promise<TestAnalysis>}
 */
async function runTests(targetDir) {
  const proc = Bun.spawn(['bun', 'test', targetDir], {
    stderr: 'pipe',
    stdout: 'pipe',
  });
  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;

  const cleanOutput = stripAnsi(stdout);
  let passed = 0;
  let failed = 0;

  const passMatches = cleanOutput.match(/(\d+)\s+pass/g);
  const failMatches = cleanOutput.match(/(\d+)\s+fail/g);

  if (passMatches) {
    const lastPass = passMatches[passMatches.length - 1];
    const passCountStr = lastPass?.split(' ')[0];
    if (passCountStr) passed = parseInt(passCountStr, 10);
  }

  if (failMatches) {
    const lastFail = failMatches[failMatches.length - 1];
    const failCountStr = lastFail?.split(' ')[0];
    if (failCountStr) failed = parseInt(failCountStr, 10);
  }

  return { exitCode, passed, failed, output: stdout, errorOutput: stderr };
}

/**
 * @param {string} targetDir
 * @returns {Promise<TypeAnalysis>}
 */
async function checkTypes(targetDir) {
  const proc = Bun.spawn(['bun', 'tsc', '--noEmit', '--pretty', 'false'], {
    cwd: targetDir === 'lib' ? process.cwd() : targetDir,
    stderr: 'pipe',
    stdout: 'pipe',
  });
  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;
  if (stderr && !stdout.trim()) {
    log.error('Error executing the TypeScript compiler:');
    console.error(stderr);
    process.exit(1);
  }

  /** @type {Record<string, string[]>} */
  const errorsByFile = {};
  const errorRegex = /^(.*?)\((\d+),(\d+)\):\s+error\s+TS\d+:\s+(.*)$/gm;
  let match;
  while ((match = errorRegex.exec(stdout)) !== null) {
    const [, filePath, line, column, message] = match;
    if (filePath) {
      const relativePath = relative(process.cwd(), join(targetDir, filePath));
      if (!errorsByFile[relativePath]) errorsByFile[relativePath] = [];
      errorsByFile[relativePath]?.push(
        `L${line}:C${column} - ${(message || '').trim()}`,
      );
    }
  }

  const totalErrors = Object.values(errorsByFile).flat().length;
  const totalFilesWithErrors = Object.keys(errorsByFile).length;

  return { totalFilesWithErrors, totalErrors, errorsByFile, exitCode };
}

/**
 * @param {string} targetDir
 * @param {string[]} [additionalFiles]
 * @param {string[]} [excludedPatterns]
 * @returns {Promise<Record<string, string>>}
 */
async function getInlineSource(
  targetDir,
  additionalFiles = [],
  excludedPatterns = [],
) {
  const inputPath = resolve(process.cwd(), targetDir);
  const glob = new Glob('**/*');
  /** @type {Record<string, string>} */
  const sourceData = {};

  const defaultExcludes = [
    'node_modules/**',
    '.git/**',
    '.webs/**',
    'dist/**',
    'webs.lock.txt',
  ];
  const allExcludedPatterns = [...defaultExcludes, ...excludedPatterns];

  const scannedFiles = await Array.fromAsync(
    glob.scan({ cwd: inputPath, absolute: true, dot: true, onlyFiles: true }),
  );

  const excludeGlobs = allExcludedPatterns.map((pattern) => new Glob(pattern));

  const filteredFiles = scannedFiles.filter((filePath) => {
    const relativePath = relative(inputPath, filePath);
    for (const glob of excludeGlobs) {
      if (glob.match(relativePath)) {
        return false;
      }
    }
    return true;
  });

  for (const filePath of filteredFiles) {
    const relativePath = relative(inputPath, filePath);
    const file = Bun.file(filePath);
    if (file.size > 0 && file.size < 1_000_000) {
      try {
        sourceData[relativePath] = await file.text();
      } catch {}
    }
  }

  for (const filePath of additionalFiles) {
    const absolutePath = resolve(process.cwd(), filePath);
    try {
      const file = Bun.file(absolutePath);
      if ((await file.exists()) && file.size > 0) {
        const displayPath = relative(process.cwd(), absolutePath);
        sourceData[displayPath] = await file.text();
      } else {
        console.log(
          c('yellow', `  - Skipping: ${filePath} (not found or empty)`),
        );
      }
    } catch (e) {
      const message = e instanceof Error ? e.message : String(e);
      log.error(`Error reading file ${filePath}: ${message}`);
    }
  }

  return sourceData;
}

/**
 * @param {TestAnalysis} analysis
 * @returns {string}
 */
function generateTestReport(analysis) {
  let report = 'Test Runner:\n';
  const { exitCode, passed, failed, output, errorOutput } = analysis;

  if (exitCode === 0 && failed === 0) {
    report += 'Status: OK\n';
  } else {
    report += `Status: ${failed > 0 ? 'Failed' : 'Error'}\n`;
  }
  report += `Summary: ${passed} test(s) passed, ${failed} test(s) failed.\n`;
  if (output) report += `\n--- TEST OUTPUT ---\n${output}\n`;
  if (errorOutput) {
    report += `\n--- STDERR ---\n${errorOutput}\n`;
  }
  return report;
}

/**
 * @param {TypeAnalysis} analysis
 * @returns {string}
 */
function generateTypeAnalysisReport(analysis) {
  const { exitCode, totalErrors, totalFilesWithErrors } = analysis;
  let report = 'Type Analysis:\n';
  if (exitCode === 0) {
    report += 'Status: OK\n';
    report += 'Total Errors: 0\n';
    return report;
  }

  report += `Status: ${totalErrors} error(s) found in ${totalFilesWithErrors} file(s)\n`;
  return report;
}

/**
 * @template T
 * @param {string} title
 * @param {() => Promise<T>} task
 * @returns {Promise<{result: T, duration: string}>}
 */
async function runTaskWithLoader(title, task) {
  let lastLineLength = 0;
  const startTime = performance.now();
  console.log('');

  const spinnerFrames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
  let frameIndex = 0;

  const interval = setInterval(() => {
    const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
    const timer = c('dim', `(${elapsed}s)`);
    const frame = spinnerFrames[frameIndex];
    if (frame) {
      const spinner = c('magenta', frame);
      const line = `\r ${spinner} ${title} ${timer}`;
      process.stdout.write(line.padEnd(lastLineLength));
      lastLineLength = stripAnsi(line).length;
    }
    frameIndex = (frameIndex + 1) % spinnerFrames.length;
  }, 80);

  try {
    const result = await task();
    clearInterval(interval);
    const duration = ((performance.now() - startTime) / 1000).toFixed(2);
    const timer = c('dim', `(${duration}s)`);
    const successLine = `\r${c('green', '✓')} ${title} ${timer}\n`;
    process.stdout.write(successLine.padEnd(lastLineLength + 1));
    return { result, duration };
  } catch (e) {
    clearInterval(interval);
    const duration = ((performance.now() - startTime) / 1000).toFixed(2);
    const timer = c('dim', `(${duration}s)`);
    const failLine = `\r${c('red', '✖')} ${title} ${timer}\n`;
    process.stdout.write(failLine.padEnd(lastLineLength + 1));
    throw e;
  }
}

/**
 * Generates a lockfile containing the project structure and source code.
 * This provides a snapshot of the directory's contents.
 * @param {string} targetDir The directory to create the lockfile for.
 * @param {string[]} [additionalFilesToInclude=[]] An array of specific file paths to include, even if outside the target directory.
 * @param {string[]} [patternsToExclude=[]] An array of glob patterns to exclude from the source file collection.
 */
export async function createLockfile(
  targetDir,
  additionalFilesToInclude = [],
  patternsToExclude = [],
) {
  console.log(
    c('bold', `\nGenerating lockfile for directory: '${targetDir}'...`),
  );

  if (additionalFilesToInclude.length > 0) {
    console.log(
      c(
        'dim',
        `Including additional files: ${additionalFilesToInclude.join(', ')}`,
      ),
    );
  }
  if (patternsToExclude.length > 0) {
    console.log(
      c('dim', `Excluding patterns: ${patternsToExclude.join(', ')}`),
    );
  }

  const parts = [];

  const { result: tree } = await runTaskWithLoader(
    'Building project tree',
    () => buildProjectTree(targetDir),
  );
  const treeReport = generateTreeReport(tree);
  let treeContent = '========== PROJECT STRUCTURE ==========\n';
  treeContent += stripAnsi(treeReport).replace('Project Structure:\n', '');
  parts.push(treeContent);

  const { result: sourceFiles } = await runTaskWithLoader(
    'Collecting source files',
    () =>
      getInlineSource(targetDir, additionalFilesToInclude, patternsToExclude),
  );
  let filesContent = '========== SOURCE FILES ==========\n';
  const sortedFilePaths = Object.keys(sourceFiles).sort();

  for (const path of sortedFilePaths) {
    const sourceContent = sourceFiles[path];
    filesContent += `\n---------- START: ${path} ----------\n`;
    filesContent += sourceContent;
    filesContent += `\n---------- END: ${path} ----------\n`;
  }
  parts.push(filesContent);

  const lockfileContent = parts.join('\n');
  const outputPath = resolve(targetDir, 'webs.lock.txt');
  await writeFile(outputPath, lockfileContent);

  console.log(
    c('green', `\n✓ Lockfile created successfully at: ${outputPath}`),
  );
}

/**
 * @param {string} targetDir
 */
export async function runAnalysis(targetDir) {
  const { result: testAnalysis } = await runTaskWithLoader(
    'Running Tests',
    () => runTests(targetDir),
  );
  const { result: typeAnalysis } = await runTaskWithLoader(
    'Checking Types',
    () => checkTypes(targetDir),
  );

  console.log('\n--- Analysis Complete ---\n');
  console.log(c('bold', 'Type Analysis:'));
  console.log(
    generateTypeAnalysisReport(typeAnalysis).split('\n').slice(1).join('\n'),
  );
  console.log(c('bold', '\nTest Analysis:'));
  console.log(generateTestReport(testAnalysis).split('\n').slice(1).join('\n'));
}

/**
 * @param {object} inspectionData
 * @param {Record<string, import('./router.js').RouteDefinition>} inspectionData.appRoutes
 * @param {Record<string, import('./ai.server.js').AgentDefinition>} inspectionData.agentRoutes
 * @param {string[]} inspectionData.sourceEntrypoints
 * @param {import('./server-config.js').Config} inspectionData.config
 * @param {Record<string, string>} inspectionData.sourceToComponentMap
 */
export async function generateInspectionReport({
  appRoutes,
  agentRoutes,
  sourceEntrypoints,
  config,
  sourceToComponentMap,
}) {
  console.log(
    c(
      'bold',
      `\nInspecting Webs project at '${relative(process.cwd(), config.CWD)}'`,
    ),
  );

  console.log(c('bold', '\nPages & API Routes'));
  console.log(c('dim', '──────────────────'));

  const sortedRoutes = Object.entries(appRoutes).sort(([pathA], [pathB]) =>
    pathA.localeCompare(pathB),
  );

  for (const [path, def] of sortedRoutes) {
    const methods = ['GET', ...Object.keys(def.handlers)].map((m) =>
      m.toUpperCase(),
    );
    if (Object.keys(def.wsHandlers).length > 0) {
      methods.push('WSS');
    }
    const methodStr = methods.map((m) => c('cyan', `[${m}]`)).join(' ');

    const componentName = def.componentName;
    const sourcePath = Object.entries(sourceToComponentMap).find(
      ([, name]) =>
        name === componentName ||
        `layout/${name.replace(/\//g, '_')}` === componentName,
    )?.[0];

    console.log(` ${methodStr} ${path}`);
    if (sourcePath) {
      console.log(c('dim', `        └─ component: ${sourcePath}`));
    }
  }

  console.log(c('bold', '\nRegistered Components'));
  console.log(c('dim', '───────────────────'));
  const guiComponents = [];
  const appComponents = [];

  for (const fullPath of sourceEntrypoints) {
    const relPath = relative(config.SRC_DIR, fullPath);
    if (relPath.endsWith('.agent.webs') || basename(relPath) === 'layout.webs')
      continue;

    if (relPath.startsWith('gui/')) {
      guiComponents.push({
        name: basename(relPath, '.webs'),
        path: `src/${relPath}`,
      });
    } else if (relPath.startsWith('app/')) {
      appComponents.push({
        name: relPath.replace('.webs', '').replace('app/', ''),
        path: `src/${relPath}`,
      });
    }
  }

  guiComponents.sort((a, b) => a.name.localeCompare(b.name));
  appComponents.sort((a, b) => a.name.localeCompare(b.name));

  for (const { name, path } of guiComponents) {
    console.log(` • ${name} ${c('dim', `(from: ${path})`)}`);
  }
  for (const { name, path } of appComponents) {
    console.log(` • ${name} ${c('dim', `(from: ${path})`)}`);
  }

  if (Object.keys(agentRoutes).length > 0) {
    console.log(c('bold', '\nAI Agents'));
    console.log(c('dim', '─────────'));
    for (const [name, def] of Object.entries(agentRoutes)) {
      console.log(` • ${name.replace('app/', '')}`);
      if (def.model) {
        console.log(c('dim', `   └─ model: ${def.model}`));
      }
      if (def.tools && def.tools.length > 0) {
        const toolNames = def.tools.map((t) => t.function.name).join(', ');
        console.log(c('dim', `   └─ tools: [${toolNames}]`));
      }
    }
  }
  console.log('');
}

/**
 * @param {string} pattern
 * @param {string} path
 * @param {string | undefined} filePattern
 */
export async function runGrep(pattern, path, filePattern) {
  const args = ['-r', '-n', '-I', '--color=always', pattern, path];
  if (filePattern) {
    args.splice(4, 0, `--include=${filePattern}`);
  }

  const proc = Bun.spawn(['grep', ...args], {
    stdout: 'pipe',
    stderr: 'pipe',
  });

  const reader = proc.stdout.getReader();
  const decoder = new TextDecoder();

  const highlight = (/** @type {string} */ line) => {
    return line.replace(
      new RegExp(pattern, 'g'),
      (/** @type {string} */ match) => c('red', c('bold', match)),
    );
  };

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value);
    const lines = chunk.split('\n');
    for (const line of lines) {
      if (!line) continue;
      const [filePath, lineNum, ...rest] = line.split(':');
      const content = rest.join(':');
      if (filePath && lineNum) {
        process.stdout.write(
          `${c('yellow', filePath)}:${c('cyan', lineNum)}: ${highlight(
            content,
          )}\n`,
        );
      }
    }
  }

  const stderr = await new Response(proc.stderr).text();
  if (stderr) {
    console.error(c('red', `grep error:\n${stderr}`));
  }
}

/**
 * @param {number} port
 * @param {string} targetDir
 */
export async function startInteractiveShell(port, targetDir) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: c('cyan', 'webs> '),
  });

  console.log(c('bold', `\nConnected to dev server on port ${port}.`));
  console.log(c('dim', "Type 'help' for a list of commands.\n"));

  /**
   * @param {string} output
   */
  const printResponse = (output) => {
    const [headerPart, ...bodyParts] = output.split('\r\n\r\n');
    const body = bodyParts.join('\r\n\r\n');
    const headers = headerPart?.split('\r\n') || [];
    const statusLine = headers.shift();

    if (statusLine) {
      const statusMatch = statusLine.match(/HTTP\/\d\.\d (\d+) (.*)/);
      if (statusMatch) {
        const code = parseInt(statusMatch[1] || '0', 10);
        const statusText = statusMatch[2];
        const color =
          code >= 200 && code < 300 ? 'green' : code >= 400 ? 'red' : 'yellow';
        console.log(c('bold', `Status: ${c(color, `${code} ${statusText}`)}`));
      }
    }

    console.log(c('bold', 'Headers:'));
    console.log(c('dim', headers.join('\n')));

    console.log(c('bold', '\nBody:'));
    try {
      console.log(JSON.stringify(JSON.parse(body), null, 2));
    } catch {
      console.log(body);
    }
  };

  /** @type {{ [key: string]: (args: string[]) => void | Promise<void> }} */
  const commands = {
    help() {
      console.log('\nAvailable commands:');
      console.log(
        `  ${c(
          'bold',
          'GET|POST|PUT|PATCH|DELETE <path> [body]',
        )} - Make an HTTP request.`,
      );
      console.log(
        `  ${c(
          'bold',
          'grep <pattern> [path] [--include <glob>]',
        )}   - Search for a pattern in files.`,
      );
      console.log(
        `  ${c(
          'bold',
          'test [path]',
        )}                               - Run tests for the project.`,
      );
      console.log(
        `  ${c('bold', 'exit | quit')}                                - Exit the shell.\n`,
      );
    },
    exit() {
      rl.close();
    },
    quit() {
      rl.close();
    },
    /** @param {string[]} args */
    async test(args) {
      const testPath = args[0] || targetDir;
      console.log(`Running tests for '${testPath}'...`);
      const { output, errorOutput } = await runTests(testPath);
      console.log(output);
      if (errorOutput) console.error(errorOutput);
    },
    /** @param {string[]} args */
    async grep(args) {
      const pattern = args[0];
      const path = args[1] || targetDir;
      const includeIndex = args.indexOf('--include');
      const filePattern =
        includeIndex !== -1 ? args[includeIndex + 1] : undefined;
      if (!pattern) {
        log.error('Usage: grep <pattern> [path] [--include <glob>]');
        return;
      }
      await runGrep(pattern, path, filePattern);
    },
  };

  /**
   * @param {string} method
   */
  const createRequestHandler =
    (method) => async (/** @type {string[]} */ args) => {
      const path = args[0];
      if (!path) {
        log.error(`Usage: ${method} <path> [body]`);
        return;
      }
      const body = args.slice(1).join(' ');
      const headers =
        method !== 'GET' ? `-H "Content-Type: application/json"` : '';
      const data = body ? `-d '${$.escape(body)}'` : '';
      const command = `curl -s -i -X ${method} http://localhost:${port}${path} ${headers} ${data}`;
      const { stdout, stderr, exitCode } = await $`${{
        raw: command,
      }}`.nothrow();

      if (exitCode !== 0) {
        log.error(`Request failed with exit code ${exitCode}`);
        console.error(stderr.toString());
      } else {
        printResponse(stdout.toString());
      }
    };

  commands.get = createRequestHandler('GET');
  commands.post = createRequestHandler('POST');
  commands.put = createRequestHandler('PUT');
  commands.patch = createRequestHandler('PATCH');
  commands.delete = createRequestHandler('DELETE');

  rl.on('line', async (line) => {
    const [command, ...args] = line.trim().split(/\s+/);
    const cmdFunc = command ? commands[command.toLowerCase()] : null;

    if (cmdFunc) {
      await cmdFunc(args);
    } else if (command) {
      log.error(`Unknown command: '${command}'. Type 'help' for commands.`);
    }
    rl.prompt();
  }).on('close', () => {
    console.log(c('bold', '\nExiting shell.'));
    process.exit(0);
  });

  rl.prompt();
}

---------- END: server/profiler.js ----------

---------- START: server/router.js ----------
import { getUserFromSession, createSession } from './authentication.js';
import { createFileSystemForUser } from './fs.server.js';
import { renderToString } from '../engine/ssr.js';
import { handleApiRequest } from './api.js';
import { stat, exists } from 'fs/promises';
import { basename, join } from 'path';
import { h } from '../engine/vdom.js';
import { createLogger } from '../shared/logger.js';

/**
 * @file This is the core request handler for the server. It's responsible for routing incoming
 * requests to the appropriate handler, whether it's serving a static file, executing an API
 * endpoint, handling a server-side action, or rendering a page component.
 */

/**
 * @typedef {import('bun:sqlite').Database} BunDatabase
 * @typedef {import('./ai.server.js').AI} AI
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('./ai.server.js').AgentDefinition} AgentDefinition
 */

/**
 * Defines the structure of the asset manifest generated by the build process.
 * This manifest tells the server where to find the bundled JavaScript, CSS, and service worker files.
 * @typedef {object} ServerManifest
 * @property {string | undefined} js - The path to the main client-side JavaScript bundle.
 * @property {string | undefined} css - The path to the main CSS bundle.
 * @property {string | undefined} sw - The path to the generated service worker file.
 */

/**
 * Represents the definition of a server-side route, which is generated from a page component file.
 * This object links a URL path to its rendering and data-handling logic.
 * @typedef {object} RouteDefinition
 * @property {any} component - The compiled component object to be rendered for this route.
 * @property {string} componentName - The unique, file-path-derived name of the component (e.g., 'app/posts/index').
 * @property {Record<string, Function>} actions - Server-side functions exported from the component that can be called from the client (e.g., `prefetch`, form actions).
 * @property {Record<string, Function>} handlers - HTTP method handlers (e.g., `post`, `patch`) for handling API-like requests directly on the component's route.
 * @property {Record<string, Function>} wsHandlers - WebSocket lifecycle handlers (`onOpen`, `onMessage`, etc.) for real-time communication on this route.
 * @property {any} [cc] - Compiled native C functions for this route.
 */

/**
 * A comprehensive context object containing all necessary server-side resources and configuration.
 * This object is assembled once at server startup and passed to the main fetch handler.
 * @typedef {object} ServerContext
 * @property {BunDatabase} db - The singleton database instance.
 * @property {AI} ai - The singleton AI service instance.
 * @property {any} dbConfig - The database schema configuration.
 * @property {ServerManifest} manifest - The asset manifest from the build process.
 * @property {Record<string, RouteDefinition>} appRoutes - A map of URL patterns to their corresponding `RouteDefinition`.
 * @property {Record<string, AgentDefinition>} agentRoutes - A map of AI agent names to their definitions.
 * @property {Config} config - The global server configuration object.
 * @property {boolean} isProd - A flag indicating if the server is running in production mode.
 * @property {string} SYNC_TOPIC - The name of the WebSocket topic for data synchronization.
 * @property {string} actionsPath - The path to the dynamically generated server actions file.
 * @property {any} globalComponents - A map of globally registered UI components.
 * @property {Record<string, string>} sourceToComponentMap - A development-only map from source file paths to their component names.
 * @property {Record<string, Function>} syncActions - A map of generated functions for handling database synchronization.
 * @property {string[]} sourceEntrypoints - A list of all discovered `.webs` source files.
 * @property {object | null} [frameworkNativeModules] - Compiled native modules for internal framework use.
 */

/**
 * @internal
 * The context required for handling a data-only request (client-side navigation).
 * @typedef {object} DataRequestContext
 * @property {ServerManifest} manifest - The asset manifest.
 * @property {Record<string, string>} sourceToComponentMap - A map from source file paths to component names.
 * @property {object | null} [frameworkNativeModules]
 */

/**
 * @internal
 * The context required for handling a full page request (SSR).
 * @typedef {object} PageRequestContext
 * @property {ServerManifest} manifest - The asset manifest.
 * @property {any} globalComponents - A map of globally registered UI components.
 * @property {Record<string, string>} sourceToComponentMap - A map from source file paths to component names.
 * @property {object | null} [frameworkNativeModules]
 */

/**
 * The context for the prefetch function.
 * @typedef {object} PrefetchContext
 * @property {BunDatabase} db
 * @property {any} user
 * @property {any} params
 * @property {import('./fs.server.js').ServerFsApi | null} fs
 * @property {object | null | undefined} frameworkNativeModules
 */

const logger = createLogger('[Router]');
/** @type {Map<string, { gzippedBuffer: Buffer, contentType: string }>} */
const gzipCache = new Map();

/**
 * @param {Request} req
 * @param {string} filePath
 */
async function serveStaticFile(req, filePath) {
  const acceptsGzip = req.headers.get('Accept-Encoding')?.includes('gzip');
  const file = Bun.file(filePath);

  if (acceptsGzip) {
    if (gzipCache.has(filePath)) {
      const cached = gzipCache.get(filePath);
      if (cached) {
        const { gzippedBuffer, contentType } = cached;
        logger.debug(`Serving gzipped file from cache: ${filePath}`);
        return new Response(
          /** @type {BodyInit} */ (/** @type {unknown} */ (gzippedBuffer)),
          {
            headers: {
              'Content-Encoding': 'gzip',
              'Content-Type': contentType,
            },
          },
        );
      }
    }

    logger.debug(`Gzipping and serving file: ${filePath}`);
    const buffer = await file.arrayBuffer();
    const gzippedBuffer = Bun.gzipSync(new Uint8Array(buffer));
    const contentType = file.type;

    gzipCache.set(filePath, {
      gzippedBuffer: /** @type {Buffer} */ (
        /** @type {unknown} */ (gzippedBuffer)
      ),
      contentType,
    });

    return new Response(
      /** @type {BodyInit} */ (/** @type {unknown} */ (gzippedBuffer)),
      {
        headers: {
          'Content-Encoding': 'gzip',
          'Content-Type': contentType,
        },
      },
    );
  }

  logger.debug(`Serving uncompressed file: ${filePath}`);
  return new Response(file);
}

/**
 * @param {{appHtml: string, websState: any, manifest: ServerManifest, title: string}} params
 */
function renderHtmlShell({ appHtml, websState, manifest, title }) {
  const cssPath = manifest.css ? `/${basename(manifest.css)}` : '';
  const jsPath = manifest.js ? `/${basename(manifest.js)}` : '';

  logger.debug('Rendering HTML shell for', title);
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${title}</title>
    ${cssPath ? `<link rel="stylesheet" href="${cssPath}">` : ''}
</head>
<body>
    <div id="root">${appHtml}</div>
    <script>window.__WEBS_STATE__ = ${JSON.stringify(websState)};</script>
    <script type="module" src="${jsPath}"></script>
</body>
</html>`;
}

/**
 * @param {RouteDefinition} routeDefinition
 * @param {PrefetchContext} context
 */
async function executePrefetch(routeDefinition, context) {
  logger.debug(
    `Executing prefetch for component '${routeDefinition.componentName}'...`,
  );
  if (!routeDefinition.actions?.prefetch) {
    logger.debug('No prefetch action found.');
    return {};
  }
  try {
    const fullContext = {
      ...context,
      cc: routeDefinition.cc,
      native: context.frameworkNativeModules,
    };
    const result = await routeDefinition.actions.prefetch(fullContext);
    logger.debug('Prefetch action completed successfully.');
    return result;
  } catch (err) {
    logger.error(`Prefetch Error for "${routeDefinition.componentName}":`, err);
    return { error: 'Failed to load data on the server.' };
  }
}

/**
 * @param {Request & {db: BunDatabase, user: any, params: any}} req
 * @param {RouteDefinition} routeDefinition
 * @param {DataRequestContext} context
 */
async function handleDataRequest(req, routeDefinition, context) {
  logger.info(`Handling data request for route '${req.url}'`);
  const { db, user, params } = req;
  const { manifest, sourceToComponentMap, frameworkNativeModules } = context;
  const fs = user ? createFileSystemForUser(user.id) : null;

  const componentState = await executePrefetch(routeDefinition, {
    db,
    user,
    params,
    fs,
    frameworkNativeModules,
  });

  const websState = {
    user,
    params,
    componentState,
    componentName: routeDefinition.componentName,
    title: routeDefinition.component.name || 'Webs App',
    swPath: manifest.sw ? `/${basename(manifest.sw)}` : null,
    sourceToComponentMap,
  };
  logger.debug('Sending JSON response for data request.');
  return new Response(JSON.stringify(websState), {
    headers: { 'Content-Type': 'application/json;charset=utf-8' },
  });
}

/**
 * @param {Request & {db: BunDatabase, user: any, params: any}} req
 * @param {RouteDefinition} routeDefinition
 * @param {PageRequestContext} context
 */
async function handlePageRequest(req, routeDefinition, context) {
  logger.info(`Handling page request for route '${req.url}'`);
  const {
    manifest,
    globalComponents,
    sourceToComponentMap,
    frameworkNativeModules,
  } = context;
  const { db, user, params } = req;
  const fs = user ? createFileSystemForUser(user.id) : null;

  const initialState = await executePrefetch(routeDefinition, {
    db,
    user,
    params,
    fs,
    frameworkNativeModules,
  });

  const { pathname } = new URL(req.url);
  const props = {
    user,
    params,
    initialState,
    path: pathname,
    cc: routeDefinition.cc,
  };

  const vnode = h(routeDefinition.component, props);
  vnode.appContext = {
    components: globalComponents || {},
    provides: {},
    patch: () => {},
    hydrate: () => null,
    params: params || {},
  };

  logger.debug('Starting SSR...');
  const { html: appHtml, componentState } = await renderToString(vnode);
  logger.debug('SSR complete.');

  const websState = {
    user,
    params,
    componentState: componentState || initialState,
    componentName: routeDefinition.componentName,
    swPath: manifest.sw ? `/${basename(manifest.sw)}` : null,
    sourceToComponentMap,
  };

  const fullHtml = renderHtmlShell({
    appHtml,
    websState,
    manifest,
    title: routeDefinition.component.name || 'Webs App',
  });
  logger.debug('Sending full HTML page response.');
  return new Response(fullHtml, {
    headers: { 'Content-Type': 'text/html;charset=utf-8' },
  });
}

/**
 * @param {BunDatabase} db
 * @param {boolean} isProd
 */
const authMiddleware =
  (db, isProd) =>
  (/** @type {Request & {db?: BunDatabase, user?: any}} */ req) => {
    req.db = db;
    const cookie = req.headers.get('cookie');
    const sessionId = cookie?.match(/session_id=([^;]+)/)?.[1];
    let user = sessionId ? getUserFromSession(db, sessionId) : null;

    if (!isProd && !user) {
      const anonUser = db
        .query('SELECT id, username, email FROM users WHERE username = ?')
        .get('anon');
      if (anonUser) {
        const newSessionId = createSession(
          db,
          /** @type {{id: number}} */ (anonUser).id,
        );
        user = anonUser;
        req.headers.set('X-Set-Dev-Session', newSessionId);
      }
    }
    req.user = user;
  };

/**
 * @param {ServerContext} context
 */
export function createFetchHandler(context) {
  const {
    db,
    manifest,
    appRoutes,
    globalComponents,
    config,
    isProd,
    sourceToComponentMap,
    frameworkNativeModules,
  } = context;
  const { OUTDIR, SRC_DIR } = config;

  const attachContext = authMiddleware(db, isProd);
  const sortedAppRoutePaths = Object.keys(appRoutes || {});

  /**
   * @param {Request} req
   * @param {import('bun').Server} server
   */
  return async function fetch(req, server) {
    const url = new URL(req.url);
    const { pathname } = url;
    logger.info(`Received request for: ${pathname}`);

    if (pathname.includes('..')) {
      logger.warn('Path traversal attempt detected.');
      return new Response('Forbidden', { status: 403 });
    }

    const potentialFilePath = join(OUTDIR, pathname.substring(1));
    if (
      (await exists(potentialFilePath)) &&
      (await stat(potentialFilePath)).isFile()
    ) {
      return serveStaticFile(req, potentialFilePath);
    }

    if (!isProd) {
      const potentialSrcPath = join(SRC_DIR, pathname.substring(1));
      if (
        (await exists(potentialSrcPath)) &&
        (await stat(potentialSrcPath)).isFile()
      ) {
        return serveStaticFile(req, potentialSrcPath);
      }
    }
    const extendedReq =
      /** @type {Request & { db: any, user: any, params: any }} */ (req);
    attachContext(extendedReq);

    if (pathname.startsWith('/api/')) {
      const apiResponse = await handleApiRequest(extendedReq, server, context);
      if (apiResponse) return apiResponse;
    }

    if (req.headers.get('upgrade') === 'websocket') {
      if (pathname === '/api/sync') {
        if (extendedReq.user) {
          return server.upgrade(req, {
            data: { isSyncChannel: true, user: extendedReq.user },
          })
            ? undefined
            : new Response('Unauthorized', { status: 401 });
        }
      }
    }

    const actionMatch = pathname.match(/^\/__actions__\/(.+?)\/(.+?)$/);
    if (actionMatch) {
      if (!extendedReq.user)
        return new Response('Unauthorized', { status: 401 });
      const [, componentName, actionName] = actionMatch;
      if (!componentName || !actionName) {
        return new Response('Action not found', { status: 404 });
      }
      const routeDef = Object.values(appRoutes).find(
        (r) =>
          (r.componentName === componentName ||
            r.component.name === componentName) &&
          r.actions &&
          actionName in r.actions,
      );
      const action = routeDef?.actions?.[actionName];

      if (typeof action !== 'function')
        return new Response('Action not found', { status: 404 });

      try {
        const args = await req.json();
        const result = await action(
          {
            req,
            db,
            fs: createFileSystemForUser(extendedReq.user.id),
            user: extendedReq.user,
            cc: routeDef?.cc,
            native: frameworkNativeModules,
          },
          ...args,
        );
        return result instanceof Response ? result : Response.json(result);
      } catch (e) {
        logger.error('Error executing action:', e);
        return new Response('Internal Server Error', { status: 500 });
      }
    }

    for (const path of sortedAppRoutePaths) {
      const routeDefinition = appRoutes[path];
      /** @type {string[]} */
      const paramNames = [];
      let pathRegexStr = path.replace(/:(\w+)(\*)?/g, (_, name, isCatchAll) => {
        paramNames.push(name);
        return isCatchAll ? '(.*)' : '([^/]+)';
      });

      if (path.endsWith('*')) {
        const lastSlashIndex = pathRegexStr.lastIndexOf('/');
        if (lastSlashIndex !== -1) {
          pathRegexStr =
            pathRegexStr.substring(0, lastSlashIndex) +
            '(?:\\' +
            pathRegexStr.substring(lastSlashIndex) +
            ')?';
        }
      }

      const regex = new RegExp(`^${pathRegexStr}$`);
      const match = pathname.match(regex);

      if (match && routeDefinition) {
        logger.info(`Matched request to route: '${path}'`);
        extendedReq.params = paramNames.reduce((acc, name, i) => {
          let value = match[i + 1] || '';
          if (value === undefined && path.endsWith('*')) {
            value = '';
          }
          if (
            path.endsWith('*') &&
            name === paramNames[paramNames.length - 1]
          ) {
            value = value.startsWith('/') ? value.substring(1) : value;
          }
          /** @type {any} */ (acc)[name] = value;
          return acc;
        }, {});

        if (req.headers.get('upgrade') === 'websocket') {
          if (
            routeDefinition.wsHandlers &&
            Object.keys(routeDefinition.wsHandlers).length > 0
          ) {
            logger.info(`Upgrading to WebSocket for route: ${path}`);
            const success = server.upgrade(req, {
              data: {
                user: extendedReq.user,
                params: extendedReq.params,
                wsHandlers: routeDefinition.wsHandlers,
              },
            });
            return success
              ? undefined
              : new Response('WebSocket upgrade failed', { status: 500 });
          }
        }

        const requestMethod = req.method.toLowerCase();
        if (requestMethod !== 'get') {
          if (!extendedReq.user) {
            return new Response('Unauthorized', { status: 401 });
          }

          const handler = routeDefinition.handlers?.[requestMethod];

          if (handler && typeof handler === 'function') {
            try {
              const result = await handler({
                req: extendedReq,
                db,
                user: extendedReq.user,
                params: extendedReq.params,
                fs: createFileSystemForUser(extendedReq.user.id),
                cc: routeDefinition.cc,
                native: frameworkNativeModules,
              });

              if (result instanceof Response) {
                return result;
              }
              if (result !== undefined) {
                return Response.json(result);
              }
              return new Response(null, { status: 204 });
            } catch (e) {
              const error = /** @type {Error} */ (e);
              logger.error(
                `Error executing '${requestMethod}' handler for route '${path}':`,
                error,
              );
              return new Response(error.message || 'Internal Server Error', {
                status: 500,
              });
            }
          } else {
            return new Response('Method Not Allowed', { status: 405 });
          }
        }

        const response = req.headers.get('X-Webs-Navigate')
          ? await handleDataRequest(extendedReq, routeDefinition, {
              manifest,
              sourceToComponentMap,
              frameworkNativeModules,
            })
          : await handlePageRequest(extendedReq, routeDefinition, {
              manifest,
              globalComponents,
              sourceToComponentMap,
              frameworkNativeModules,
            });

        const devSessionId = req.headers.get('X-Set-Dev-Session');
        if (devSessionId) {
          response.headers.append(
            'Set-Cookie',
            `session_id=${devSessionId}; HttpOnly; Path=/; SameSite=Strict; Max-Age=604800`,
          );
        }
        return response;
      }
    }

    logger.info('No route matched, returning 404.');
    return new Response('Not Found', { status: 404 });
  };
}

---------- END: server/router.js ----------

---------- START: server/server-config.js ----------
import { resolve } from 'path';

/**
 * @typedef {object} Config
 * @property {string} CWD
 * @property {string | number} PORT
 * @property {boolean} IS_PROD
 * @property {string} OUTDIR
 * @property {string} TMPDIR
 * @property {string} TMP_COMPILED_DIR
 * @property {string} TMP_WRAPPERS_DIR
 * @property {string} TMP_APP_JS
 * @property {string} TMP_APP_CSS
 * @property {string} SRC_DIR
 * @property {string} APP_DIR
 * @property {string} PUB_DIR
 * @property {string} GUI_DIR
 * @property {string} LIB_DIR
 * @property {string} USER_FILES_ROOT
 * @property {string} TMP_GENERATED_ACTIONS
 * @property {string} TMP_COMPONENT_REGISTRY
 */

/**
 * @typedef {object} AIConfig
 * @property {string} host
 * @property {{ agent: string, chat: string, embedding: string, labeling: string }} models
 * @property {{ path: string, dimensions: number }} db
 */

/**
 * @typedef {object} DbConfig
 * @property {string} name
 * @property {number} version
 * @property {Record<string, import('./db.server.js').Table>} tables
 * @property {any[]} clientTables
 */

const userProjectDir = process.argv[2]
  ? resolve(process.argv[2])
  : process.cwd();
const FRAMEWORK_DIR = import.meta.dir;

/** @type {Config} */
export const config = {
  CWD: userProjectDir,
  PORT: process.env.PORT || 3000,
  IS_PROD: process.env.NODE_ENV === 'production',
  OUTDIR: resolve(userProjectDir, 'dist'),
  TMPDIR: resolve(userProjectDir, '.webs'),
  TMP_COMPILED_DIR: resolve(userProjectDir, '.webs/compiled'),
  TMP_WRAPPERS_DIR: resolve(userProjectDir, '.webs/layout'),
  TMP_APP_JS: resolve(userProjectDir, '.webs/app.js'),
  TMP_APP_CSS: resolve(userProjectDir, '.webs/app.css'),
  SRC_DIR: resolve(userProjectDir, 'src'),
  APP_DIR: resolve(userProjectDir, 'src/app'),
  PUB_DIR: resolve(userProjectDir, 'src/pub'),
  GUI_DIR: resolve(userProjectDir, 'src/gui'),
  LIB_DIR: resolve(FRAMEWORK_DIR, '../../lib'),
  USER_FILES_ROOT: resolve(userProjectDir, '.webs/files'),
  TMP_GENERATED_ACTIONS: resolve(userProjectDir, '.webs/actions.js'),
  TMP_COMPONENT_REGISTRY: resolve(userProjectDir, '.webs/registry.js'),
};

/** @type {AIConfig} */
export const aiConfig = {
  host: process.env.OLLAMA_HOST || 'http://localhost:11434',
  models: {
    agent: process.env.AGENT_MODEL || 'gwen3:8b',
    chat: process.env.CHAT_MODEL || 'gemma3:latest',
    labeling: process.env.LABEL_MODEL || 'gemma3:270m',
    embedding: process.env.EMBED_MODEL || 'embeddinggemma',
  },
  db: {
    path: '.webs/ai.db',
    dimensions: 768,
  },
};

export function getDbConfig() {
  const schema = {
    name: 'fw.db',
    version: 1,
    tables: {
      users: {
        keyPath: 'id',
        fields: {
          id: { type: 'integer', primaryKey: true },
          email: { type: 'text', notNull: true, unique: true },
          username: { type: 'text', notNull: true, unique: true },
          password: { type: 'text', notNull: true },
          created_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
      },
      sessions: {
        keyPath: 'id',
        fields: {
          id: { type: 'text', primaryKey: true },
          user_id: {
            type: 'integer',
            notNull: true,
            references: 'users(id)',
            onDelete: 'CASCADE',
          },
          expires_at: { type: 'timestamp', notNull: true },
        },
      },
      files: {
        sync: true,
        keyPath: 'path',
        primaryKeys: ['path', 'user_id'],
        fields: {
          path: { type: 'text', notNull: true },
          user_id: {
            type: 'integer',
            notNull: true,
            references: 'users(id)',
            onDelete: 'CASCADE',
          },
          content: { type: 'blob', notNull: true },
          access: { type: 'text', notNull: true, default: 'private' },
          size: { type: 'integer', notNull: true, default: 0 },
          last_modified: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
          updated_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
        indexes: [{ name: 'by-user', keyPath: 'user_id' }],
      },
      todos: {
        sync: true,
        keyPath: 'id',
        fields: {
          id: { type: 'text', primaryKey: true },
          content: { type: 'text', notNull: true },
          completed: { type: 'integer', notNull: true, default: 0 },
          user_id: {
            type: 'integer',
            notNull: true,
            references: 'users(id)',
            onDelete: 'CASCADE',
          },
          created_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
          updated_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
        indexes: [{ name: 'by-user', keyPath: 'user_id' }],
      },
      chats: {
        sync: true,
        keyPath: 'id',
        fields: {
          id: { type: 'text', primaryKey: true },
          name: { type: 'text', notNull: true },
          topic: { type: 'text' },
          owner_id: {
            type: 'integer',
            references: 'users(id)',
            onDelete: 'SET NULL',
          },
          created_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
        indexes: [{ name: 'by-owner', keyPath: 'owner_id' }],
      },
      chat_messages: {
        sync: true,
        keyPath: 'id',
        fields: {
          id: { type: 'text', primaryKey: true },
          chat_id: {
            type: 'text',
            notNull: true,
            references: 'chats(id)',
            onDelete: 'CASCADE',
          },
          username: { type: 'text', notNull: true },
          message: { type: 'text', notNull: true },
          attachments: { type: 'text' },
          user_id: {
            type: 'integer',
            references: 'users(id)',
            onDelete: 'SET NULL',
          },
          created_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
          updated_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
        indexes: [{ name: 'by-chat', keyPath: 'chat_id' }],
      },
    },
  };

  const clientTables = Object.entries(schema.tables)
    .filter(([, def]) => /** @type {any} */ (def).sync)
    .map(([name, def]) => ({
      name,
      keyPath: /** @type {any} */ (def).keyPath,
      autoIncrement: /** @type {any} */ (def).autoIncrement,
      indexes: /** @type {any} */ (def).indexes,
    }));

  return { ...schema, clientTables };
}

---------- END: server/server-config.js ----------

---------- START: server/server-setup.js ----------
import { exists, mkdir, writeFile } from 'fs/promises';
import { join, dirname } from 'path';
import { hashPassword } from './authentication.js';
import { generateUUID } from '../shared/utils.js';
import { createLogger } from '../shared/logger.js';

/**
 * @typedef {import('bun:sqlite').Database} Database
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('./ai.server.js').AI} AI
 */

/**
 * @typedef {object} Todo
 * @property {string} id
 * @property {string} content
 * @property {number} completed
 * @property {any} user_id
 */

const logger = createLogger('[Dev]');

/**
 * Ensures that a directory exists, creating it if necessary.
 * @param {string} dirPath
 */
export async function ensureDir(dirPath) {
  if (!(await exists(dirPath))) await mkdir(dirPath, { recursive: true });
}

/**
 * @param {Database} db
 * @param {Config} config
 * @param {AI} ai
 * @param {Record<string, string>} [docFiles]
 */
export async function seedDevDatabase(db, config, ai, docFiles) {
  const anonUser = {
    email: 'anon@webs.site',
    username: 'anon',
    password: 'password',
  };
  let existingUser = db
    .query('SELECT id FROM users WHERE username = ?')
    .get(anonUser.username);
  let anonUserId;

  if (existingUser) {
    anonUserId = existingUser.id;
  } else {
    const hashedPassword = await hashPassword(anonUser.password);
    const result = db
      .prepare('INSERT INTO users (email, username, password) VALUES (?, ?, ?)')
      .run(anonUser.email, anonUser.username, hashedPassword);
    anonUserId = result.lastInsertRowid;
  }

  if (!anonUserId) return;

  const anonPrivateDir = join(
    config.USER_FILES_ROOT,
    String(anonUserId),
    'private',
  );
  await ensureDir(anonPrivateDir);

  const seedFiles = {
    'welcome.txt': 'Welcome to your new Webs file system!',
    ...(docFiles && Object.keys(docFiles).length > 0
      ? docFiles
      : {
          'docs/webs-framework.md':
            '# Webs Framework\n\nThe Webs framework is a modern, file-based, full-stack JavaScript framework.',
          'docs/ai-features.md':
            '# AI Features\n\nThe framework includes a powerful AI module for semantic search and Retrieval-Augmented Generation (RAG).',
        }),
  };

  for (const [filePath, content] of Object.entries(seedFiles)) {
    const fullPath = join(anonPrivateDir, filePath);
    await ensureDir(dirname(fullPath));

    if (!(await exists(fullPath))) {
      logger.info(`Seeding file to disk: '${filePath}'...`);
      await writeFile(fullPath, content);
    }

    if (
      !db
        .query('SELECT path FROM files WHERE path = ? AND user_id = ?')
        .get(filePath, anonUserId)
    ) {
      logger.info(`Adding file to db: '${filePath}'...`);
      const now = new Date().toISOString();
      const fileRecord = {
        path: filePath,
        user_id: anonUserId,
        access: 'private',
        size: content.length,
        last_modified: now,
        updated_at: now,
        content: Buffer.from(content),
      };
      const insertStmt = db.prepare(
        'INSERT INTO files (path, user_id, access, size, last_modified, updated_at, content) VALUES ($path, $user_id, $access, $size, $last_modified, $updated_at, $content)',
      );

      const params = Object.fromEntries(
        Object.entries(fileRecord).map(([key, value]) => [`$${key}`, value]),
      );
      insertStmt.run(params);
    }

    await ai.indexFileIfNotExists(
      { path: filePath, content: content },
      { userId: anonUserId },
    );
  }

  const todoCount =
    db
      .query('SELECT COUNT(*) as count FROM todos WHERE user_id = ?')
      .get(anonUserId)?.count || 0;
  if (todoCount === 0) {
    logger.info('Seeding initial todos for anon user.');
    /** @type {Todo[]} */
    const seedTodos = [
      {
        id: generateUUID(),
        content: 'Explore the Webs framework',
        completed: 1,
        user_id: anonUserId,
      },
      {
        id: generateUUID(),
        content: 'Build something awesome',
        completed: 0,
        user_id: anonUserId,
      },
      {
        id: generateUUID(),
        content: 'Check out the local-first sync',
        completed: 0,
        user_id: anonUserId,
      },
    ];
    const insert = db.prepare(
      'INSERT INTO todos (id, content, completed, user_id, created_at, updated_at) VALUES ($id, $content, $completed, $user_id, $created_at, $updated_at)',
    );
    const insertTx = db.transaction((/** @type {Todo[]} */ todos) => {
      for (const todo of todos) {
        const now = new Date().toISOString();
        const params = Object.fromEntries(
          Object.entries({ ...todo, created_at: now, updated_at: now }).map(
            ([key, value]) => [`$${key}`, value],
          ),
        );
        insert.run(params);
      }
    });
    insertTx(seedTodos);
  }

  const chatCount =
    db.query('SELECT COUNT(*) as count FROM chats').get()?.count || 0;
  if (chatCount === 0) {
    logger.info('Seeding initial chat and messages.');
    const generalChatId = generateUUID();
    db.prepare(
      'INSERT INTO chats (id, name, topic, owner_id) VALUES (?, ?, ?, ?)',
    ).run(generalChatId, 'general-chat', 'General discussion', anonUserId);

    db.prepare(
      'INSERT INTO chat_messages (id, chat_id, username, message, user_id) VALUES (?, ?, ?, ?, ?)',
    ).run(
      generateUUID(),
      generalChatId,
      'anon',
      'Welcome to the first chat!',
      anonUserId,
    );
  }
}

---------- END: server/server-setup.js ----------

---------- START: server/server.js ----------
import { createFetchHandler } from './router.js';
import { createLogger } from '../shared/logger.js';
import { createFileSystemForUser } from './fs.server.js';

/**
 * @typedef {import('bun:sqlite').Database} Database
 * @typedef {import('bun').Server} Server
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('./ai.server.js').AI} AI
 */

/**
 * @template T
 * @typedef {import('bun').ServerWebSocket<T>} ServerWebSocket
 */

/**
 * @typedef {object} ServerContext
 * @property {Database} db
 * @property {any} dbConfig
 * @property {boolean} isProd
 * @property {Config} config
 * @property {string} SYNC_TOPIC
 * @property {AI} ai
 * @property {Record<string, Function>} syncActions
 * @property {any} manifest
 * @property {Record<string, any>} appRoutes
 * @property {any} agentRoutes
 * @property {any} globalComponents
 * @property {any} sourceToComponentMap
 * @property {string} actionsPath
 * @property {string[]} sourceEntrypoints
 */

/**
 * @typedef {object} WebSocketData
 * @property {boolean} [isSyncChannel]
 * @property {any} [user]
 * @property {any} [params]
 * @property {Record<string, Function>} [wsHandlers]
 */

/**
 * @typedef {object} WebSocketHandlerContext
 * @property {ServerWebSocket<WebSocketData>} socket - The WebSocket connection instance.
 * @property {import('./authentication.js').UserInfo | null} user - The authenticated user.
 * @property {Record<string, string>} params - The route parameters.
 * @property {Database} db - The database instance.
 * @property {import('./fs.server.js').ServerFsApi} fs - The user-scoped file system API.
 */

/**
 * @typedef {(context: WebSocketHandlerContext) => Promise<void> | void} OpenHandler
 * @typedef {(context: WebSocketHandlerContext & { message: string | Buffer }) => Promise<void> | void} MessageHandler
 * @typedef {(context: WebSocketHandlerContext) => Promise<void> | void} CloseHandler
 * @typedef {(context: WebSocketHandlerContext & { error: Error }) => Promise<void> | void} ErrorHandler
 */

const logger = createLogger('[Server]');

/**
 * This function starts the main web server, fully restoring the logic from `server-old.js`.
 * @param {ServerContext} serverContext
 */
export async function startServer(serverContext) {
  const { db, dbConfig, isProd, config, SYNC_TOPIC, syncActions } =
    serverContext;
  const { PORT } = config;

  const fetchHandler = createFetchHandler(serverContext);

  logger.info('Starting Webs server...');

  const serverOptions = {
    port: PORT,
    development: !isProd,
    fetch: fetchHandler,
    websocket: {
      /**
       * @param {ServerWebSocket<WebSocketData>} ws
       */
      open(ws) {
        if (ws.data?.isSyncChannel) {
          logger.info(
            'WebSocket client connected and subscribed to sync topic.',
          );
          ws.subscribe(SYNC_TOPIC);
          return;
        }

        const { wsHandlers, user, params } = ws.data;
        if (wsHandlers?.onOpen) {
          wsHandlers.onOpen({
            socket: ws,
            user,
            params,
            db,
            fs: createFileSystemForUser(user.id),
          });
        }
      },
      /**
       * @param {ServerWebSocket<WebSocketData>} ws
       * @param {string | Buffer} message
       */
      async message(ws, message) {
        if (ws.data?.isSyncChannel) {
          const server = Bun.serve(serverOptions);
          await handleSyncMessage(ws, message, server);
          server.stop();
          return;
        }

        const { wsHandlers, user, params } = ws.data;
        if (wsHandlers?.onMessage) {
          wsHandlers.onMessage({
            socket: ws,
            message,
            user,
            params,
            db,
            fs: createFileSystemForUser(user.id),
          });
        }
      },
      /**
       * @param {ServerWebSocket<WebSocketData>} ws
       * @param {number} _code
       * @param {string} _reason
       */
      close(ws, _code, _reason) {
        if (ws.data?.isSyncChannel) {
          ws.unsubscribe(SYNC_TOPIC);
          return;
        }

        const { wsHandlers, user, params } = ws.data;
        if (wsHandlers?.onClose) {
          wsHandlers.onClose({
            socket: ws,
            user,
            params,
            db,
            fs: createFileSystemForUser(user.id),
          });
        }
      },
      /**
       * @param {ServerWebSocket<WebSocketData>} ws
       * @param {Error} error
       */
      error(ws, error) {
        const { wsHandlers, user, params } = ws.data;
        if (wsHandlers?.onError) {
          wsHandlers.onError({
            socket: ws,
            error,
            user,
            params,
            db,
            fs: createFileSystemForUser(user?.id),
          });
        } else {
          logger.error('WebSocket error:', error);
        }
      },
    },
    error: (/** @type {Error} */ err) => {
      logger.error('Internal server error occurred:', err);
      return new Response('Internal Server Error', { status: 500 });
    },
  };

  /**
   * Handles incoming WebSocket messages for data synchronization.
   * @param {import('bun').ServerWebSocket<{user?: any}>} ws
   * @param {string | Buffer} message
   * @param {Server} server
   */
  async function handleSyncMessage(ws, message, server) {
    let payload;
    try {
      payload = JSON.parse(String(message));
      const { opId, type } = payload;
      const user = ws.data.user;

      if (type?.startsWith('fs:')) {
        const fs = createFileSystemForUser(user.id);
        const { path, data, options } = payload;
        let broadcastPayload;

        if (type === 'fs:write') {
          await fs.write(path, data, options);
          const stats = await fs.stat(path, options);
          const fileBlob = await fs.cat(path, options);
          const record = {
            path,
            user_id: user.id,
            content: await fileBlob.arrayBuffer(),
            access: options?.access || 'private',
            size: stats.size,
            last_modified: new Date().toISOString(),
          };
          if (syncActions.upsertFiles) {
            broadcastPayload = syncActions.upsertFiles(
              { user },
              record,
            )?.broadcast;
          }
        } else if (type === 'fs:rm') {
          await fs.rm(path, options);
          if (syncActions.deleteFiles) {
            broadcastPayload = syncActions.deleteFiles(
              { user },
              { path, user_id: user.id },
            )?.broadcast;
          }
        }

        ws.send(JSON.stringify({ type: 'ack', opId }));
        if (broadcastPayload) {
          server.publish(
            SYNC_TOPIC,
            JSON.stringify({ type: 'sync', data: broadcastPayload }),
          );
        }
      } else {
        const { tableName, data: recordData, id } = payload;
        if (
          !opId ||
          !type ||
          !tableName ||
          !dbConfig?.tables?.[tableName]?.sync
        ) {
          throw new Error('Invalid sync operation.');
        }

        const actionName =
          type === 'put'
            ? `upsert${tableName.charAt(0).toUpperCase() + tableName.slice(1)}`
            : `delete${tableName.charAt(0).toUpperCase() + tableName.slice(1)}`;
        const actionFn = syncActions[actionName];
        if (!actionFn)
          throw new Error(`Sync action '${actionName}' not found.`);

        const result = await actionFn(
          { user },
          type === 'put' ? recordData : { id },
        );
        if (result?.broadcast) {
          server.publish(
            SYNC_TOPIC,
            JSON.stringify({ type: 'sync', data: result.broadcast }),
          );
        }
        ws.send(JSON.stringify({ type: 'ack', opId }));
      }
    } catch (e) {
      const error = /** @type {Error} */ (e);
      logger.error('Sync Error:', error.message);
      ws.send(
        JSON.stringify({
          type: 'sync-error',
          opId: payload?.opId,
          error: error.message,
        }),
      );
    }
  }

  logger.info(`Server running at http://localhost:${PORT}`);
  return serverOptions;
}

---------- END: server/server.js ----------

---------- START: server/shell.js ----------
#!/usr/bin/env bun

import * as readline from 'node:readline';
import { $ } from 'bun';
import {
  runAnalysis,
  createLockfile,
  generateInspectionReport,
} from './profiler.js';
import { relative, resolve as resolvePath } from 'node:path';
import {
  suspendConsoleOutput,
  resumeConsoleOutput,
  getLogBuffer,
} from '../shared/logger.js';
import { createFileSystemForUser } from './fs.server.js';
import { generateUUID } from '../shared/utils.js';

const colors = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
};

/**
 * @param {keyof typeof colors} color
 * @param {string | number} text
 * @returns {string}
 */
const c = (color, text) => `${colors[color]}${text}${colors.reset}`;
/** @param {string} str */
const stripAnsi = (str) => str.replace(/\x1b\[[0-9;]*m/g, '');

const log = {
  /** @param {string} message */
  error: (message) => ` ${c('bold', c('red', '✖'))} ${c('red', message)} `,
};

/**
 * @typedef {object} ChatMessage
 * @property {'user' | 'assistant'} role
 * @property {string} content
 */

/**
 * @typedef {object} Chat
 * @property {string} id
 * @property {string} name
 * @property {string} topic
 * @property {string} created_at
 */

/**
 * @typedef {object} MainViewState
 * @property {string[]} outputLines
 * @property {string} inputLine
 * @property {number} cursorPos
 * @property {string[]} history
 * @property {number} historyIndex
 * @property {boolean} isBusy
 */

/**
 * @typedef {object} AiChatViewState
 * @property {string | null} chatId
 * @property {ChatMessage[]} messages
 * @property {boolean} isBusy
 */

/**
 * @typedef {object} AgentChatViewState
 * @property {ChatMessage[]} messages
 * @property {boolean} isBusy
 * @property {string | null} agentName
 * @property {any[]} toolEvents
 */

/**
 * @typedef {object} ChatSelectViewState
 * @property {Chat[]} chats
 * @property {boolean} isBusy
 * @property {string | null} error
 */

/**
 * @typedef {object} ShellState
 * @property {'main' | 'aiChat' | 'agentChat' | 'chatSelect'} currentView
 * @property {MainViewState} main
 * @property {AiChatViewState} aiChat
 * @property {AgentChatViewState} agentChat
 * @property {ChatSelectViewState} chatSelect
 */

/**
 * Starts the interactive developer shell with a stateful, view-based UI.
 * @param {import('./server-config.js').Config} config
 * @param {import('bun').Server} server
 * @param {import('./ai.server.js').AI} ai
 * @param {import('./router.js').ServerContext} serverContext
 * @returns {Promise<void>}
 */
export function startDevShell(config, server, ai, serverContext) {
  return new Promise((resolve) => {
    /** @type {ShellState} */
    let state = {
      currentView: 'main',
      main: {
        outputLines: [
          c('bold', `\nWelcome to the Webs Interactive Developer Shell.`),
          c('dim', `Watching for file changes. Type 'help' for commands.\n`),
        ],
        inputLine: '',
        cursorPos: 0,
        history: [],
        historyIndex: -1,
        isBusy: false,
      },
      aiChat: {
        chatId: null,
        messages: [],
        isBusy: false,
      },
      agentChat: {
        messages: [],
        isBusy: false,
        agentName: null,
        toolEvents: [],
      },
      chatSelect: {
        chats: [],
        isBusy: false,
        error: null,
      },
    };

    const promptText = `(webs-dev) ⬢ ${config.CWD.split('/').pop()} > `;
    const prompt = c('cyan', promptText);
    const promptLength = stripAnsi(prompt).length;

    const cleanupAndExit = async () => {
      process.stdout.off('resize', redraw);
      process.stdin.off('keypress', onKeyPress);
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(false);
      }
      process.stdout.write('\x1b[?25h');
      resumeConsoleOutput();
      console.log('');
      resolve();
    };

    /**
     * @param {ShellState['currentView']} view
     * @param {...any} args
     */
    const changeView = (view, ...args) => {
      state.currentView = view;
      if (view === 'aiChat') {
        const [chatId, ...promptParts] = args;
        enterAiChatView(chatId, promptParts.join(' '));
      } else if (view === 'agentChat') {
        enterAgentChatView(args[0], args.slice(1).join(' '));
      } else if (view === 'chatSelect') {
        enterChatSelectView();
      }
      redraw();
    };

    const redraw = () => {
      const { rows, columns } = process.stdout;
      process.stdout.write('\x1b[?25l');
      process.stdout.write('\x1b[2J\x1b[H');

      let headerText = '';
      switch (state.currentView) {
        case 'main':
          headerText = `[Main View] - Type 'help' for commands`;
          break;
        case 'aiChat': {
          const chatName = state.aiChat.chatId
            ? state.chatSelect.chats.find((c) => c.id === state.aiChat.chatId)
                ?.name || 'Chat'
            : 'New Chat';
          headerText = `[AI Chat: ${chatName}] - Use 'q' or '/back' on a new line to exit.`;
          break;
        }
        case 'agentChat':
          const agentName = state.agentChat.agentName || 'agent';
          headerText = `[Agent: ${agentName}] - Use 'q' or '/back' on a new line to exit.`;
          break;
        case 'chatSelect':
          headerText = `[AI Chat] - Select a chat or type 'new' to start.`;
          break;
      }

      const paddedHeader = c('bold', headerText.padEnd(columns));
      process.stdout.write(`\x1b[44m\x1b[37m${paddedHeader}\x1b[0m`);

      switch (state.currentView) {
        case 'main':
          drawMainView(rows, columns);
          break;
        case 'aiChat':
          drawAiChatView(rows, columns);
          break;
        case 'agentChat':
          drawAgentChatView(rows, columns);
          break;
        case 'chatSelect':
          drawChatSelectView(rows, columns);
          break;
      }

      process.stdout.write(`\x1b[?25h`);
    };
    /**
     * @param {number} rows
     * @param {number} _columns
     */
    const drawMainView = (rows, _columns) => {
      const outputHeight = rows - 3;
      const visibleOutput = state.main.outputLines.slice(-outputHeight);
      process.stdout.write('\n');
      process.stdout.write(visibleOutput.join('\n'));
      for (let i = visibleOutput.length; i < outputHeight; i++) {
        process.stdout.write('\n');
      }

      const fullPrompt = prompt + state.main.inputLine;
      process.stdout.write(`\x1b[${rows};1H${fullPrompt}`);
      process.stdout.write('\x1b[K');
      process.stdout.write(
        `\x1b[${rows};${promptLength + state.main.cursorPos + 1}H`,
      );
    };
    /**
     * @param {number} rows
     * @param {number} _columns
     */

    const drawChatSelectView = (rows, _columns) => {
      const outputHeight = rows - 3;
      const { chats, isBusy, error } = state.chatSelect;
      let output = [];

      if (isBusy) {
        output.push(c('dim', 'Loading chats...'));
      } else if (error) {
        output.push(c('red', `Error: ${error}`));
        output.push(c('dim', "Type 'q' or '/back' to return."));
      } else if (chats.length === 0) {
        output.push('No previous chats found.');
        output.push('\n' + c('bold', "Type 'new' to start a new chat."));
        output.push(c('dim', "Type 'q' or '/back' to return."));
      } else {
        output.push(c('bold', 'Your recent chats:'));
        chats.forEach((chat, i) => {
          const topic = chat.topic ? `- ${chat.topic.substring(0, 50)}...` : '';
          output.push(
            c('bold', `${i + 1}. ${chat.name}`) + c('dim', ` ${topic}`),
          );
        });
        output.push(
          '\n' +
            c(
              'bold',
              "Enter a number to continue a chat, or type 'new' to start a new one.",
            ),
        );
        output.push(c('dim', "Type 'q' or '/back' to return."));
      }

      if (error) {
        state.chatSelect.error = null;
      }

      const visibleOutput = output.slice(-outputHeight);
      process.stdout.write('\n');
      process.stdout.write(visibleOutput.join('\n'));
      for (let i = visibleOutput.length; i < outputHeight; i++) {
        process.stdout.write('\n');
      }

      const fullPrompt = '> ' + state.main.inputLine;
      process.stdout.write(`\x1b[${rows};1H${fullPrompt}`);
      process.stdout.write('\x1b[K');
      process.stdout.write(`\x1b[${rows};${2 + state.main.cursorPos + 1}H`);
    };

    /**
     * @param {number} rows
     * @param {number} _columns
     */
    const drawAiChatView = (rows, _columns) => {
      const outputHeight = rows - 3;
      const messagesToDisplay = [];
      for (const msg of state.aiChat.messages) {
        const prefix =
          msg.role === 'user'
            ? c('green', c('bold', 'You: '))
            : c('magenta', c('bold', 'AI:  '));
        messagesToDisplay.push(...(prefix + msg.content).split('\n'));
      }
      if (state.aiChat.isBusy) {
        messagesToDisplay.push(c('dim', 'AI is thinking...'));
      }

      const visibleOutput = messagesToDisplay.slice(-outputHeight);
      process.stdout.write('\n');
      process.stdout.write(visibleOutput.join('\n'));
      for (let i = visibleOutput.length; i < outputHeight; i++) {
        process.stdout.write('\n');
      }

      const fullPrompt = '> ' + state.main.inputLine;
      process.stdout.write(`\x1b[${rows};1H${fullPrompt}`);
      process.stdout.write('\x1b[K');
      process.stdout.write(`\x1b[${rows};${2 + state.main.cursorPos + 1}H`);
    };

    /**
     * @param {number} rows
     * @param {number} _columns
     */
    const drawAgentChatView = (rows, _columns) => {
      const outputHeight = rows - 3;
      const messagesToDisplay = [];
      for (const msg of state.agentChat.messages) {
        const prefix =
          msg.role === 'user'
            ? c('green', c('bold', 'You: '))
            : c('magenta', c('bold', 'Agent: '));
        messagesToDisplay.push(...(prefix + msg.content).split('\n'));
      }

      if (state.agentChat.toolEvents.length > 0) {
        messagesToDisplay.push(c('bold', c('yellow', '\n--- Tool Calls ---')));
        for (const tool of state.agentChat.toolEvents) {
          messagesToDisplay.push(
            c('yellow', `> Calling ${tool.name}(${JSON.stringify(tool.args)})`),
          );
          if (tool.status === 'complete') {
            messagesToDisplay.push(
              c('dim', `  └─ Result: ${JSON.stringify(tool.result)}`),
            );
          }
        }
        messagesToDisplay.push('');
      }

      if (state.agentChat.isBusy) {
        messagesToDisplay.push(c('dim', 'Agent is thinking...'));
      }

      const visibleOutput = messagesToDisplay.slice(-outputHeight);
      process.stdout.write('\n');
      process.stdout.write(visibleOutput.join('\n'));
      for (let i = visibleOutput.length; i < outputHeight; i++) {
        process.stdout.write('\n');
      }

      const fullPrompt = '> ' + state.main.inputLine;
      process.stdout.write(`\x1b[${rows};1H${fullPrompt}`);
      process.stdout.write('\x1b[K');
      process.stdout.write(`\x1b[${rows};${2 + state.main.cursorPos + 1}H`);
    };

    /** @param {string} line */
    const executeMainCommand = async (line) => {
      const trimmedLine = line.trim();
      state.main.isBusy = true;
      state.main.outputLines.push(prompt + line);
      if (trimmedLine) {
        state.main.history.unshift(trimmedLine);
        if (state.main.history.length > 100) state.main.history.pop();
      }
      state.main.historyIndex = -1;
      state.main.inputLine = '';
      state.main.cursorPos = 0;
      redraw();

      const [commandName, ...args] = trimmedLine.split(/\s+/);
      const cmd = commandName ? commands[commandName.toLowerCase()] : null;

      if (cmd) {
        const originalConsoleLog = console.log;
        const capturedOutput = [];
        console.log = (...logArgs) => {
          capturedOutput.push(
            logArgs
              .map((arg) =>
                typeof arg === 'string' ? arg : JSON.stringify(arg),
              )
              .join(' '),
          );
        };
        resumeConsoleOutput();
        try {
          await cmd.action(args);
        } catch (e) {
          const error = /** @type {Error} */ (e);
          capturedOutput.push(
            c('red', `Error executing command: ${error.message}`),
          );
        } finally {
          console.log = originalConsoleLog;
          suspendConsoleOutput();
          if (capturedOutput.length > 0) {
            state.main.outputLines.push(...capturedOutput);
          }
        }
      } else if (commandName) {
        state.main.outputLines.push(
          log.error(
            `Unknown command: '${commandName}'. Type 'help' for available commands.`,
          ),
        );
      }
      state.main.isBusy = false;
      redraw();
    };
    /** @param {string} line */
    const handleAiChatSubmit = async (line) => {
      const content = line.trim();
      if (!content) return;
      if (content === '/back' || content === 'q') {
        changeView('main');
        return;
      }

      const { aiChat: ac } = state;
      const devUser = { id: 1, username: 'anon' };
      ac.isBusy = true;
      state.main.inputLine = '';
      state.main.cursorPos = 0;

      if (!ac.chatId) {
        redraw();
        try {
          const { chatId } = await ai.createChat(
            { message: { role: 'user', content } },
            {
              db: serverContext.db,
              user: devUser,
              syncActions: serverContext.syncActions,
              server,
            },
          );
          ac.chatId = chatId;
          ac.messages.push({ role: 'user', content });
        } catch (e) {
          ac.isBusy = false;
          const message = e instanceof Error ? e.message : String(e);
          ac.messages.push({
            role: 'assistant',
            content: c('red', `Failed to create chat: ${message}`),
          });
          redraw();
          return;
        }
      } else {
        const userMessageToSave = {
          id: generateUUID(),
          chat_id: ac.chatId,
          username: devUser.username,
          message: content,
          user_id: devUser.id,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };
        if (serverContext.syncActions.upsertChat_messages) {
          serverContext.syncActions.upsertChat_messages(
            { user: devUser },
            userMessageToSave,
          );
        }
        ac.messages.push({ role: 'user', content });
      }

      redraw();

      const historyForApi = ac.messages.map(({ role, content }) => ({
        role,
        content,
      }));

      try {
        const stream = ai.chat(historyForApi);
        ac.isBusy = false;
        let responseText = '';
        /** @type {ChatMessage} */
        const assistantMessage = { role: 'assistant', content: '' };
        ac.messages.push(assistantMessage);

        for await (const chunk of stream) {
          responseText += chunk;
          assistantMessage.content = responseText;
          redraw();
        }

        const aiMessageToSave = {
          id: generateUUID(),
          chat_id: ac.chatId,
          username: 'assistant',
          message: responseText,
          user_id: null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };
        if (serverContext.syncActions.upsertChat_messages) {
          serverContext.syncActions.upsertChat_messages(
            { user: devUser },
            aiMessageToSave,
          );
        }
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        ac.messages.push({
          role: 'assistant',
          content: c('red', `AI chat failed: ${message}`),
        });
      } finally {
        ac.isBusy = false;
        redraw();
      }
    };

    /** @param {string} line */
    const handleAgentChatSubmit = async (line) => {
      const content = line.trim();
      if (!content) return;
      if (content === '/back' || content === 'q') {
        changeView('main');
        return;
      }
      const { agentChat: ac } = state;
      const agentName = ac.agentName;
      if (!agentName) return;

      ac.messages.push({ role: 'user', content });
      ac.isBusy = true;
      ac.toolEvents = [];
      state.main.inputLine = '';
      state.main.cursorPos = 0;
      redraw();

      const agentDef = serverContext.agentRoutes[agentName];
      if (!agentDef) {
        ac.isBusy = false;
        ac.messages.push({
          role: 'assistant',
          content: c('red', `Agent '${agentName}' definition not found.`),
        });
        redraw();
        return;
      }

      try {
        const toolContext = {
          db: serverContext.db,
          user: { id: 1, username: 'dev' }, // Mock user for shell
          fs: createFileSystemForUser(1),
          ai,
          syncActions: serverContext.syncActions,
          server,
        };
        const stream = ai.agent(ac.messages, agentDef, toolContext);
        ac.isBusy = false;
        let responseText = '';
        /** @type {ChatMessage} */
        const assistantMessage = { role: 'assistant', content: '' };
        ac.messages.push(assistantMessage);

        for await (const chunk of stream) {
          try {
            const event = JSON.parse(chunk);
            if (event.type === 'chunk') {
              responseText += event.content || '';
              assistantMessage.content = responseText;
            } else if (event.type === 'tool_start') {
              ac.toolEvents.push({
                name: event.name,
                args: event.args,
                status: 'pending',
              });
            } else if (event.type === 'tool_end') {
              const toolEvent = ac.toolEvents.find(
                (e) => e.name === event.name && e.status === 'pending',
              );
              if (toolEvent) {
                toolEvent.result = event.result;
                toolEvent.status = 'complete';
              }
            }
          } catch (e) {
            responseText += chunk;
            assistantMessage.content = responseText;
          }
          redraw();
        }
      } catch (e) {
        ac.isBusy = false;
        const message = e instanceof Error ? e.message : String(e);
        ac.messages.push({
          role: 'assistant',
          content: c('red', `Agent run failed: ${message}`),
        });
      }
      redraw();
    };

    /** @param {string} output */
    const printApiResponse = (output) => {
      const capturedOutput = [];
      const [headerPart, ...bodyParts] = output.split('\r\n\r\n');
      const body = bodyParts.join('\r\n\r\n');
      const headers = headerPart?.split('\r\n') || [];
      const statusLine = headers.shift();

      if (statusLine) {
        const statusMatch = statusLine.match(/HTTP\/\d\.\d (\d+) (.*)/);
        if (statusMatch) {
          const code = parseInt(statusMatch[1] || '0', 10);
          const statusText = statusMatch[2];
          const color =
            code >= 200 && code < 300
              ? 'green'
              : code >= 400
                ? 'red'
                : 'yellow';
          capturedOutput.push(
            c('bold', `Status: ${c(color, `${code} ${statusText}`)}`),
          );
        }
      }
      capturedOutput.push(c('dim', body));
      state.main.outputLines.push(...capturedOutput);
    };

    /** @type {{ [key: string]: { description: string, action: (args: string[]) => void | Promise<void> } }} */
    const commands = {
      help: {
        description: 'Displays this help message.',
        action() {
          console.log('\nAvailable Views & Commands:\n');
          const commandList = Object.entries(commands).sort(([a], [b]) =>
            a.localeCompare(b),
          );
          for (const [name, { description }] of commandList) {
            console.log(`  ${c('bold', name.padEnd(10))} ${description}`);
          }
          console.log('\n');
        },
      },
      exit: {
        description: 'Exits the developer shell and stops the server.',
        action: cleanupAndExit,
      },
      clear: {
        description: 'Clears the output of the main view.',
        action: () => {
          state.main.outputLines = [];
        },
      },
      logs: {
        description: 'Displays recent server logs from memory.',
        action: () => {
          const buffer = getLogBuffer();
          if (buffer.length === 0) {
            console.log(c('dim', 'Log buffer is empty.'));
            return;
          }
          console.log(c('bold', '\n--- Recent Server Logs ---'));
          console.log(buffer.join('\n'));
          console.log(c('bold', '--- End of Logs ---'));
        },
      },
      ai: {
        description: 'Select a previous AI chat or start a new one.',
        action: () => changeView('chatSelect'),
      },
      chat: {
        description: "Alias for 'ai'. Starts or resumes an AI chat session.",
        action: () => changeView('chatSelect'),
      },
      agent: {
        description:
          'Runs a defined AI agent. Usage: agent [name] [initial prompt]',
        action: async (args) => {
          const [agentName, ...promptParts] = args;
          const agentDefs = serverContext.agentRoutes || {};

          if (!agentName) {
            console.log(c('bold', '\nAvailable Agents:'));
            if (Object.keys(agentDefs).length === 0) {
              console.log(
                c(
                  'dim',
                  '  No agents defined. Create files ending in .agent.webs in src/app.',
                ),
              );
            } else {
              for (const name in agentDefs) {
                console.log(`  - ${name}`);
              }
            }
            console.log('');
            return;
          }

          if (!agentDefs[agentName]) {
            console.log(log.error(`Agent '${agentName}' not found.`));
            return;
          }

          const initialPrompt = promptParts.join(' ');
          changeView('agentChat', agentName, initialPrompt);
        },
      },
      inspect: {
        description: 'Displays a report of all pages, components, and routes.',
        action: async () =>
          generateInspectionReport({ ...serverContext, config }),
      },
      analyze: {
        description: 'Runs type analysis and tests for the current target.',
        action: async () => await runAnalysis(config.CWD),
      },
      lock: {
        description:
          'Generates a webs.lock.txt file. Usage: lock [lib|src] [--include <files...>] [--exclude <patterns...>]',
        action: async (args) => {
          let lockTargetDir = config.CWD;
          let commandArgs = [...args];
          const target = commandArgs[0];
          if (target === 'lib' || target === 'src') {
            commandArgs.shift();
            lockTargetDir = resolvePath(process.cwd(), target);
            if (!(await Bun.file(lockTargetDir).exists())) {
              console.log(log.error(`Directory './${target}' not found.`));
              return;
            }
          }
          /**
           * @param {string[]} localArgs
           * @param {string} flag
           * @returns {string[]}
           */
          const getFlagValues = (localArgs, flag) => {
            const flagIndex = localArgs.indexOf(flag);
            const values = [];
            if (flagIndex !== -1) {
              for (let i = flagIndex + 1; i < localArgs.length; i++) {
                const arg = localArgs[i];
                if (arg && arg.startsWith('--')) break;
                if (arg) values.push(arg);
              }
            }
            return values;
          };
          const includedFiles = getFlagValues(commandArgs, '--include');
          const excludedPatterns = getFlagValues(commandArgs, '--exclude');
          console.log(
            `Creating lockfile for: ./${relative(
              process.cwd(),
              lockTargetDir,
            )}`,
          );
          await createLockfile(lockTargetDir, includedFiles, excludedPatterns);
        },
      },
      grep: {
        description:
          'Searches for a pattern in files. Usage: grep <pattern> [path] [--include <glob>]',
        action: async (args) => {
          const [pattern, path = config.CWD, ...rest] = args;
          if (!pattern) {
            return console.log(
              log.error('Usage: grep <pattern> [path] [--include <glob>]'),
            );
          }
          const includeIndex = rest.indexOf('--include');
          const filePattern =
            includeIndex > -1 ? rest[includeIndex + 1] : undefined;
          const grepArgs = ['-r', '-n', '-I', pattern, path];
          if (filePattern) {
            grepArgs.splice(3, 0, `--include=${filePattern}`);
          }
          const proc = Bun.spawn(['grep', ...grepArgs], {
            stdout: 'pipe',
            stderr: 'pipe',
          });
          const stdout = await new Response(proc.stdout).text();
          const stderr = await new Response(proc.stderr).text();
          /** @param {string} line */
          const highlight = (line) =>
            line.replace(
              new RegExp(pattern, 'g'),
              /** @param {string} match */
              (match) => c('red', c('bold', match)),
            );
          const outputLines = stdout
            .split('\n')
            .filter((line) => line)
            .map((line) => {
              const parts = line.split(':');
              const filePath = parts.shift();
              const lineNum = parts.shift();
              const content = parts.join(':');
              return `${c('yellow', filePath || '')}:${c(
                'cyan',
                lineNum || '',
              )}: ${highlight(content)}`;
            });
          if (outputLines.length > 0) {
            console.log(outputLines.join('\n'));
          } else {
            console.log(c('dim', 'No results found.'));
          }
          if (stderr) {
            console.log(log.error(`grep error:\n${stderr}`));
          }
        },
      },
      api: {
        description:
          'Makes an HTTP request to the dev server. Usage: api <GET|POST|..> <path> [body]',
        action: async (args) => {
          const [method, path, ...bodyParts] = args;
          if (!method || !path)
            return console.log(log.error('Usage: api <METHOD> <path> [body]'));
          const body = bodyParts.join(' ');
          const headers =
            method.toUpperCase() !== 'GET'
              ? `-H "Content-Type: application/json"`
              : '';
          const data = body ? `-d '${$.escape(body)}'` : '';
          const command = `curl -s -i -X ${method.toUpperCase()} http://localhost:${
            server.port
          }${path} ${headers} ${data}`;
          const { stdout, stderr } = await $`${{ raw: command }}`.nothrow();
          if (stderr.length > 0) {
            console.log(log.error(`Request failed.`));
            console.log(stderr.toString());
          } else {
            printApiResponse(stdout.toString());
          }
        },
      },
    };

    const enterChatSelectView = async () => {
      const { chatSelect: cs } = state;
      cs.isBusy = true;
      cs.error = null;
      redraw();
      try {
        const devUser = { id: 1, username: 'anon' };
        const chats = await ai.getChats({
          db: serverContext.db,
          user: devUser,
          syncActions: serverContext.syncActions,
          server,
        });
        cs.chats = chats;
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        cs.error = message;
      } finally {
        cs.isBusy = false;
      }
      redraw();
    };

    /**
     * @param {string | null} chatId
     * @param {string} initialPrompt
     */
    const enterAiChatView = async (chatId, initialPrompt) => {
      const { aiChat: ac } = state;
      ac.chatId = chatId;
      ac.messages = [];
      state.main.inputLine = '';
      state.main.cursorPos = 0;

      if (chatId) {
        ac.isBusy = true;
        redraw();
        try {
          const messages = serverContext.db
            .prepare(
              'SELECT username, message as content FROM chat_messages WHERE chat_id = ? ORDER BY created_at ASC',
            )
            .all(chatId);

          ac.messages = messages.map(
            (/** @type {{ username: string; content: any; }} */ m) => ({
              role: m.username === 'anon' ? 'user' : 'assistant',
              content: m.content,
            }),
          );
        } catch (e) {
          const message = e instanceof Error ? e.message : String(e);
          ac.messages.push({
            role: 'assistant',
            content: c('red', `Error loading chat history: ${message}`),
          });
        } finally {
          ac.isBusy = false;
        }
      }

      if (initialPrompt) {
        await handleAiChatSubmit(initialPrompt);
      } else {
        redraw();
      }
    };

    /**
     * @param {string | undefined} agentName
     * @param {string} initialPrompt
     */
    const enterAgentChatView = (agentName, initialPrompt) => {
      state.agentChat.agentName = agentName || null;
      state.agentChat.messages = [];
      state.agentChat.toolEvents = [];
      state.main.inputLine = '';
      state.main.cursorPos = 0;
      if (initialPrompt) {
        handleAgentChatSubmit(initialPrompt);
      }
    };

    /**
     * @param {string | undefined} str
     * @param {{ name: string, ctrl?: boolean, meta?: boolean }} key
     */
    const handleMainKeyPress = (str, key) => {
      const { main: m } = state;
      switch (key.name) {
        case 'return':
          executeMainCommand(m.inputLine);
          return;
        case 'backspace':
          if (m.cursorPos > 0) {
            m.inputLine =
              m.inputLine.slice(0, m.cursorPos - 1) +
              m.inputLine.slice(m.cursorPos);
            m.cursorPos--;
          }
          break;
        case 'delete':
          m.inputLine =
            m.inputLine.slice(0, m.cursorPos) +
            m.inputLine.slice(m.cursorPos + 1);
          break;
        case 'left':
          m.cursorPos = Math.max(0, m.cursorPos - 1);
          break;
        case 'right':
          m.cursorPos = Math.min(m.inputLine.length, m.cursorPos + 1);
          break;
        case 'up':
          if (m.historyIndex < m.history.length - 1) {
            m.historyIndex++;
            m.inputLine = m.history[m.historyIndex] || '';
            m.cursorPos = m.inputLine.length;
          }
          break;
        case 'down':
          if (m.historyIndex > 0) {
            m.historyIndex--;
            m.inputLine = m.history[m.historyIndex] || '';
            m.cursorPos = m.inputLine.length;
          } else {
            m.historyIndex = -1;
            m.inputLine = '';
            m.cursorPos = 0;
          }
          break;
        default:
          if (str && !key.ctrl && !key.meta) {
            m.inputLine =
              m.inputLine.slice(0, m.cursorPos) +
              str +
              m.inputLine.slice(m.cursorPos);
            m.cursorPos++;
          }
      }
    };

    /**
     * @param {string | undefined} str
     * @param {{ name: string, ctrl?: boolean, meta?: boolean }} key
     */
    const handleChatSelectKeyPress = (str, key) => {
      const { main: m, chatSelect: cs } = state;
      if (key.name === 'return') {
        const input = m.inputLine.trim().toLowerCase();
        m.inputLine = '';
        m.cursorPos = 0;
        if (input === 'new') {
          changeView('aiChat', null);
        } else if (input === 'q' || input === '/back') {
          changeView('main');
        } else {
          const index = parseInt(input, 10) - 1;
          const chat = cs.chats[index];
          if (!isNaN(index) && chat) {
            changeView('aiChat', chat.id);
          } else {
            cs.error =
              "Invalid selection. Please enter a number from the list or 'new'.";
            redraw();
          }
        }
        return;
      }
      handleMainKeyPress(str, key);
    };

    /**
     * @param {string | undefined} str
     * @param {{ name: string, ctrl?: boolean, meta?: boolean }} key
     */
    const onKeyPress = (str, key) => {
      if (key.ctrl && key.name === 'c') {
        return cleanupAndExit();
      }
      const isBusy =
        state.main.isBusy || state.aiChat.isBusy || state.agentChat.isBusy;
      if (isBusy && key.name !== 'q') return;

      switch (state.currentView) {
        case 'main':
          handleMainKeyPress(str, key);
          break;
        case 'chatSelect':
          handleChatSelectKeyPress(str, key);
          break;
        case 'aiChat':
          if (key.name === 'return') {
            handleAiChatSubmit(state.main.inputLine);
          } else {
            handleMainKeyPress(str, key);
          }
          break;
        case 'agentChat':
          if (key.name === 'return') {
            handleAgentChatSubmit(state.main.inputLine);
          } else {
            handleMainKeyPress(str, key);
          }
          break;
      }

      redraw();
    };

    if (process.stdin.isTTY) process.stdin.setRawMode(true);
    readline.emitKeypressEvents(process.stdin);
    process.stdin.on('keypress', onKeyPress);
    process.stdout.on('resize', redraw);

    suspendConsoleOutput();
    redraw();
  });
}

---------- END: server/shell.js ----------

---------- START: shared/devtools.js ----------
/**
 * @file Initializes the global developer tools interface.
 * This module creates the `window.__WEBS_DEVELOPER__` object,
 * providing a bridge for external devtools to inspect and interact with the application instance.
 */

import { createLogger } from './logger.js';
/**
 * @typedef {import('../engine/core.js').App} App
 */

/**
 * @typedef {object} DevToolsEvents
 * @property {(event: string, callback: Function) => void} on - Registers an event listener.
 * @property {(event: string, data: any) => void} emit - Emits an event to all listeners.
 * @property {(event: string, callback: Function) => void} off - Removes a specific event listener.
 */

/**
 * @typedef {Window & { __WEBS_DEVELOPER__?: { registerApp(app: App): void; getApp(): App | null; events: DevToolsEvents; } }} DevtoolsWindow
 */

const logger = createLogger('[DevTools]');
/**
 * @internal
 * @type {App | null}
 */
let appInstance = null;
/**
 * @internal
 * @type {Map<string, Array<Function>>}
 */
const listeners = new Map();

/**
 * @internal
 * @type {DevToolsEvents}
 */
const events = {
  on(event, callback) {
    if (!listeners.has(event)) {
      listeners.set(event, []);
    }
    const eventListeners = listeners.get(event);
    if (eventListeners) {
      eventListeners.push(callback);
    }
  },

  emit(event, data) {
    listeners.get(event)?.forEach((cb) => cb(data));
  },

  off(event, callback) {
    const eventListeners = listeners.get(event);
    if (eventListeners) {
      const index = eventListeners.indexOf(callback);
      if (index > -1) {
        eventListeners.splice(index, 1);
      }
    }
  },
};

/**
 * Initializes the developer tools global hook.
 * This function should be called when the application is bootstrapping on the client.
 */
export function initDevTools() {
  if (typeof window === 'undefined') {
    return;
  }

  logger.log('Initializing global __WEBS_DEVEVOPER__');

  /**
   * @global
   * @namespace __WEBS_DEVELOPER__
   * @property {(app: App) => void} registerApp - Registers the main application instance.
   * @property {() => App | null} getApp - Retrieves the registered application instance.
   * @property {DevToolsEvents} events - An event emitter for devtools communication.
   */
  /** @type {DevtoolsWindow} */ (window).__WEBS_DEVELOPER__ = {
    /** @param {App} app */
    registerApp(app) {
      logger.log('Application instance registered with devtools.');
      appInstance = app;
      events.emit('app:init', app);
    },

    getApp() {
      return appInstance;
    },

    events,
  };
}

---------- END: shared/devtools.js ----------

---------- START: shared/logger.js ----------
/**
 * @file Manages logging functionality with configurable levels.
 */

import { format } from 'util';

/**
 * The available logging levels.
 * @typedef {'debug' | 'info' | 'warn' | 'error' | 'silent'} LogLevel
 */

/**
 * A logger instance with methods for different log levels.
 * @typedef {object} Logger
 * @property {(...args: any[]) => void} debug - Logs a debug message.
 * @property {(...args: any[]) => void} info - Logs an info message.
 * @property {(...args: any[]) => void} log - Logs an info message (alias for info).
 * @property {(...args: any[]) => void} warn - Logs a warning message.
 * @property {(...args: any[]) => void} error - Logs an error message.
 */

/**
 * @internal
 * @type {Record<LogLevel, number>}
 * Maps log levels to their severity number.
 */
const LOG_LEVELS = {
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  silent: 5,
};

/**
 * @internal
 * @type {LogLevel}
 * The current logging level name.
 */
let currentLogLevelName =
  (typeof process !== 'undefined' &&
    /** @type {LogLevel} */ (process.env.LOG_LEVEL)) ||
  'info';

/**
 * @internal
 * @type {number}
 * The current logging level severity.
 */
let currentLogLevel = LOG_LEVELS[currentLogLevelName];

/**
 * @internal
 * @type {number}
 * The maximum length of a logger name (the text inside the brackets), used for alignment.
 */
let maxNameLength = 0;

/**
 * @internal
 * @type {string[]}
 * The in-memory buffer for recent log entries.
 */
let logBuffer = [];

/**
 * @internal
 * @type {number}
 * The maximum number of log entries to keep in memory.
 */
const MAX_LOG_BUFFER_SIZE = 500;

/**
 * @internal
 * @type {boolean}
 * Flag to control console output, useful for interactive shells.
 */
let isConsoleSuspended = false;

/**
 * Suspends logging to the console.
 */
export function suspendConsoleOutput() {
  isConsoleSuspended = true;
}

/**
 * Resumes logging to the console.
 */
export function resumeConsoleOutput() {
  isConsoleSuspended = false;
}

/**
 * Retrieves a copy of the current in-memory log buffer.
 * @returns {string[]} A list of recent log entries.
 */
export function getLogBuffer() {
  return [...logBuffer];
}

/**
 * Sets the global logging level for all created loggers.
 * @param {LogLevel} level - The new logging level to set.
 */
export function setLogLevel(level) {
  if (LOG_LEVELS[level]) {
    currentLogLevel = LOG_LEVELS[level];
    currentLogLevelName = level;
  }
}

/**
 * Creates a new logger instance with a specified prefix.
 * @param {string} prefix - The prefix to prepend to all log messages from this logger (e.g., '[MyLogger]').
 * @returns {Logger} A logger object with different log levels.
 */
export function createLogger(prefix) {
  const name = prefix.slice(1, -1);
  if (name.length > maxNameLength) {
    maxNameLength = name.length;
  }

  /**
   * @internal
   * @param {number} level - The severity level of the message.
   * @param {'log' | 'warn' | 'error'} consoleMethod - The console method to use.
   * @param {keyof typeof LOG_LEVELS} levelName - The string name of the log level.
   * @param {...any} args - The arguments to log.
   */
  const doLog = (level, consoleMethod, levelName, ...args) => {
    const shouldLogToConsole = level >= currentLogLevel && !isConsoleSuspended;

    const formattedMessage = format(...args);
    // Strip ANSI color codes for the buffer to keep it clean
    const strippedMessage = formattedMessage.replace(/\x1b\[[0-9;]*m/g, '');
    const timestamp = new Date().toLocaleTimeString();
    const bufferEntry = `[${timestamp}] [${levelName.toUpperCase()}] ${strippedMessage}`;

    logBuffer.push(bufferEntry);
    if (logBuffer.length > MAX_LOG_BUFFER_SIZE) {
      logBuffer.shift();
    }

    if (shouldLogToConsole) {
      if (typeof process !== 'undefined') {
        const paddedName = ' ' + name.padEnd(maxNameLength - 1, ' ');
        const finalPrefix = `[${paddedName}]`;
        console[consoleMethod](finalPrefix, ...args);
      } else {
        console[consoleMethod](...args);
      }
    }
  };

  return {
    /** @param {...any} args */
    debug: (...args) => doLog(LOG_LEVELS.debug, 'log', 'debug', ...args),
    /** @param {...any} args */
    info: (...args) => doLog(LOG_LEVELS.info, 'log', 'info', ...args),
    /** @param {...any} args */
    log: (...args) => doLog(LOG_LEVELS.info, 'log', 'info', ...args),
    /** @param {...any} args */
    warn: (...args) => doLog(LOG_LEVELS.warn, 'warn', 'warn', ...args),
    /** @param {...any} args */
    error: (...args) => doLog(LOG_LEVELS.error, 'error', 'error', ...args),
  };
}

---------- END: shared/logger.js ----------

---------- START: shared/utils.js ----------
/**
 * @file Contains shared utility functions for language, DOM, and common tasks.
 */

/**
 * Checks if a value is a plain object.
 * @param {any} val - The value to check.
 * @returns {val is object} `true` if the value is an object, not an array, and not null.
 */
export const isObject = (val) =>
  val !== null && typeof val === 'object' && !Array.isArray(val);

/**
 * Checks if a value is a string.
 * @param {any} val - The value to check.
 * @returns {val is string} `true` if the value is a string.
 */
export const isString = (val) => typeof val === 'string';

/**
 * Checks if a value is a function.
 * @param {any} val - The value to check.
 * @returns {val is Function} `true` if the value is a function.
 */
export const isFunction = (val) => typeof val === 'function';

/**
 * Generates a universally unique identifier (UUID) v4.
 * Uses the browser's or Node.js's native `crypto.randomUUID` if available,
 * otherwise falls back to a Math.random-based implementation.
 * @returns {string} The generated UUID.
 */
export function generateUUID() {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/**
 * @typedef {string | Record<string, boolean> | Array<string | Record<string, boolean>>} ClassValue
 */

/**
 * A set of HTML tags that are self-closing (void elements).
 * @type {Set<string>}
 */
export const voidElements = new Set([
  'area',
  'base',
  'br',
  'col',
  'embed',
  'hr',
  'img',
  'input',
  'link',
  'meta',
  'param',
  'source',
  'track',
  'wbr',
]);

/**
 * Normalizes a class attribute value into a single space-separated string.
 * It can handle string, object, and array formats for defining classes.
 *
 * @example
 * normalizeClass('foo bar');
 * normalizeClass({ foo: true, bar: false, baz: true });
 * normalizeClass(['foo', { bar: true }]);
 *
 * @param {ClassValue} value - The class value to normalize.
 * @returns {string} The normalized class string.
 */
export function normalizeClass(value) {
  let res = '';
  if (isString(value)) {
    res = value;
  } else if (Array.isArray(value)) {
    for (const item of value) {
      const normalized = normalizeClass(/** @type {ClassValue} */ (item));
      if (normalized) res += normalized + ' ';
    }
  } else if (isObject(value)) {
    for (const key in value) {
      if (value[key]) res += key + ' ';
    }
  }
  return res.trim();
}

---------- END: shared/utils.js ----------
