========== SOURCE FILES ==========

---------- START: client/db.client.js ----------
/**
 * @file Orchestrates the client-side IndexedDB instance, providing a high-level API for schema management, transactional operations, and data access.
 */

import { createLogger } from '../developer/logger.js';
import { session } from './runtime.js';

/**
 * @typedef {object} IndexSchema
 * @property {string} name - The name of the index.
 * @property {string | string[]} keyPath - The key path for the index.
 * @property {IDBIndexParameters} [options] - Options for the index (e.g., unique, multiEntry).
 */

/**
 * @typedef {object} TableSchema
 * @property {string} name - The name of the object store.
 * @property {string | string[]} keyPath - The key path for the object store.
 * @property {boolean} [autoIncrement] - Whether the key should be auto-incrementing.
 * @property {IndexSchema[]} [indexes] - An array of index definitions for the object store.
 * @property {boolean} [sync] - Whether the table should be synchronized with the server.
 */

/**
 * @typedef {object} DbConfig
 * @property {number} version - The version of the database schema.
 * @property {TableSchema[]} clientTables - An array of table schemas for the client-side database.
 */

/**
 * @typedef {object} DbTableApi
 * @property {(key: IDBValidKey) => Promise<any | null | undefined>} get - Retrieves a single record by its primary key.
 * @property {() => Promise<any[] | undefined>} getAll - Retrieves all records from the table.
 * @property {(prefix: string) => Promise<any[] | undefined>} findByPrefix - Retrieves records whose primary key starts with a given prefix.
 * @property {(indexName: string, query: IDBValidKey | IDBKeyRange) => Promise<any[] | undefined>} query - Queries the table using a specified index.
 * @property {(record: object) => Promise<void>} put - Adds or updates a record in the table.
 * @property {(records: object[]) => Promise<void>} bulkPut - Adds or updates multiple records in the table.
 * @property {(key: IDBValidKey) => Promise<void>} delete - Deletes a record by its primary key.
 * @property {(callback: () => void) => () => void} subscribe - Subscribes to changes in the table.
 * @property {() => Promise<void | undefined>} clear - Clears all records from the table.
 */

const logger = createLogger('[DB]');

const DB_NAME = 'webs-local-db';

/**
 * @internal
 * @type {Promise<IDBDatabase | null> | null}
 * A promise that resolves with the database instance.
 */
let dbPromise = null;

/**
 * @internal
 * @type {import('./sync-engine.js').SyncEngine | null} A reference to the synchronization engine.
 */
let syncEngineRef = null;

/**
 * @internal
 * Promisifies an IDBRequest, providing a modern async/await-compatible interface for IndexedDB's event-based operations.
 * @template T
 * @param {IDBRequest<T>} request The IndexedDB request.
 * @returns {Promise<T>} A promise that resolves with the request's result or rejects with its error.
 */
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

/**
 * @internal
 * Opens and initializes the IndexedDB database.
 * @param {DbConfig} config The database configuration.
 * @returns {Promise<IDBDatabase | null>} A promise that resolves with the database instance.
 */
function openDB(config) {
  if (typeof window === 'undefined' || !window.indexedDB) {
    return Promise.resolve(null);
  }
  if (dbPromise) return dbPromise;
  logger.log('Opening IndexedDB...');
  dbPromise = new Promise((resolve, reject) => {
    const version = config?.version || 1;
    const request = window.indexedDB.open(DB_NAME, version);

    request.onerror = (e) => {
      logger.error('IndexedDB error:', /** @type {any} */ (e.target).error);
      reject(/** @type {any} */ (e.target).error);
    };
    request.onsuccess = () => {
      logger.log('IndexedDB opened successfully.');
      resolve(request.result);
    };

    request.onupgradeneeded = (e) => {
      logger.log('IndexedDB upgrade needed.', {
        oldVersion: e.oldVersion,
        newVersion: e.newVersion,
      });
      const db = /** @type {IDBDatabase} */ (
        /** @type {any} */ (e.target).result
      );
      const tx = /** @type {IDBTransaction} */ (
        /** @type {any} */ (e.target).transaction
      );

      if (!db.objectStoreNames.contains('outbox')) {
        logger.debug("Creating 'outbox' object store.");
        db.createObjectStore('outbox', { keyPath: 'opId' });
      }

      config?.clientTables?.forEach((tableSchema) => {
        if (!db.objectStoreNames.contains(tableSchema.name)) {
          logger.debug(`Creating '${tableSchema.name}' object store.`);
          const store = db.createObjectStore(tableSchema.name, {
            keyPath: tableSchema.keyPath,
            autoIncrement: tableSchema.autoIncrement,
          });
          tableSchema.indexes?.forEach((index) =>
            store.createIndex(index.name, index.keyPath, index.options),
          );
        } else {
          logger.debug(
            `Checking indexes for '${tableSchema.name}' object store.`,
          );
          if (tx) {
            const store = tx.objectStore(tableSchema.name);
            const existingIndices = new Set(store.indexNames);
            tableSchema.indexes?.forEach((index) => {
              if (!existingIndices.has(index.name)) {
                logger.debug(
                  `Creating index '${index.name}' on '${tableSchema.name}'.`,
                );
                store.createIndex(index.name, index.keyPath, index.options);
              }
            });
          }
        }
      });
    };
  });
  return dbPromise;
}

/**
 * @internal
 * @type {Map<string, Set<() => void>>}
 * A map of table names to their subscriber callback functions.
 */
const tableSubscribers = new Map();

/**
 * Notifies all subscribers for a given table that its data has changed.
 * @param {string} tableName The name of the table that was updated.
 */
export function notify(tableName) {
  logger.debug(`Notifying subscribers for table: ${tableName}`);
  tableSubscribers.get(tableName)?.forEach((callback) => callback());
}

/**
 * The core database object containing low-level methods.
 * @internal
 */
export const coreDB = {
  /** @type {Promise<IDBDatabase | null> | null} */
  db: null,
  _getDB() {
    if (!this.db) {
      this.db = openDB(/** @type {any} */ (window).__WEBS_DB_CONFIG__);
    }
    return this.db;
  },

  /**
   * Sets a reference to the sync engine for push notifications.
   * @param {import('./sync-engine.js').SyncEngine} engine The sync engine instance.
   */
  setSyncEngine(engine) {
    syncEngineRef = engine;
  },

  /**
   * Performs an IndexedDB transaction.
   * @template T
   * @param {string | string[]} tableNames The name(s) of the object stores to include in the transaction.
   * @param {IDBTransactionMode} mode The transaction mode ('readonly' or 'readwrite').
   * @param {(tx: IDBTransaction) => T | Promise<T>} action The function to execute within the transaction context.
   * @returns {Promise<T | undefined>} A promise that resolves with the result of the action.
   */
  async transaction(tableNames, mode, action) {
    const db = await this._getDB();
    if (!db) return undefined;
    const tableNamesArray = Array.isArray(tableNames)
      ? tableNames
      : [tableNames];

    const tx = db.transaction(tableNamesArray, mode);

    const transactionPromise = new Promise((resolve, reject) => {
      tx.oncomplete = () => {
        resolve(undefined);
      };
      tx.onerror = () => {
        reject(tx.error);
      };
      tx.onabort = () => {
        reject(new Error('Transaction aborted'));
      };
    });

    try {
      const actionResult = await action(tx);
      await transactionPromise;
      return actionResult;
    } catch (err) {
      tx.abort();
      throw err;
    }
  },

  /**
   * @param {string} tableName
   * @param {IDBValidKey} key
   */
  get: (tableName, key) =>
    coreDB.transaction(tableName, 'readonly', (tx) =>
      promisifyRequest(tx.objectStore(tableName).get(key)),
    ),

  /** @param {string} tableName */
  getAll: (tableName) =>
    coreDB.transaction(tableName, 'readonly', (tx) =>
      promisifyRequest(tx.objectStore(tableName).getAll()),
    ),

  /**
   * @param {string} tableName
   * @param {string} prefix
   */
  findByPrefix: (tableName, prefix) =>
    coreDB.transaction(tableName, 'readonly', (tx) => {
      const store = tx.objectStore(tableName);
      const range = IDBKeyRange.bound(prefix, prefix + '\uffff');
      return promisifyRequest(store.getAll(range));
    }),

  /**
   * @param {string} tableName
   * @param {string} indexName
   * @param {IDBValidKey | IDBKeyRange} query
   */
  query: (tableName, indexName, query) =>
    coreDB.transaction(tableName, 'readonly', (tx) => {
      const store = tx.objectStore(tableName);
      const index = store.index(indexName);
      return promisifyRequest(index.getAll(query));
    }),

  /**
   * @param {string} tableName
   * @param {any} record
   */
  put: async (tableName, record) => {
    const tableConfig = /** @type {any} */ (
      window
    ).__WEBS_DB_CONFIG__?.clientTables.find(
      (/** @type {TableSchema} */ t) => t.name === tableName,
    );
    const isSynced = tableConfig?.sync;
    const tables = isSynced ? [tableName, 'outbox'] : [tableName];

    const recordWithUser = {
      ...record,
      user_id: record.user_id || session.user?.id,
    };

    await coreDB.transaction(tables, 'readwrite', (tx) => {
      tx.objectStore(tableName).put(recordWithUser);
      if (isSynced) {
        const op = {
          tableName,
          type: 'put',
          data: recordWithUser,
          opId: crypto.randomUUID(),
        };
        tx.objectStore('outbox').add(op);
      }
    });
    if (isSynced && syncEngineRef) syncEngineRef.process();
    notify(tableName);
  },

  /**
   * @param {string} tableName
   * @param {object[]} records
   */
  bulkPut: async (tableName, records) => {
    if (!records || records.length === 0) return;
    await coreDB.transaction(tableName, 'readwrite', (tx) => {
      const store = tx.objectStore(tableName);
      records.forEach((record) => store.put(record));
    });
    notify(tableName);
  },

  /**
   * @param {string} tableName
   * @param {IDBValidKey} key
   */
  delete: async (tableName, key) => {
    const tableConfig = /** @type {any} */ (
      window
    ).__WEBS_DB_CONFIG__?.clientTables.find(
      (/** @type {TableSchema} */ t) => t.name === tableName,
    );
    const isSynced = tableConfig?.sync;
    const tables = isSynced ? [tableName, 'outbox'] : [tableName];

    await coreDB.transaction(tables, 'readwrite', (tx) => {
      tx.objectStore(tableName).delete(key);
      if (isSynced) {
        const op = {
          tableName,
          type: 'delete',
          id: key,
          opId: crypto.randomUUID(),
        };
        tx.objectStore('outbox').add(op);
      }
    });
    if (isSynced && syncEngineRef) syncEngineRef.process();
    notify(tableName);
  },

  /** @param {string} tableName */
  clear: (tableName) =>
    coreDB.transaction(tableName, 'readwrite', async (tx) => {
      await promisifyRequest(tx.objectStore(tableName).clear());
      notify(tableName);
    }),

  /**
   * @param {string} tableName
   * @param {() => void} callback
   * @returns {() => void} An unsubscribe function.
   */
  subscribe: (tableName, callback) => {
    if (!tableSubscribers.has(tableName)) {
      tableSubscribers.set(tableName, new Set());
    }
    tableSubscribers.get(tableName)?.add(callback);
    return () => tableSubscribers.get(tableName)?.delete(callback);
  },

  /**
   * Handles incoming sync messages from the server.
   * @param {object} message
   * @param {string} message.tableName
   * @param {'put' | 'delete'} message.type
   * @param {object} [message.data]
   * @param {IDBValidKey} [message.id]
   */
  handleSyncMessage: async ({ tableName, type, data, id }) => {
    logger.log(`Handling incoming sync message`, { tableName, type, data, id });
    await coreDB.transaction(tableName, 'readwrite', (tx) => {
      const store = tx.objectStore(tableName);
      if (type === 'put' && data) {
        store.put(data);
      } else if (type === 'delete' && id !== undefined) {
        store.delete(id);
      }
    });
    notify(tableName);
  },
};

/**
 * A wrapper around `coreDB.transaction` for external use.
 * @template T
 * @param {string | string[]} tableNames The name(s) of the object stores.
 * @param {IDBTransactionMode} mode The transaction mode.
 * @param {(tx: IDBTransaction) => T | Promise<T>} action The function to execute.
 * @returns {Promise<T | undefined>} A promise that resolves with the result of the action.
 */
export function transaction(tableNames, mode, action) {
  return coreDB.transaction(tableNames, mode, action);
}

/**
 * @internal
 * Creates a no-op stub of the database API for server-side rendering (SSR) environments, ensuring isomorphic code compatibility.
 * @returns {DbTableApi}
 */
function createSsrDbMock() {
  const fn = () => Promise.resolve();
  const getFn = () => Promise.resolve(null);
  const empty = () => Promise.resolve([]);
  return {
    get: getFn,
    getAll: empty,
    findByPrefix: empty,
    query: empty,
    put: fn,
    bulkPut: fn,
    delete: fn,
    subscribe: () => () => {},
    clear: fn,
  };
}

/**
 * Returns a high-level API for interacting with a specific database table.
 * @param {string} tableName The name of the table to interact with.
 * @returns {DbTableApi} An object with methods for interacting with the specified table.
 */
export function db(tableName) {
  if (typeof window === 'undefined') {
    return createSsrDbMock();
  }
  if (!tableName) throw new Error('db() requires a table name.');

  return {
    get: (key) => coreDB.get(tableName, key),
    getAll: () => coreDB.getAll(tableName),
    findByPrefix: (prefix) => coreDB.findByPrefix(tableName, prefix),
    query: (indexName, query) => coreDB.query(tableName, indexName, query),
    put: (record) => coreDB.put(tableName, record),
    bulkPut: (records) => coreDB.bulkPut(tableName, records),
    delete: (key) => coreDB.delete(tableName, key),
    subscribe: (callback) => coreDB.subscribe(tableName, callback),
    clear: () => coreDB.clear(tableName),
  };
}

/**
 * Resets the database state for testing purposes.
 * @internal
 */
export function _resetDBForTests() {
  dbPromise = null;
  coreDB.db = null;
  tableSubscribers.clear();
}

---------- END: client/db.client.js ----------

---------- START: client/runtime.js ----------
export { createApp, hydrate, router, route } from '../core/core.js';
export {
  state,
  ref,
  effect,
  computed,
  store,
  isRef,
  RAW_SYMBOL,
} from '../core/reactivity.js';
export {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onUnmounted,
  onReady,
  onPropsReceived,
  provide,
  inject,
} from '../core/component.js';
export {
  h,
  Text,
  Comment,
  Fragment,
  Teleport,
  createVnode,
} from '../core/vdom.js';
export { compile, compileCache } from '../renderer/compiler.js';

export { db } from './db.client.js';
export { fs } from './fs.client.js';
export { syncEngine } from './sync-engine.js';
export { session } from './session.js';
export { action, table } from './hooks.js';

export { ai, useConversation } from '../ai/ai.client.js';

/** JSDoc Type Definitions for consumers of the framework **/

/**
 * @template T
 * @typedef {import('../core/reactivity.js').ReactiveProxy<T>} ReactiveProxy
 */

/**
 * @typedef {import('./session.js').User} User
 */

/**
 * @typedef {import('./session.js').SessionState} SessionState
 */

/**
 * @typedef {import('./session.js').SessionGetters} SessionGetters
 */

/**
 * @typedef {import('./session.js').SessionActions} SessionActions
 */

/**
 * @typedef {import('./session.js').Session} Session
 */

/**
 * @typedef {import('./hooks.js').TableState} TableState
 */

/**
 * @template T
 * @typedef {ReactiveProxy<{ data: T | null; isLoading: boolean; error: Error | null; }> & { write: (content: any, options?: import('./fs.client.js').FsOperationOptions) => Promise<void>, rm: (options?: import('./fs.client.js').FsOperationOptions) => Promise<void> }} UseFsState
 */

/**
 * @typedef {'connecting' | 'open' | 'closed'} SocketStatus
 */

/**
 * @typedef {object} SocketState
 * @property {SocketStatus} status - The current status of the WebSocket connection.
 * @property {any} data - The most recent message received from the server.
 * @property {Error | null} error - Any error that occurred with the connection.
 */

/**
 * @typedef {object} UseSocketReturn
 * @property {ReactiveProxy<SocketState>} state - The reactive state of the WebSocket.
 * @property {(data: any) => void} send - A function to send data to the server.
 * @property {() => void} close - A function to manually close the connection.
 */

/**
 * @typedef {import('../ai/ai.client.js').UseConversationReturn} UseConversationReturn
 */

---------- END: client/runtime.js ----------

---------- START: client/session.js ----------
import { store } from '../core/reactivity.js';
import { createLogger } from '../developer/logger.js';

/**
 * @typedef {object} User
 * @property {number} id
 * @property {string} username
 * @property {string} email
 */

/**
 * @typedef {object} SessionState
 * @property {User | null} user
 * @property {string | null} error
 * @property {boolean} isReady
 */

/**
 * @typedef {object} SessionGetters
 * @property {() => boolean} isLoggedIn
 */

/**
 * @typedef {object} SessionActions
 * @property {(credentials: {email: string, username: string, password: string}) => Promise<void>} register
 * @property {(email: string, password: string) => Promise<User | undefined>} login
 * @property {() => Promise<void>} logout
 * @property {(user: User | null) => void} setUser
 */

/**
 * @typedef {import('../core/reactivity.js').ReactiveProxy<SessionState> & SessionGetters & SessionActions} Session
 */

const sessionLogger = createLogger('[Session]');

/**
 * The session management object.
 * @type {Session}
 */
export const session = store({
  state: () => ({
    user: null,
    error: null,
    isReady: false,
  }),
  getters: {
    /**
     * @this {SessionState}
     * @returns {boolean}
     */
    isLoggedIn() {
      return !!this.user;
    },
  },
  actions: {
    /**
     * @this {SessionState}
     * @param {User | null} user
     */
    setUser(user) {
      this.user = user || null;
      this.isReady = true;
    },
    /**
     * @this {SessionState & SessionActions}
     * @param {{email: string, username: string, password: string}} credentials
     */
    async register({ email, username, password }) {
      this.error = null;
      try {
        const response = await fetch('/api/auth/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, username, password }),
        });
        if (!response.ok)
          throw new Error((await response.text()) || 'Registration failed');
      } catch (err) {
        this.error = /** @type {Error} */ (err).message;
        sessionLogger.error('Registration failed:', err);
        throw err;
      }
    },
    /**
     * @this {SessionState & SessionActions}
     * @param {string} email
     * @param {string} password
     * @returns {Promise<User | undefined>}
     */
    async login(email, password) {
      this.error = null;
      try {
        const response = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password }),
        });
        if (!response.ok)
          throw new Error((await response.text()) || 'Login failed');
        const userData = await response.json();
        this.user = userData;
        return userData;
      } catch (err) {
        this.error = /** @type {Error} */ (err).message;
        sessionLogger.error('Login failed:', err);
        throw err;
      }
    },
    /** @this {SessionState & SessionActions} */
    async logout() {
      try {
        await fetch('/api/auth/logout', { method: 'POST' });
        this.user = null;
        this.error = null;
      } catch (err) {
        sessionLogger.error('Logout failed:', err);
      }
    },
  },
});

---------- END: client/session.js ----------

---------- START: client/hooks.js ----------
import { state } from '../core/reactivity.js';
import { db } from './db.client.js';
import { onMounted, onUnmounted } from '../core/component.js';

/**
 * @template T
 * @typedef {import('../core/reactivity.js').ReactiveProxy<T>} ReactiveProxy
 */

/**
 * @typedef {ReactiveProxy<{data: any[], isLoading: boolean, error: Error | null}> & {
 * hydrate: (serverData: any[]) => Promise<void>,
 * put: (record: any) => Promise<void>,
 * destroy: (key: any) => Promise<void>
 * }} TableState
 */

/**
 * A composable for calling server-side actions on a component.
 * @param {string} actionName - The name of the action function to call.
 * @param {string} [componentName] - The name of the component where the action is defined.
 */
export function action(actionName, componentName) {
  if (typeof window === 'undefined')
    return { call: () => Promise.resolve(null), state: {} };

  /** @type {import('../core/reactivity.js').ReactiveProxy<{data: any, error: Error | null, isLoading: boolean}>} */
  const s = state({ data: null, error: null, isLoading: false });

  /** @param {any[]} args */
  const call = async (...args) => {
    s.isLoading = true;
    s.error = null;
    s.data = null;
    try {
      const finalCompName =
        componentName ||
        /** @type {any} */ (window).__WEBS_STATE__?.componentName;
      const res = await fetch(`/__actions__/${finalCompName}/${actionName}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(args),
      });
      if (!res.ok)
        throw new Error((await res.text()) || `Action failed: ${res.status}`);
      s.data = await res.json();
    } catch (err) {
      s.error = err instanceof Error ? err : new Error(String(err));
    } finally {
      s.isLoading = false;
    }
  };
  return { call, state: s };
}

/**
 * A composable for interacting with a client-side database table.
 * @param {string} tableName - The name of the database table.
 * @param {any[]} [initialData=[]] - Optional initial data to populate the state.
 * @returns {TableState} A reactive state object with methods to interact with the table.
 */
export function table(tableName, initialData = []) {
  const tableDB = db(tableName);
  if (typeof window === 'undefined') {
    const mock = state({ data: initialData, isLoading: false, error: null });
    const mockWithMethods = /** @type {TableState} */ (
      /** @type {any} */ (mock)
    );
    mockWithMethods.hydrate = async () => {};
    mockWithMethods.put = async () => {};
    mockWithMethods.destroy = async () => {};
    return mockWithMethods;
  }

  const s = state({
    data: initialData || [],
    isLoading: true,
    error: /** @type {Error | null} */ (null),
  });

  const fetchData = async () => {
    try {
      s.isLoading = true;
      s.data = (await tableDB.getAll()) || [];
    } catch (e) {
      s.error = /** @type {Error} */ (e);
    } finally {
      s.isLoading = false;
    }
  };

  const unsubscribe = tableDB.subscribe(fetchData);
  onUnmounted(unsubscribe);

  const sWithMethods = /** @type {TableState} */ (/** @type {any} */ (s));

  /** @param {any[]} serverData */
  sWithMethods.hydrate = async (serverData) => {
    if (serverData && Array.isArray(serverData)) {
      await tableDB.bulkPut(serverData);
    }
    await fetchData();
  };

  sWithMethods.put = tableDB.put;
  sWithMethods.destroy = tableDB.delete;

  onMounted(async () => {
    if (!initialData || initialData.length === 0) {
      await fetchData();
    } else {
      s.isLoading = false;
    }
  });

  return sWithMethods;
}

---------- END: client/hooks.js ----------

---------- START: client/sync-engine.js ----------
/**
 * @file Manages data synchronization between the client and server using WebSockets.
 */

import { createLogger } from '../developer/logger.js';
import { effect } from '../core/reactivity.js';
import { session } from './runtime.js';

/**
 * @typedef {object} SyncEngine
 * @property {(db: import('./db.client.js').coreDB) => void} init - Initializes the sync engine with a reference to the database module.
 * @property {() => void} start - Starts the sync engine, sets up listeners for online/offline events, and user authentication state.
 * @property {() => void} process - Manually triggers the outbox processing logic.
 * @property {(message: any) => void} send - Sends a message directly through the WebSocket connection, bypassing the outbox.
 * @property {(event: 'message', callback: (payload: any) => void) => () => void} addEventListener - Adds an event listener for sync engine events.
 */

const logger = createLogger('[Sync]');

/** @type {WebSocket | null} */
let socket = null;
/** @type {ReturnType<typeof setTimeout> | null} */
let reconnectTimeout = null;
/** @type {number} */
let reconnectAttempts = 0;
/** @type {boolean} */
let isProcessingOutbox = false;
/** @type {import('./db.client.js').coreDB | null} */
let dbModule = null;

/**
 * @internal
 * A lightweight event emitter for handling synchronization events within the engine.
 */
const eventEmitter = {
  /** @type {Map<string, Set<Function>>} */
  listeners: new Map(),
  /**
   * @param {string} event
   * @param {Function} callback
   * @returns {() => void} Unsubscribe function.
   */
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.add(callback);
      return () => eventListeners.delete(callback);
    }
    return () => {};
  },
  /**
   * @param {string} event
   * @param {any} data
   */
  emit(event, data) {
    this.listeners.get(event)?.forEach((cb) => cb(data));
  },
};

/**
 * @internal
 * Establishes a WebSocket connection to the sync server.
 */
function connectToSyncServer() {
  if (socket?.readyState === WebSocket.OPEN) {
    processOutbox();
    return;
  }
  if (typeof navigator !== 'undefined' && !navigator.onLine) {
    logger.log('Offline, cannot connect to sync server.');
    return;
  }
  if (reconnectTimeout) clearTimeout(reconnectTimeout);

  logger.log('Attempting to connect to sync server...');
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const url = `${protocol}//${window.location.host}/api/sync`;
  socket = new WebSocket(url);

  socket.onopen = () => {
    logger.log('Sync server connection established.');
    reconnectAttempts = 0;
    processOutbox();
  };

  socket.onmessage = async (event) => {
    const payload = JSON.parse(event.data);
    logger.debug('Received message from sync server:', payload);
    eventEmitter.emit('message', payload);
    if (payload.type === 'sync' && dbModule) {
      await dbModule.handleSyncMessage(payload.data);
    } else if (payload.type === 'ack' || payload.type === 'sync-error') {
      if (payload.type === 'sync-error') {
        logger.error('Sync error from server:', payload);
      }
      if (dbModule) {
        await dbModule.transaction(
          'outbox',
          'readwrite',
          (/** @type {IDBTransaction} */ tx) => {
            tx.objectStore('outbox').delete(payload.opId);
          },
        );
      }
      processOutbox();
    }
  };

  socket.onclose = (event) => {
    logger.warn('Sync server connection closed.', {
      code: event.code,
      reason: event.reason,
    });
    socket = null;
    if (event.code !== 1000) {
      reconnectAttempts++;
      const delay = Math.min(30000, 1000 * 2 ** reconnectAttempts);
      logger.log(`Will attempt to reconnect in ${delay}ms.`);
      reconnectTimeout = setTimeout(connectToSyncServer, delay);
    }
  };

  socket.onerror = (err) => {
    logger.error('Sync server connection error:', err);
    socket?.close();
  };
}

/**
 * @internal
 * Processes and sends pending operations from the 'outbox' object store.
 * @returns {Promise<void>}
 */
async function processOutbox() {
  if (isProcessingOutbox || socket?.readyState !== WebSocket.OPEN) {
    logger.debug('Skipping outbox processing.', {
      isProcessingOutbox,
      socketState: socket?.readyState,
    });
    return;
  }

  if (!dbModule) return;

  const db = await dbModule._getDB();
  if (!db) return;

  isProcessingOutbox = true;
  try {
    await dbModule.transaction(
      'outbox',
      'readonly',
      async (/** @type {IDBTransaction} */ tx) => {
        const store = tx.objectStore('outbox');
        const request = store.openCursor();

        return new Promise((resolve, reject) => {
          let itemSent = false;
          request.onsuccess = (/** @type {Event} */ e) => {
            const cursor = /** @type {any} */ (e.target).result;
            if (cursor && !itemSent) {
              itemSent = true;
              const op = cursor.value;
              logger.log('Processing and sending operation from outbox:', op);
              socket?.send(JSON.stringify(op));
            }
            resolve(undefined);
          };
          request.onerror = (/** @type {Event} */ e) =>
            reject(/** @type {any} */ (e.target).error);
        });
      },
    );
  } catch (err) {
    logger.error('Error processing outbox:', err);
  } finally {
    isProcessingOutbox = false;
  }
}

/**
 * The main sync engine API.
 * @type {SyncEngine}
 */
export const syncEngine = {
  /**
   * Initializes the sync engine with a reference to the database module.
   * @param {import('./db.client.js').coreDB} db - The core DB module.
   */
  init(db) {
    dbModule = db;
  },
  /**
   * Starts the sync engine, sets up listeners for online/offline events, and user authentication state.
   */
  start() {
    if (typeof window === 'undefined') return;

    effect(
      () => session.user,
      (
        /** @type {import('./runtime.js').User | null} */ newUser,
        /** @type {import('./runtime.js').User | null} */ oldUser,
      ) => {
        if (newUser && !oldUser) {
          logger.log('User logged in, starting sync engine.');
          connectToSyncServer();
        } else if (oldUser && !newUser) {
          logger.log('User logged out, stopping sync engine.');
          if (socket) {
            socket.close(1000, 'User logged out');
          }
        }
      },
    );

    window.addEventListener('online', () => {
      logger.log('Browser is online.');
      if (session.user) connectToSyncServer();
    });
    window.addEventListener('offline', () => {
      logger.log('Browser is offline.');
      if (socket) {
        socket.close(1000, 'Network offline');
      }
    });
  },
  /**
   * Manually triggers the outbox processing logic.
   */
  process: () => {
    setTimeout(() => {
      if (typeof navigator !== 'undefined' && navigator.onLine) processOutbox();
    }, 100);
  },
  /**
   * Sends a message directly through the WebSocket connection, bypassing the outbox.
   * @param {any} message - The message to send.
   */
  send: (message) => {
    if (socket?.readyState === WebSocket.OPEN)
      socket.send(JSON.stringify(message));
  },
  /**
   * Adds an event listener for sync engine events.
   * @param {'message'} event - The event to listen for.\
   * @param {(payload: any) => void} callback - The callback function.
   * @returns {() => void} An unsubscribe function.
   */
  addEventListener: (event, callback) => {
    return eventEmitter.on(event, callback);
  },
};

---------- END: client/sync-engine.js ----------

---------- START: client/service-worker.js ----------
/**
 * @file Service worker for caching application assets and enabling offline functionality.
 * @global
 * @property {boolean} IS_PROD - A global flag indicating if the environment is production.
 * @property {Array<{url: string}>} __WEBS_MANIFEST - A global variable injected by the build process, containing the list of assets to cache.
 */

/// <reference lib="WebWorker" />

/**
 * @typedef {ServiceWorkerGlobalScope & typeof globalThis & { IS_PROD: boolean; __WEBS_MANIFEST: Array<{url: string}>}} ServiceWorkerWithCustomGlobals
 */

const sw = /** @type {ServiceWorkerWithCustomGlobals} */ (
  /** @type {unknown} */ (self)
);

const CACHE_NAME = 'webs-cache-v1';

const APP_SHELL_URL = '/';

const fullManifest = sw.__WEBS_MANIFEST || [];

const assetUrls = fullManifest
  .filter((entry) => entry.url.includes('.'))
  .map((entry) => entry.url);

const urlsToCache = [APP_SHELL_URL, ...assetUrls];

sw.addEventListener('install', (event) => {
  if (typeof sw.IS_PROD !== 'undefined' && !sw.IS_PROD) {
    console.log('[SW] Development mode: skipping caching on install.');
    return event.waitUntil(sw.skipWaiting());
  }

  console.log('[SW] Production mode: Caching app shell and assets on install.');
  event.waitUntil(
    caches
      .open(CACHE_NAME)
      .then((cache) => {
        console.log('[SW] Caching:', urlsToCache);
        return cache.addAll(urlsToCache);
      })
      .then(() => sw.skipWaiting()),
  );
});

sw.addEventListener('activate', (event) => {
  console.log('[SW] Activating new service worker...');
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((name) => name !== CACHE_NAME)
            .map((name) => {
              console.log(`[SW] Deleting old cache: ${name}`);
              return caches.delete(name);
            }),
        );
      })
      .then(() => sw.clients.claim()),
  );
});

sw.addEventListener('fetch', (event) => {
  if (typeof sw.IS_PROD !== 'undefined' && !sw.IS_PROD) {
    return;
  }

  const { request } = event;
  const url = new URL(request.url);

  if (request.method !== 'GET' || url.origin !== sw.location.origin) {
    return;
  }

  if (request.mode === 'navigate') {
    event.respondWith(
      fetch(request)
        .then((response) => {
          if (response.ok) {
            const resClone = response.clone();
            caches
              .open(CACHE_NAME)
              .then((cache) => cache.put(APP_SHELL_URL, resClone));
          }
          return response;
        })
        .catch(async () => {
          console.warn(
            '[SW] Network unavailable for navigation. Serving app shell from cache.',
          );
          const cachedResponse = await caches.match(APP_SHELL_URL);
          return (
            cachedResponse ||
            new Response('App shell not found in cache', { status: 404 })
          );
        }),
    );
    return;
  }

  event.respondWith(
    caches.open(CACHE_NAME).then(async (cache) => {
      const cachedResponse = await cache.match(request);

      const fetchedResponsePromise = fetch(request)
        .then((networkResponse) => {
          if (networkResponse.ok) {
            cache.put(request, networkResponse.clone());
          }
          return networkResponse;
        })
        .catch((err) => {
          console.warn(`[SW] Network request for ${request.url} failed.`, err);
          return (
            cachedResponse ||
            new Response('Network error', {
              status: 408,
              headers: { 'Content-Type': 'text/plain' },
            })
          );
        });

      return cachedResponse || fetchedResponsePromise;
    }),
  );
});

---------- END: client/service-worker.js ----------

---------- START: client/fs.client.js ----------
/**
 * @file Client-side file system abstraction over IndexedDB.
 */

import { session } from './runtime.js';
import { db, transaction, notify } from './db.client.js';
import { createLogger } from '../developer/logger.js';

/**
 * @typedef {object} FsOperationOptions
 * @property {'private' | 'public'} [access] - The access level of the file.
 */

/**
 * @typedef {object} DirectoryEntry
 * @property {string} name - The name of the file or directory.
 * @property {boolean} isDirectory - True if the entry is a directory.
 * @property {string} path - The full path of the entry.
 */

/**
 * @typedef {object} FsApi
 * @property {() => Promise<any | null>} read - Reads the content of a file. Throws if used on a directory path.
 * @property {() => Promise<DirectoryEntry[]>} ls - Lists the contents of a directory. Throws if used on a file path.
 * @property {(content: any, options?: FsOperationOptions) => Promise<void>} write - Writes content to a file. Throws if used on a directory path.
 * @property {(options?: FsOperationOptions) => Promise<void>} rm - Removes a file or directory.
 */

const logger = createLogger('[FS]');

/**
 * @internal
 * Core file system logic that directly interacts with the database.
 */
export const coreFS = {
  /**
   * Reads the content of a file.
   * @param {string} path - The path to the file.
   * @returns {Promise<any | null>} A promise that resolves with the file content, or null if not found.
   */
  readFile: (path) =>
    db('files')
      .get(path)
      .then((file) => (file ? file.content : null)),

  /**
   * Lists the contents of a directory.
   * @param {string} path - The path to the directory.
   * @returns {Promise<DirectoryEntry[]>} A promise that resolves with an array of directory entries.
   */
  listDirectory: async (path) => {
    logger.debug(`[FS] Listing directory: "${path}"`);
    const normalizedPath = path.replace(/\/$/, '');
    const prefix = normalizedPath ? `${normalizedPath}/` : '';
    const allFiles = (await db('files').findByPrefix(prefix)) || [];
    const directChildren = new Map();

    for (const file of allFiles) {
      if (!file.path.startsWith(prefix)) continue;

      const relativePath = file.path.substring(prefix.length);
      const segments = relativePath.split('/');
      const childName = segments[0];

      if (!childName) continue;

      if (!directChildren.has(childName)) {
        const isDirectory = segments.length > 1;
        directChildren.set(childName, {
          name: childName,
          isDirectory: isDirectory,
          path: isDirectory ? `${prefix}${childName}` : file.path,
        });
      }
    }
    const result = Array.from(directChildren.values()).sort((a, b) =>
      a.name.localeCompare(b.name),
    );
    logger.debug(`[FS] Directory listing for "${path}" result:`, result);
    return result;
  },

  /**
   * Creates a file system operation and adds it to the outbox for synchronization.
   * @param {object} payload - The operation payload.
   * @param {'fs:write' | 'fs:rm'} payload.type - The type of operation.
   * @param {string} payload.path - The path of the file or directory.
   * @param {any} [payload.data] - The data for a write operation.
   * @param {FsOperationOptions} payload.options - Options for the operation.
   * @returns {Promise<void>}
   */
  async createOperation(payload) {
    if (!session.isLoggedIn || !session.user)
      throw new Error('User not logged in.');
    const op = { ...payload, opId: crypto.randomUUID() };
    logger.log(`[FS] Creating operation:`, op);

    const currentUser = session.user;
    if (!currentUser) {
      throw new Error('User session not found during transaction.');
    }

    await transaction(['files', 'outbox'], 'readwrite', (tx) => {
      const filesStore = tx.objectStore('files');
      const outboxStore = tx.objectStore('outbox');

      if (op.type === 'fs:write') {
        filesStore.put({
          path: op.path,
          content: op.data,
          user_id: currentUser.id,
          access: op.options.access || 'private',
          size: op.data?.length || 0,
          last_modified: new Date().toISOString(),
        });
      } else if (op.type === 'fs:rm') {
        const key =
          typeof op.path === 'string'
            ? { path: op.path, user_id: currentUser.id }
            : op.path;
        filesStore.delete([key.path, key.user_id]);
      }
      outboxStore.add(op);
    });

    notify('files');
  },
};

/**
 * Provides a high-level API for direct, non-reactive interaction with the client-side file system.
 * @param {string | (() => string)} [path=''] - The path to a file or directory. Can be a string or a reactive getter function.
 * @returns {FsApi} An object with methods for file system interaction.
 */
export function fs(path = '') {
  if (typeof window === 'undefined') {
    return {
      read: () => Promise.resolve(null),
      ls: () => Promise.resolve([]),
      write: () => Promise.resolve(),
      rm: () => Promise.resolve(),
    };
  }

  const getIsDirectory = (/** @type {string | (() => string)} */ p) => {
    const currentPath = typeof p === 'function' ? p() : p;
    return currentPath === '' || currentPath.endsWith('/');
  };

  const methods = {
    read: () => {
      if (getIsDirectory(path))
        return Promise.reject(new Error('Cannot call .read() on a directory.'));
      const currentPath = typeof path === 'function' ? path() : path;
      return coreFS.readFile(currentPath);
    },
    ls: () => {
      if (!getIsDirectory(path))
        return Promise.reject(
          new Error(
            'Can only call .ls() on a directory path (ending with "/").',
          ),
        );
      const currentPath = typeof path === 'function' ? path() : path;
      return coreFS.listDirectory(currentPath);
    },
    /**
     * @param {any} content
     * @param {FsOperationOptions} [options]
     */
    write: (content, options = { access: 'private' }) => {
      if (getIsDirectory(path))
        throw new Error('Cannot call .write() on a directory.');
      const currentPath = typeof path === 'function' ? path() : path;
      return coreFS.createOperation({
        type: 'fs:write',
        path: currentPath,
        data: content,
        options,
      });
    },
    /** @param {FsOperationOptions} [options] */
    rm: (options = { access: 'private' }) => {
      const currentPath = typeof path === 'function' ? path() : path;
      return coreFS.createOperation({
        type: 'fs:rm',
        path: currentPath,
        options,
      });
    },
  };

  return methods;
}

---------- END: client/fs.client.js ----------

---------- START: build/bundler.js ----------
#!/usr/bin/env bun

/**
 * @typedef {import('../server/server-config.js').Config} Config
 * @typedef {import('bun').BuildOutput} BuildOutput
 */

/**
 * Database configuration specifically for the client-side bundle.
 * @typedef {object} DbConfigForClient
 * @property {number} version - The database schema version.
 * @property {any[]} clientTables - An array of table schemas for the client-side database.
 */

/**
 * Represents a layout wrapper component entrypoint.
 * @typedef {object} LayoutWrapperEntrypoint
 * @property {string} name - The unique name of the layout wrapper.
 * @property {string} path - The path to the generated layout wrapper file.
 */
import { writeFile } from 'fs/promises';
import { join, relative, dirname, resolve, basename } from 'path';
import { createLogger } from '../developer/logger.js';
import bunPluginTailwind from 'bun-plugin-tailwind';

const logger = createLogger('[Bundler]');

/**
 * Prepares the main client-side entrypoint file.
 * @param {string[]} sourceEntrypoints - Array of paths to .webs source files.
 * @param {LayoutWrapperEntrypoint[]} layoutWrapperEntrypoints - Array of layout wrapper objects.
 * @param {DbConfigForClient} dbConfig - The database configuration.
 * @param {Config} config - The global server configuration.
 * @returns {Promise<void>}
 */
async function prepareClientEntrypoint(
  sourceEntrypoints,
  layoutWrapperEntrypoints,
  dbConfig,
  config,
) {
  const appJsDir = dirname(config.TMP_APP_JS);

  const sourceLoaderEntries = sourceEntrypoints.map((fullPath) => {
    const componentName = relative(config.SRC_DIR, fullPath)
      .replace(/\\/g, '/')
      .replace('.webs', '');

    const compiledPath = resolve(
      config.TMP_COMPILED_DIR,
      relative(config.SRC_DIR, fullPath).replace('.webs', '.js'),
    );
    let relPath = relative(appJsDir, compiledPath).replace(/\\/g, '/');

    if (!relPath.startsWith('.')) relPath = './' + relPath;

    logger.debug(
      `Adding client entry for component: '${componentName}' -> '${relPath}'`,
    );
    return `['${componentName}', () => import('${relPath}')]`;
  });

  const layoutWrapperLoaderEntries = layoutWrapperEntrypoints.map(
    ({ name, path }) => {
      let relPath = relative(appJsDir, path).replace(/\\/g, '/');
      if (!relPath.startsWith('.')) relPath = './' + relPath;

      logger.debug(
        `Adding client entry for layout wrapper: '${name}' -> '${relPath}'`,
      );
      return `['${name}', () => import('${relPath}')]`;
    },
  );

  const allLoaderEntries = [
    ...sourceLoaderEntries,
    ...layoutWrapperLoaderEntries,
  ];

  const entrypointContent = `
    import { hydrate } from '@conradklek/webs';
    const dbConfig = ${JSON.stringify({
      version: dbConfig.version,
      clientTables: dbConfig.clientTables,
    })};
    const componentLoaders = new Map([${allLoaderEntries.join(',\n    ')}]);
    hydrate(componentLoaders, dbConfig);
  `;
  await writeFile(config.TMP_APP_JS, entrypointContent);
}

/**
 * Builds the client-side JavaScript and CSS bundles.
 * @param {string[]} sourceEntrypoints - Array of paths to .webs source files.
 * @param {LayoutWrapperEntrypoint[]} layoutWrapperEntrypoints - Array of layout wrapper objects.
 * @param {string[]} publicCssEntrypoints - Array of paths to public CSS files.
 * @param {DbConfigForClient} dbConfig - The database configuration.
 * @param {Config} config - The global server configuration.
 * @returns {Promise<BuildOutput['outputs'] | null>} The build outputs or null if failed.
 */
export async function buildClientBundle(
  sourceEntrypoints,
  layoutWrapperEntrypoints,
  publicCssEntrypoints,
  dbConfig,
  config,
) {
  logger.info('Starting client bundle...');
  await prepareClientEntrypoint(
    sourceEntrypoints,
    layoutWrapperEntrypoints,
    dbConfig,
    config,
  );

  const clientBuildResult = await Bun.build({
    entrypoints: [config.TMP_APP_JS, ...publicCssEntrypoints],
    outdir: config.OUTDIR,
    target: 'browser',
    minify: config.IS_PROD,
    naming: config.IS_PROD ? '[name]-[hash].[ext]' : '[name].[ext]',
    plugins: [bunPluginTailwind],
    sourcemap: config.IS_PROD ? 'none' : 'inline',
    define: {
      'process.env.NODE_ENV': `"${process.env.NODE_ENV || 'development'}"`,
    },
  });

  if (!clientBuildResult.success) {
    logger.error('Client build failed.');
    clientBuildResult.logs.forEach((log) => console.error(log));
    return null;
  }

  logger.info('Client bundle complete.');
  return clientBuildResult.outputs;
}

/**
 * Generates the service worker file.
 * @param {BuildOutput['outputs']} buildOutputs - The outputs from the client bundle build.
 * @param {Config} config - The global server configuration.
 * @returns {Promise<string | null>} The path to the generated service worker or null.
 */
export async function generateServiceWorker(buildOutputs, config) {
  if (!buildOutputs || buildOutputs.length === 0) return null;
  logger.info('Generating service worker...');

  const swTemplatePath = resolve(config.LIB_DIR, './client/service-worker.js');
  if (!(await Bun.file(swTemplatePath).exists())) {
    logger.warn('Service worker template not found. Skipping SW generation.');
    return null;
  }
  const swTemplate = await Bun.file(swTemplatePath).text();

  const manifestForSw = JSON.stringify(
    buildOutputs
      .filter(
        (o) =>
          (o.kind === 'entry-point' || o.kind === 'chunk') &&
          (o.path.endsWith('.js') || o.path.endsWith('.css')),
      )
      .map((o) => ({ url: '/' + basename(o.path) }))
      .filter((entry) => !entry.url.includes('[...'))
      .concat({ url: '/' }),
  );
  const finalSwContent = `const IS_PROD = ${
    config.IS_PROD
  };\nself.__WEBS_MANIFEST = ${manifestForSw};\n\n${swTemplate}`;

  const swOutputPath = join(config.OUTDIR, 'sw.js');
  await writeFile(swOutputPath, finalSwContent);
  logger.info(`Service worker generated at: ${swOutputPath}`);
  return swOutputPath;
}

---------- END: build/bundler.js ----------

---------- START: build/cli.js ----------
#!/usr/bin/env bun

/**
 * @typedef {import('../server/server-config.js').Config} Config
 * @typedef {import('bun').BuildArtifact} BuildArtifact
 * @typedef {import('../ai/ai.server.js').AgentDefinition} AgentDefinition
 * @typedef {import('../server/router.js').ServerContext} ServerContext
 */

/**
 * Represents a single page component's source and compiled file paths.
 * @typedef {object} PageEntrypoint
 * @property {string} source - The absolute path to the source .webs file.
 * @property {string} compiled - The absolute path to the pre-compiled .js file in the temporary directory.
 */

/**
 * Represents the definition of a server route.
 * @typedef {object} RouteDefinition
 * @property {string} path - The URL path for the route (e.g., '/users/:id').
 * @property {object} definition - The route's handler and component information.
 * @property {any} definition.component - The compiled component (or layout wrapper) to render.
 * @property {string} definition.componentName - The unique name of the component.
 * @property {Record<string, Function>} definition.actions - Server-side actions associated with the component.
 * @property {Record<string, Function>} definition.handlers - HTTP method handlers (post, patch, etc.).
 * @property {Record<string, Function>} [definition.wsHandlers] - WebSocket lifecycle handlers.
 */

/**
 * Represents all the entrypoints and file collections required for a build.
 * @typedef {object} BuildEntries
 * @property {string[]} sourceEntrypoints - All discovered .webs source files.
 * @property {PageEntrypoint[]} pageEntrypoints - .webs files that are pages.
 * @property {string[]} publicCssEntrypoints - CSS files from the public directory.
 * @property {Array<{ name: string; path: string; }>} layoutWrapperEntrypoints - Dynamically generated layout wrapper components.
 */
import { rm, writeFile, exists } from 'fs/promises';
import { watch } from 'fs';
import { join, relative, dirname, resolve, basename } from 'path';
import {
  config as defaultConfig,
  getDbConfig,
  aiConfig as defaultAiConfig,
} from '../server/server-config.js';
import { setupDatabase } from '../server/db.server.js';
import { AI } from '../ai/ai.server.js';
import { startServer } from '../server/server.js';
import { createFetchHandler } from '../server/router.js';
import { seedDevDatabase, ensureDir } from '../server/server-setup.js';
import { createLogger } from '../developer/logger.js';
import tailwind from 'bun-plugin-tailwind';
import {
  runAnalysis,
  startAiSession,
  createLockfile,
  generateInspectionReport,
  startInteractiveShell,
  runGrep,
} from '../developer/profiler.js';

const logger = createLogger('[Main]');

/**
 * Compiles a .webs file into JavaScript.
 * @param {string} filePath
 * @param {string} componentName
 * @param {Config} config
 * @returns {Promise<{js: string, css: string}>}
 */
async function compileWebsFile(filePath, componentName, config) {
  const sourceCode = await Bun.file(filePath).text();
  const scriptMatch = /<script[^>]*>(.*?)<\/script>/s.exec(sourceCode);
  const templateMatch = /<template>(.*?)<\/template>/s.exec(sourceCode);
  const styleMatch = /<style>([\s\S]*?)<\/style>/s.exec(sourceCode);

  let scriptContent = scriptMatch?.[1]?.trim() ?? '';
  const templateContent = templateMatch?.[1]?.trim() ?? '';
  const styleContent = styleMatch?.[1]?.trim() ?? '';

  scriptContent = scriptContent.replace(
    /from\s+['"](.+?)\.webs['"]/g,
    "from '$1.js'",
  );

  const isGlobalComponent =
    config.GUI_DIR && filePath.startsWith(config.GUI_DIR);
  let registryImport = '';

  if (!isGlobalComponent) {
    const outPath = resolve(
      config.TMP_COMPILED_DIR,
      relative(config.SRC_DIR, filePath).replace('.webs', '.js'),
    );
    let relPathToRegistry = relative(
      dirname(outPath),
      config.TMP_COMPONENT_REGISTRY,
    ).replace(/\\/g, '/');
    if (!relPathToRegistry.startsWith('.'))
      relPathToRegistry = './' + relPathToRegistry;
    registryImport = `import __globalComponents from '${relPathToRegistry}';\n`;
  }

  const templateProperty = `template: ${JSON.stringify(templateContent)}`;
  const injectedProps = `name: '${componentName}', ${templateProperty}, style: ${JSON.stringify(
    styleContent,
  )}`;

  let finalScript;
  if (!scriptContent.includes('export default')) {
    finalScript = `${scriptContent}\nexport default { ${injectedProps} };`;
  } else {
    finalScript = scriptContent.replace(
      /(export default\s*\{)/,
      `$1 ${injectedProps},`,
    );
  }

  if (!isGlobalComponent) {
    if (finalScript.includes('components:')) {
      finalScript = finalScript.replace(
        /(components\s*:\s*\{)/,
        '$1 ...(__globalComponents || {}),',
      );
    } else {
      finalScript = finalScript.replace(
        /(export default\s*\{)/,
        '$1 components: __globalComponents || {},',
      );
    }
  }

  if (finalScript.includes('export default')) {
    finalScript = finalScript.replace(
      /export default (\{[\s\S]*\});?/,
      'const __webs_component_def = $1; export default __webs_component_def;',
    );
  }

  return { js: registryImport + finalScript, css: styleContent };
}
/**
 * @param {Config} config
 * @returns {Promise<BuildEntries>}
 */
async function prepareBuildFiles(config) {
  logger.info('Stage 1: Starting file pre-compilation...');
  await ensureDir(config.TMP_COMPILED_DIR);

  const websGlob = new Bun.Glob('**/*.{webs,agent.webs}');
  const cssGlob = new Bun.Glob('**/*.css');
  const sourceEntrypoints = [];
  const publicCssEntrypoints = [];
  /** @type {PageEntrypoint[]} */
  const pageEntrypoints = [];

  for await (const file of websGlob.scan(config.SRC_DIR)) {
    const fullPath = join(config.SRC_DIR, file);
    sourceEntrypoints.push(fullPath);

    const relativePath = relative(config.SRC_DIR, fullPath).replace(/\\/g, '/');
    const componentName = relativePath
      .replace('.webs', '')
      .replace('.agent', '');

    const { js } = await compileWebsFile(fullPath, componentName, config);
    const outPath = join(
      config.TMP_COMPILED_DIR,
      relativePath.replace('.webs', '.js').replace('.agent', '.'),
    );

    if (fullPath.startsWith(config.APP_DIR)) {
      pageEntrypoints.push({ source: fullPath, compiled: outPath });
    }

    await ensureDir(dirname(outPath));
    await writeFile(outPath, js);
  }

  if (await exists(config.PUB_DIR)) {
    logger.info(
      'Found src/pub directory. Adding CSS files as build entrypoints...',
    );
    for await (const file of cssGlob.scan(config.PUB_DIR)) {
      publicCssEntrypoints.push(join(config.PUB_DIR, file));
    }
  }

  logger.info('Stage 1: File pre-compilation complete.');
  return {
    sourceEntrypoints,
    pageEntrypoints,
    publicCssEntrypoints,
    layoutWrapperEntrypoints: [],
  };
}
/**
 * @param {Config} config
 */
async function generateComponentRegistry(config) {
  logger.info('Generating global component registry...');
  await ensureDir(dirname(config.TMP_COMPONENT_REGISTRY));
  const glob = new Bun.Glob('**/*.webs');
  const imports = [];
  const exports = [];

  if (await exists(config.GUI_DIR)) {
    for await (const file of glob.scan(config.GUI_DIR)) {
      const componentName = basename(file, '.webs');
      const pascalName = componentName
        .split('-')
        .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
        .join('');

      const compiledPath = resolve(
        config.TMP_COMPILED_DIR,
        'gui',
        `${componentName}.js`,
      );
      let relativePath = relative(
        dirname(config.TMP_COMPONENT_REGISTRY),
        compiledPath,
      ).replace(/\\/g, '/');
      if (!relativePath.startsWith('.')) relativePath = './' + relativePath;

      imports.push(`import ${pascalName} from '${relativePath}';`);
      exports.push(`  '${componentName}': ${pascalName}`);
    }
  }

  const content = `${imports.join(
    '\n',
  )}\n\nexport default {\n${exports.join(',\n')}\n};`;
  await writeFile(config.TMP_COMPONENT_REGISTRY, content);
  logger.info('Global component registry generated.');
}
/**
 * @param {string} pagePath
 * @param {Config} config
 */
async function findLayoutsForPage(pagePath, config) {
  const layouts = [];
  let currentDir = dirname(pagePath);
  while (currentDir.startsWith(config.APP_DIR)) {
    const layoutPath = join(currentDir, 'layout.webs');
    if (await exists(layoutPath)) layouts.push(layoutPath);
    if (currentDir === config.APP_DIR) break;
    currentDir = dirname(currentDir);
  }
  return layouts.reverse();
}
/**
 * @param {PageEntrypoint[]} pageEntrypoints
 * @param {Config} config
 */
async function generateRoutes(pageEntrypoints, config) {
  logger.info('Generating server routes...');
  await ensureDir(config.TMP_WRAPPERS_DIR);

  const routeDefinitions = [];
  /** @type {Record<string, AgentDefinition>} */
  const agentDefinitions = {};
  const layoutWrapperEntrypoints = [];
  /** @type {Record<string, string>} */
  const sourceToComponentMap = {};

  for (const {
    source: sourcePagePath,
    compiled: compiledPagePath,
  } of pageEntrypoints) {
    const componentPath = relative(config.APP_DIR, sourcePagePath)
      .replace(/\\/g, '/')
      .replace('.webs', '')
      .replace('.agent', '');

    const componentName = `app/${componentPath}`;

    sourceToComponentMap[
      relative(config.SRC_DIR, sourcePagePath).replace(/\\/g, '/')
    ] = componentName;

    if (basename(componentName) === 'layout') continue;

    const mod = await import(`${compiledPagePath}?t=${Date.now()}`);

    if (sourcePagePath.endsWith('.agent.webs')) {
      logger.info(`Found agent definition: ${componentName}`);
      agentDefinitions[componentName] = {
        name: componentName,
        system_prompt: mod.system_prompt || '',
        tools: mod.tools || [],
        model: mod.model,
        component: mod.default,
      };
    }

    const layouts = await findLayoutsForPage(sourcePagePath, config);
    let finalComponent = mod.default;
    let finalComponentName = componentName;

    if (layouts.length > 0) {
      finalComponentName = `layout/${componentName.replace(/\//g, '_')}`;
      const wrapperPath = join(
        config.TMP_WRAPPERS_DIR,
        `${finalComponentName.split('/')[1]}.js`,
      );
      layoutWrapperEntrypoints.push({
        name: finalComponentName,
        path: wrapperPath,
      });

      const layoutImports = layouts
        .map((p, i) => {
          const relativeSourcePath = relative(config.SRC_DIR, p);
          const targetPath = resolve(
            config.TMP_COMPILED_DIR,
            relativeSourcePath.replace('.webs', '.js'),
          );
          let relativeImportPath = relative(
            dirname(wrapperPath),
            targetPath,
          ).replace(/\\/g, '/');
          if (!relativeImportPath.startsWith('.'))
            relativeImportPath = './' + relativeImportPath;
          return `import Layout${i} from '${relativeImportPath}';`;
        })
        .join('\n');

      let pageComponentRelativePath = relative(
        dirname(wrapperPath),
        compiledPagePath,
      ).replace(/\\/g, '/');
      if (!pageComponentRelativePath.startsWith('.'))
        pageComponentRelativePath = './' + pageComponentRelativePath;

      const wrapperContent = `
                import { h } from '@conradklek/webs';
                ${layoutImports}
                import PageComponent from '${pageComponentRelativePath}';
                export default {
                    name: '${finalComponentName}',
                    props: { params: Object, initialState: Object, user: Object },
                    render() {
                        const pageNode = h(PageComponent, { ...this.$props });
                        return ${layouts.reduceRight(
                          (acc, _, i) =>
                            `h(Layout${i}, { ...this.$props }, { default: () => ${acc} })`,
                          'pageNode',
                        )};
                    }
                };
            `;
      await writeFile(wrapperPath, wrapperContent);
      finalComponent = (await import(`${wrapperPath}?t=${Date.now()}`)).default;
    }

    let urlPath =
      '/' +
      componentPath
        .replace('.webs', '')
        .replace(/index$/, '')
        .replace(/\[(\w+)\]/g, ':$1');
    if (urlPath.length > 1 && urlPath.endsWith('/'))
      urlPath = urlPath.slice(0, -1);

    const actions = (mod.default && mod.default.actions) || {};
    /** @type {Record<string, Function>} */
    const handlers = {};
    const methodNames = ['post', 'patch', 'put', 'del'];
    for (const method of methodNames) {
      if (mod.default && typeof mod.default[method] === 'function') {
        handlers[method] = mod.default[method];
      }
    }
    /** @type {Record<string, Function>} */
    const wsHandlers = {};
    const wsHandlerNames = ['onOpen', 'onMessage', 'onClose', 'onError'];
    for (const handlerName of wsHandlerNames) {
      if (mod.default && typeof mod.default[handlerName] === 'function') {
        wsHandlers[handlerName] = mod.default[handlerName];
      }
    }

    routeDefinitions.push({
      path: urlPath,
      definition: {
        component: finalComponent,
        componentName: finalComponentName,
        actions: actions,
        handlers: handlers,
        wsHandlers: wsHandlers,
      },
    });
  }

  routeDefinitions.sort((a, b) => b.path.length - a.path.length);
  logger.info('Server routes and agent definitions generated.');
  return {
    appRoutes: Object.fromEntries(
      routeDefinitions.map((r) => [r.path, r.definition]),
    ),
    agentRoutes: agentDefinitions,
    layoutWrapperEntrypoints,
    sourceToComponentMap,
  };
}
/**
 * @param {BuildEntries} entries
 * @param {any} dbConfig
 * @param {Config} config
 */
async function buildClientBundle(entries, dbConfig, config) {
  logger.info('Starting client bundle...');

  const { sourceEntrypoints, layoutWrapperEntrypoints, publicCssEntrypoints } =
    entries;

  const allLoaderEntries = [
    ...sourceEntrypoints.map((fullPath) => {
      const componentName = relative(config.SRC_DIR, fullPath)
        .replace(/\\/g, '/')
        .replace('.webs', '');
      const compiledPath = join(
        config.TMP_COMPILED_DIR,
        relative(config.SRC_DIR, fullPath).replace('.webs', '.js'),
      );
      let relPath = relative(dirname(config.TMP_APP_JS), compiledPath).replace(
        /\\/g,
        '/',
      );
      if (!relPath.startsWith('.')) relPath = './' + relPath;
      return `['${componentName}', () => import('${relPath}')]`;
    }),
    ...layoutWrapperEntrypoints.map(({ name, path }) => {
      let relPath = relative(dirname(config.TMP_APP_JS), path).replace(
        /\\/g,
        '/',
      );
      if (!relPath.startsWith('.')) relPath = './' + relPath;
      return `['${name}', () => import('${relPath}')]`;
    }),
  ];

  const entrypointContent = `
        import { hydrate } from '@conradklek/webs';
        const dbConfig = ${JSON.stringify({
          version: dbConfig.version,
          clientTables: dbConfig.clientTables,
        })};
        const componentLoaders = new Map([${allLoaderEntries.join(',\n    ')}]);
        hydrate(componentLoaders, dbConfig);
    `;
  await writeFile(config.TMP_APP_JS, entrypointContent);

  const clientBuildResult = await Bun.build({
    entrypoints: [config.TMP_APP_JS, ...publicCssEntrypoints],
    outdir: config.OUTDIR,
    target: 'browser',
    splitting: true,
    minify: config.IS_PROD,
    naming: config.IS_PROD ? '[name]-[hash].[ext]' : '[name].[ext]',
    plugins: [tailwind],
    loader: { '.js': 'jsx' },
    sourcemap: config.IS_PROD ? 'none' : 'inline',
    define: {
      'process.env.NODE_ENV': `"${process.env.NODE_ENV || 'development'}"`,
    },
  });

  if (!clientBuildResult.success) {
    logger.error('Client build failed.');
    clientBuildResult.logs.forEach((log) => console.error(log));
    return null;
  }

  logger.info('Client bundle complete.');
  return clientBuildResult.outputs;
}
/**
 * @param {BuildArtifact[] | null} buildOutputs
 * @param {Config} config
 */
async function generateServiceWorker(buildOutputs, config) {
  if (!buildOutputs) return null;
  logger.info('Generating service worker...');
  const swTemplatePath = resolve(config.LIB_DIR, './client/service-worker.js');
  if (!(await exists(swTemplatePath))) {
    logger.warn('Service worker template not found.');
    return null;
  }
  const swTemplate = await Bun.file(swTemplatePath).text();
  const manifestForSw = JSON.stringify(
    buildOutputs
      .filter(
        (o) =>
          (o.kind === 'entry-point' || o.kind === 'chunk') &&
          (o.path.endsWith('.js') || o.path.endsWith('.css')),
      )
      .map((o) => ({ url: '/' + basename(o.path) }))
      .concat({ url: '/' }),
  );
  const finalSwContent = `const IS_PROD = ${
    config.IS_PROD
  };\nself.__WEBS_MANIFEST = ${manifestForSw};\n\n${swTemplate}`;
  const swOutputPath = join(config.OUTDIR, 'sw.js');
  await writeFile(swOutputPath, finalSwContent);
  logger.info(`Service worker generated at: ${swOutputPath}`);
  return swOutputPath;
}
/**
 * @param {Config} config
 */
async function runBuildAndServe(config) {
  const devInfoPath = join(config.TMPDIR, 'dev.json');

  const cleanup = async () => {
    if (await exists(devInfoPath)) {
      await rm(devInfoPath, { force: true });
    }
    process.exit();
  };
  process.on('SIGINT', cleanup);
  process.on('exit', cleanup);

  await rm(config.TMPDIR, { recursive: true, force: true });
  await ensureDir(config.TMPDIR);

  const dbConfig = getDbConfig();
  const aiConfig = {
    ...defaultAiConfig,
    db: { ...defaultAiConfig.db, path: join(config.TMPDIR, 'ai.db') },
  };
  const ai = new AI(aiConfig);
  await ai.init();
  logger.info('AI module initialized.');

  let buildEntries = await prepareBuildFiles(config);
  await generateComponentRegistry(config);

  const { default: globalComponents } = await import(
    `${config.TMP_COMPONENT_REGISTRY}?t=${Date.now()}`
  );

  const db = await setupDatabase(dbConfig, config.CWD, writeFile, config);
  if (!config.IS_PROD) await seedDevDatabase(db, config, ai);

  let {
    appRoutes,
    agentRoutes,
    layoutWrapperEntrypoints,
    sourceToComponentMap,
  } = await generateRoutes(buildEntries.pageEntrypoints, config);
  buildEntries.layoutWrapperEntrypoints = layoutWrapperEntrypoints;

  const buildOutputs = await buildClientBundle(buildEntries, dbConfig, config);

  const jsOutput = buildOutputs?.find(
    (o) => o.kind === 'entry-point' && o.path.endsWith('.js'),
  );
  const cssOutput = buildOutputs?.find((o) => o.path.endsWith('.css'));
  let manifest = {
    js: jsOutput?.path,
    css: cssOutput?.path,
    sw: (await generateServiceWorker(buildOutputs, config)) || undefined,
  };

  /** @type {ServerContext} */
  const serverContext = {
    db,
    ai,
    dbConfig,
    manifest,
    appRoutes,
    agentRoutes,
    config,
    isProd: config.IS_PROD,
    SYNC_TOPIC: 'webs-sync',
    HMR_TOPIC: 'webs-hmr',
    actionsPath: config.TMP_GENERATED_ACTIONS,
    globalComponents,
    sourceToComponentMap,
    syncActions: (
      await import(`${config.TMP_GENERATED_ACTIONS}?t=${Date.now()}`)
    ).registerActions(db),
  };

  const serverOptions = await startServer(serverContext);
  const server = Bun.serve(serverOptions);
  ai.initialize(server, agentRoutes);

  await writeFile(
    devInfoPath,
    JSON.stringify({ pid: process.pid, port: server.port }),
  );

  if (!config.IS_PROD) {
    logger.info(`Watching for file changes in: ${config.SRC_DIR}`);
    /** @type {NodeJS.Timeout | null} */
    let hmrDebounceTimer = null;

    watch(config.SRC_DIR, { recursive: true }, (_, filename) => {
      if (filename && !filename.endsWith('~')) {
        if (hmrDebounceTimer) clearTimeout(hmrDebounceTimer);
        hmrDebounceTimer = setTimeout(async () => {
          logger.info(`File change detected: ${filename}. Rebuilding...`);
          try {
            const preparedFiles = await prepareBuildFiles(config);
            buildEntries = {
              ...preparedFiles,
              layoutWrapperEntrypoints: [],
            };

            await generateComponentRegistry(config);

            const routesResult = await generateRoutes(
              buildEntries.pageEntrypoints,
              config,
            );
            appRoutes = routesResult.appRoutes;
            agentRoutes = routesResult.agentRoutes;
            sourceToComponentMap = routesResult.sourceToComponentMap;
            buildEntries.layoutWrapperEntrypoints =
              routesResult.layoutWrapperEntrypoints;

            const newBuildOutputs = await buildClientBundle(
              buildEntries,
              dbConfig,
              config,
            );

            if (newBuildOutputs) {
              const newJsOutput = newBuildOutputs.find(
                (o) => o.kind === 'entry-point' && o.path.endsWith('.js'),
              );
              const newCssOutput = newBuildOutputs.find((o) =>
                o.path.endsWith('.css'),
              );
              manifest = {
                js: newJsOutput?.path,
                css: newCssOutput?.path,
                sw:
                  (await generateServiceWorker(newBuildOutputs, config)) ||
                  manifest.sw,
              };

              const newFetchHandler = createFetchHandler({
                ...serverContext,
                manifest,
                appRoutes,
                agentRoutes,
                sourceToComponentMap,
              });
              server.reload({ ...serverOptions, fetch: newFetchHandler });

              logger.info('Rebuild complete. Sending HMR reload message.');
              server.publish(
                serverContext.HMR_TOPIC,
                JSON.stringify({ type: 'reload' }),
              );
            }
          } catch (e) {
            logger.error('Error during rebuild:', e);
          }
        }, 100);
      }
    });
  }
}

/**
 * @param {Config} config
 */
async function runInspection(config) {
  await rm(config.TMPDIR, { recursive: true, force: true });
  await ensureDir(config.TMPDIR);

  const buildEntries = await prepareBuildFiles(config);
  await generateComponentRegistry(config);

  const { appRoutes, agentRoutes, sourceToComponentMap } = await generateRoutes(
    buildEntries.pageEntrypoints,
    config,
  );

  await generateInspectionReport({
    appRoutes,
    agentRoutes,
    sourceEntrypoints: buildEntries.sourceEntrypoints,
    config,
    sourceToComponentMap,
  });
}

/**
 * @param {Config} config
 */
async function runShell(config) {
  const devInfoPath = join(config.TMPDIR, 'dev.json');
  if (!(await exists(devInfoPath))) {
    console.error(
      'Development server not running. Please start it with `webs dev` first.',
    );
    process.exit(1);
  }

  const { pid, port } = JSON.parse(await Bun.file(devInfoPath).text());

  try {
    process.kill(pid, 0);
  } catch (e) {
    console.error(
      'Development server not running. Please start it with `webs dev` first.',
    );
    await rm(devInfoPath, { force: true });
    process.exit(1);
  }

  await startInteractiveShell(port, config.CWD);
}

/**
 * @param {string[]} args
 * @param {string} flag
 * @returns {string[]}
 */
function getFlagValues(args, flag) {
  const flagIndex = args.indexOf(flag);
  const values = [];
  if (flagIndex !== -1) {
    for (let i = flagIndex + 1; i < args.length; i++) {
      const arg = args[i];
      if (arg && arg.startsWith('--')) {
        break;
      }
      if (arg) {
        values.push(arg);
      }
    }
  }
  return values;
}

async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || (defaultConfig.IS_PROD ? 'start' : 'dev');
  const targetFlagIndex = args.indexOf('--target');
  const targetDir =
    (targetFlagIndex !== -1 && args[targetFlagIndex + 1]) || process.cwd();

  const config = {
    ...defaultConfig,
    CWD: resolve(targetDir),
    OUTDIR: resolve(targetDir, 'dist'),
    TMPDIR: resolve(targetDir, '.webs'),
    TMP_COMPILED_DIR: resolve(targetDir, '.webs/compiled'),
    TMP_WRAPPERS_DIR: resolve(targetDir, '.webs/layout'),
    TMP_APP_JS: resolve(targetDir, '.webs/app.js'),
    TMP_APP_CSS: resolve(targetDir, '.webs/app.css'),
    SRC_DIR: resolve(targetDir, 'src'),
    APP_DIR: resolve(targetDir, 'src/app'),
    PUB_DIR: resolve(targetDir, 'src/pub'),
    GUI_DIR: resolve(targetDir, 'src/gui'),
    USER_FILES_ROOT: resolve(targetDir, '.webs/files'),
    TMP_GENERATED_ACTIONS: resolve(targetDir, '.webs/actions.js'),
    TMP_COMPONENT_REGISTRY: resolve(targetDir, '.webs/registry.js'),
  };

  const includeValues = getFlagValues(args, '--include');
  const knownSections = ['tree', 'types', 'tests', 'files'];
  const includedSections = includeValues.filter((v) =>
    knownSections.includes(v),
  );
  const includedFiles = includeValues.filter((v) => !knownSections.includes(v));
  const excludedPatterns = getFlagValues(args, '--exclude');

  switch (command) {
    case 'dev':
    case 'start':
      await runBuildAndServe(config);
      break;
    case 'inspect':
      await runInspection(config);
      break;
    case 'shell':
      await runShell(config);
      break;
    case 'grep': {
      const [pattern, path = config.CWD, filePattern] = args.slice(1);
      if (!pattern) {
        console.error('Usage: webs grep <pattern> [path] [--include <glob>]');
        process.exit(1);
      }
      await runGrep(pattern, path, filePattern);
      break;
    }
    case 'analyze':
      console.log(`Analyzing directory: ${targetDir}`);
      await runAnalysis(targetDir);
      break;
    case 'lock':
      console.log(`Creating lockfile for directory: ${targetDir}`);
      await createLockfile(
        targetDir,
        includedSections,
        includedFiles,
        excludedPatterns,
      );
      break;
    case 'ai':
      console.log(`Starting AI session for directory: ${targetDir}`);
      await startAiSession(targetDir);
      break;
    default:
      console.error(`Unknown command: ${command}`);
      console.log(
        'Available commands: dev, start, inspect, shell, grep, analyze, ai, lock',
      );
      process.exit(1);
  }
}

main().catch((e) => {
  logger.error('Fatal error:', e);
  process.exit(1);
});

---------- END: build/cli.js ----------

---------- START: build/plugin.js ----------
#!/usr/bin/env bun

/**
 * Configuration options for the bun-plugin-webs.
 * @typedef {object} WebsPluginOptions
 * @property {string} [root] - The project root directory. Defaults to `process.cwd()`.
 * @property {string} [registryPath] - Path to the generated global component registry file.
 * @property {string} [guiDir] - Path to the global UI components directory (`src/gui`).
 */
import { resolve, basename, relative, dirname } from 'path';

/**
 * Custom Bun plugin to handle .webs single-file components.
 * This plugin **encapsulates the stable, production-tested compilation logic** for \.webs` single-file components.`
 * @param {Partial<WebsPluginOptions>} [options]
 * @returns {import('bun').BunPlugin}
 */
export default (options = {}) => ({
  name: 'bun-plugin-webs',
  async setup(build) {
    const { root = process.cwd(), registryPath, guiDir } = options;

    build.onResolve({ filter: /\.js$/ }, (args) => {
      if (args.importer.endsWith('.webs')) {
        const resolvedPath = resolve(dirname(args.importer), args.path);
        if (registryPath && resolvedPath === registryPath) {
          return null;
        }
        const websPath = resolvedPath.replace(/\.js$/, '.webs');
        return {
          path: websPath,
          namespace: 'webs-components',
        };
      }
      return null;
    });

    build.onResolve({ filter: /\.webs$/ }, (args) => ({
      path: resolve(args.resolveDir || root, args.path),
      namespace: 'webs-components',
    }));

    build.onLoad(
      { filter: /.*/, namespace: 'webs-components' },
      async (args) => {
        try {
          const sourceCode = await Bun.file(args.path).text();
          const relativePath = relative(root, args.path).replace(/\\/g, '/');
          const componentName = relativePath.startsWith('src/')
            ? relativePath.substring(4).replace('.webs', '')
            : basename(args.path, '.webs');

          const scriptMatch = /<script[^>]*>(.*?)<\/script>/s.exec(sourceCode);
          const templateMatch = /<template>(.*?)<\/template>/s.exec(sourceCode);
          const styleMatch = /<style>([\s\S]*?)<\/style>/s.exec(sourceCode);

          let scriptContent = scriptMatch?.[1]?.trim() ?? '';
          const templateContent = templateMatch?.[1]?.trim() ?? '';
          const styleContent = styleMatch?.[1]?.trim() ?? '';

          scriptContent = scriptContent.replace(
            /from\s+['"](.+?)\.webs['"]/g,
            "from '$1.js'",
          );

          let registryImport = '';
          const isGlobalComponent = guiDir && args.path.startsWith(guiDir);

          if (!isGlobalComponent && registryPath) {
            let relPath = relative(dirname(args.path), registryPath).replace(
              /\\/g,
              '/',
            );
            if (!relPath.startsWith('.')) relPath = './' + relPath;
            registryImport = `import __globalComponents from '${relPath}';\n`;

            if (scriptContent.includes('export default')) {
              if (scriptContent.includes('components:')) {
                scriptContent = scriptContent.replace(
                  /(components\s*:\s*\{)/,
                  '$1 ...(__globalComponents || {}),',
                );
              } else {
                scriptContent = scriptContent.replace(
                  /(export default\s*\{)/,
                  '$1 components: __globalComponents || {},',
                );
              }
            }
          }

          const templateProperty = `template: ${JSON.stringify(templateContent)}`;
          const styleProperty = `style: ${JSON.stringify(styleContent)}`;
          const injectedProps = `name: '${componentName}', ${templateProperty}, ${styleProperty}`;
          let finalScript;

          if (!scriptContent.includes('export default')) {
            const componentsProp = !isGlobalComponent
              ? 'components: __globalComponents || {},'
              : '';
            finalScript = `${scriptContent}\nconst __webs_component_def = { ${injectedProps}, ${componentsProp} };\nexport default __webs_component_def;`;
          } else {
            finalScript = scriptContent.replace(
              /(export default\s*\{)/,
              `$1 ${injectedProps},`,
            );
            finalScript = finalScript.replace(
              /export default (\{[\s\S]*\});?/,
              'const __webs_component_def = $1; export default __webs_component_def;',
            );
          }

          const hmrCode = `
        if (import.meta.hot) {
          import.meta.hot.accept(() => {
            window.location.reload();
          });
        }`;

          return {
            contents: registryImport + finalScript + hmrCode,
            loader: 'js',
            resolveDir: dirname(args.path),
          };
        } catch (e) {
          console.error(`[Webs Plugin] Failed to load ${args.path}:`, e);
          throw e;
        }
      },
    );
  },
});

---------- END: build/plugin.js ----------

---------- START: ai/ai.client.js ----------
import { state } from '../core/reactivity.js';
import { db } from '../client/db.client.js';
import { onMounted, onUnmounted } from '../core/component.js';
import { session } from '../client/session.js';

/**
 * @file Contains all the JSDoc type definitions for the AI client service.
 */

/**
 * @typedef {object} ToolCall
 * @property {string} id
 * @property {object} function
 * @property {string} function.name
 * @property {object} function.arguments
 */

/**
 * @typedef {object} ChatMessage
 * @property {'user' | 'assistant' | 'system' | 'tool'} role - The role of the message sender.
 * @property {string} content - The content of the message.
 * @property {string | number} [user_id] - Optional user ID for filtering.
 * @property {ToolCall[]} [tool_calls] - Optional array of tool calls.
 * @property {string} [tool_call_id] - Optional tool call ID.
 * @property {string} [tool_name] - The name of the tool that was executed.
 */

/**
 * @typedef {object} SearchResultMetadata
 * @property {string} filePath
 * @property {number} startLine
 * @property {number} endLine
 * @property {string} [className]
 * @property {string} [functionName]
 * @property {string} [summary]
 */

/**
 * @typedef {object} SearchResult
 * @property {string} text
 * @property {number} score
 * @property {SearchResultMetadata} metadata
 */

/**
 * @typedef {object} ChatState
 * @property {string} data
 * @property {boolean} isLoading
 * @property {Error | null} error
 * @property {ReadableStream<Uint8Array> | null} stream
 */

/**
 * @typedef {object} AIModel
 * @property {string} name
 * @property {string} [license]
 * @property {string} [size]
 * @property {string} [modified_at]
 */

/**
 * @typedef {object} AgentRunner
 * @property {import('../core/reactivity.js').ReactiveProxy<ChatState>} state
 * @property {(messages: ChatMessage[]) => Promise<void>} run
 * @property {() => void} cleanup
 */

/**
 * @typedef {object} AIService
 * @property {(prompt: string, options?: { model?: string }) => Promise<ReadableStream | null>} generate
 * @property {(messages: ChatMessage[], options?: { model?: string }) => Promise<ReadableStream | null>} chat
 * @property {(query: string, limit?: number) => Promise<SearchResult[]>} search
 * @property {(agentName: string, messages: ChatMessage[], options?: object) => Promise<ReadableStream | null>} run
 * @property {{list: () => Promise<AIModel[]>, pull: (modelName: string) => Promise<ReadableStream | null>, delete: (modelName: string) => Promise<any>}} models
 */

/**
 * @typedef {object} Tool
 * @property {string} type
 * @property {object} function
 * @property {string} function.name
 * @property {string} function.description
 * @property {object} function.parameters
 * @property {string} function.parameters.type
 * @property {{ [key: string]: { type?: string | string[], items?: any, description?: string, enum?: any[] } }} function.parameters.properties
 */

/**
 * @typedef {object} ConversationMessage
 * @property {string} id
 * @property {string} channel
 * @property {string} username
 * @property {string} message
 * @property {number | null} user_id
 * @property {string} created_at
 */

/**
 * @typedef {object} ConversationState
 * @property {ConversationMessage[]} messages
 * @property {boolean} isLoading
 * @property {Error | null} error
 * @property {string} streamingResponse
 */

/**
 * @typedef {object} UseConversationReturn
 * @property {import('../core/reactivity.js').ReactiveProxy<ConversationState>} state
 * @property {(content: string) => Promise<void>} send
 */

/**
 * @typedef {object} ToolEvent
 * @property {string} name - The name of the tool being called.
 * @property {object} args - The arguments passed to the tool.
 * @property {any} [result] - The result returned by the tool.
 * @property {'pending' | 'complete'} status - The status of the tool call.
 */

/**
 * @typedef {object} AgentState
 * @property {ChatMessage[]} messages - The history of messages in the agent conversation.
 * @property {boolean} isLoading - True when the agent is processing.
 * @property {Error | null} error - Any error that occurred during the run.
 * @property {string} streamingResponse - The current text being streamed by the agent.
 * @property {ToolEvent[]} toolEvents - A log of tool calls and their results.
 */

/**
 * @typedef {object} UseAgentReturn
 * @property {import('../core/reactivity.js').ReactiveProxy<AgentState>} state - The reactive state of the agent interaction.
 * @property {(messages: ChatMessage[]) => Promise<void>} run - Executes the agent with a given set of messages.
 */

/**
 * @type {AIService | undefined}
 */
let aiServiceInstance;

/**
 * @internal
 * @returns {AIService}
 */
function createAIService() {
  /**
   * @type {AIService['generate']}
   */
  const generate = async (prompt, options = {}) => {
    const response = await fetch('/api/ai/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt, options }),
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`AI generation failed: ${errorText}`);
    }
    return response.body;
  };

  /**
   * @type {AIService['search']}
   */
  const search = async (query, limit = 5) => {
    const response = await fetch('/api/ai/search/files', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, limit }),
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`AI search failed: ${errorText}`);
    }
    return response.json();
  };

  /**
   * @type {AIService['chat']}
   */
  const chat = async (messages, options = {}) => {
    const response = await fetch('/api/ai/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ messages, options }),
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`AI chat failed: ${errorText}`);
    }
    return response.body;
  };

  /**
   * @type {AIService['run']}
   */
  const run = async (agentName, messages, options = {}) => {
    const response = await fetch(`/api/ai/agent/run/${agentName}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ messages, options }),
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Agent run failed for '${agentName}': ${errorText}`);
    }
    return response.body;
  };

  const models = {
    list: async () => {
      const response = await fetch('/api/ai/models/list');
      if (!response.ok) throw new Error('Failed to list models.');
      return response.json();
    },
    /** @param {string} modelName */
    pull: async (modelName) => {
      const response = await fetch('/api/ai/models/pull', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: modelName }),
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to pull model: ${errorText}`);
      }
      return response.body;
    },
    /** @param {string} modelName */
    delete: async (modelName) => {
      const response = await fetch('/api/ai/models/delete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: modelName }),
      });
      if (!response.ok) throw new Error('Failed to delete model.');
      return response.json();
    },
  };

  return { generate, chat, models, search, run };
}

/**
 * @internal
 * @returns {AIService}
 */
function getAiServiceInstance() {
  if (!aiServiceInstance) {
    aiServiceInstance = createAIService();
  }
  return aiServiceInstance;
}

/**
 * @overload
 * @returns {AIService} - The singleton AI service instance.
 */
/**
 * @overload
 * @param {string} prompt - A prompt for a simple, stateless text generation.
 * @param {object} [options] - Optional parameters for the generation.
 * @returns {Promise<ReadableStream | null>} - A stream of the generated text.
 */
/**
 * Provides access to the framework's AI capabilities.
 *
 * Can be used in two ways:
 * 1. As a function for simple generation: `ai("Why is the sky blue?")`
 * 2. As an object for advanced features: `ai.chat(messages)` or `ai.run('agent', ...)`
 */
const aiProxy = new Proxy(function () {}, {
  /**
   * @param {any} _
   * @param {any} __
   * @param {any[]} args
   */
  apply(_, __, args) {
    const instance = getAiServiceInstance();
    if (args.length > 0) {
      const [prompt, options] = args;
      return instance.generate(prompt, options);
    }
    return instance;
  },
  /**
   * @param {any} _
   * @param {keyof AIService} prop
   */
  get(_, prop) {
    const instance = getAiServiceInstance();
    return instance[prop];
  },
});

export const ai =
  /** @type {AIService & ((prompt?: string, options?: object) => (Promise<ReadableStream | null> | AIService))} */ (
    aiProxy
  );

/**
 * A composable for interacting with a server-side AI agent in real-time.
 * @param {string} agentName - The name of the agent to run.
 * @returns {UseAgentReturn}
 */
export function useAgent(agentName) {
  if (typeof window === 'undefined') {
    const mockState = state({
      messages: [],
      isLoading: false,
      error: null,
      streamingResponse: '',
      toolEvents: [],
    });
    return { state: mockState, run: async () => {} };
  }

  const s = state({
    messages: /** @type {ChatMessage[]} */ ([]),
    isLoading: false,
    error: /** @type {Error | null} */ (null),
    streamingResponse: '',
    toolEvents: /** @type {ToolEvent[]} */ ([]),
  });

  /** @param {ChatMessage[]} messages */
  const run = async (messages) => {
    s.isLoading = true;
    s.error = null;
    s.streamingResponse = '';
    s.toolEvents = [];
    s.messages = [...messages];

    try {
      const stream = await ai.run(agentName, messages);
      if (!stream) return;

      const reader = stream.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // Keep the last, possibly incomplete, line

        for (const line of lines) {
          if (line.trim() === '') continue;
          try {
            const event = JSON.parse(line);
            switch (event.type) {
              case 'chunk':
                s.streamingResponse += event.content || '';
                break;
              case 'tool_start':
                s.toolEvents.push({
                  name: event.name,
                  args: event.args,
                  status: 'pending',
                });
                break;
              case 'tool_end': {
                const toolEvent = s.toolEvents.find(
                  (e) => e.name === event.name && e.status === 'pending',
                );
                if (toolEvent) {
                  toolEvent.result = event.result;
                  toolEvent.status = 'complete';
                }
                break;
              }
            }
          } catch (e) {
            console.error('Failed to parse agent stream event:', line, e);
          }
        }
      }
    } catch (e) {
      s.error = e instanceof Error ? e : new Error(String(e));
    } finally {
      if (s.streamingResponse) {
        s.messages.push({
          role: 'assistant',
          content: s.streamingResponse,
        });
      }
      s.isLoading = false;
    }
  };

  return { state: s, run };
}

/**
 * A composable for creating a persistent, real-time AI chat.
 * @param {string} channel - A unique identifier for the chat channel.
 * @returns {UseConversationReturn}
 */
export function useConversation(channel) {
  if (typeof window === 'undefined') {
    const mockState = state({
      messages: [],
      isLoading: false,
      error: null,
      streamingResponse: '',
    });
    return { state: mockState, send: async () => {} };
  }

  const s = state({
    messages:
      /** @type {import('./ai.client.js').ConversationMessage[]} */ ([]),
    isLoading: true,
    error: /** @type {Error | null} */ (null),
    streamingResponse: '',
  });

  const chatDb = db('chat_messages');

  const fetchHistory = async () => {
    try {
      s.isLoading = true;
      const allMessages = await chatDb.query('by-channel', channel);
      if (allMessages) {
        s.messages = allMessages.sort(
          (a, b) =>
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime(),
        );
      }
    } catch (e) {
      s.error = e instanceof Error ? e : new Error(String(e));
    } finally {
      s.isLoading = false;
    }
  };

  onMounted(fetchHistory);
  const unsubscribe = chatDb.subscribe(fetchHistory);
  onUnmounted(unsubscribe);

  /** @param {string} content */
  const send = async (content) => {
    if (!session.user) {
      s.error = new Error('User not logged in.');
      return;
    }

    s.isLoading = true;
    s.error = null;
    s.streamingResponse = '';

    try {
      const userMessage = {
        id: crypto.randomUUID(),
        channel,
        username: session.user.username,
        message: content,
        user_id: session.user.id,
        created_at: new Date().toISOString(),
      };
      await chatDb.put(userMessage);

      // The subscription will update the local state, but we can grab the latest for the API call
      const allMessages = (await chatDb.query('by-channel', channel)) || [];
      const history = allMessages
        .sort(
          (a, b) =>
            new Date(a.created_at).getTime() - new Date(b.created_at).getTime(),
        )
        .map(
          (/** @type {ConversationMessage} */ msg) =>
            /** @type {ChatMessage} */ ({
              role:
                msg.username === /** @type {any} */ (session.user).username
                  ? 'user'
                  : 'assistant',
              content: msg.message,
            }),
        );

      const stream = await ai.chat(history);
      if (!stream) return;

      const reader = stream.getReader();
      const decoder = new TextDecoder();
      let fullResponse = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        s.streamingResponse += chunk;
        fullResponse += chunk;
      }

      if (fullResponse) {
        const aiMessage = {
          id: crypto.randomUUID(),
          channel,
          username: 'assistant',
          message: fullResponse,
          user_id: null,
          created_at: new Date().toISOString(),
        };
        await chatDb.put(aiMessage);
      }
    } catch (e) {
      s.error = e instanceof Error ? e : new Error(String(e));
    } finally {
      s.isLoading = false;
      s.streamingResponse = '';
    }
  };

  return { state: s, send };
}

---------- END: ai/ai.client.js ----------

---------- START: ai/ai.server.js ----------
import { generateUUID } from '../utils/common.js';
import { Store } from './vector-store.js';
import { AIErrors } from './ai.errors.js';
import { EventEmitter } from 'events';
import { Ollama } from 'ollama';

/**
 * @typedef {import('bun:sqlite').Database} BunDatabase
 * @typedef {import('bun').Server} BunServer
 * @typedef {import('bun').Subprocess} Subprocess
 * @typedef {import('bun').ServerWebSocket<any>} WebSocket
 * @typedef {import('bun').ErrorLike} ErrorLike
 */

/**
 * @typedef {object} ToolCall
 * @property {string} id
 * @property {object} function
 * @property {string} function.name
 * @property {object} function.arguments
 */

/**
 * @typedef {object} ChatMessage
 * @property {'user' | 'assistant' | 'system' | 'tool'} role - The role of the message sender.
 * @property {string} content - The content of the message.
 * @property {string | number} [user_id] - Optional user ID for filtering.
 * @property {ToolCall[]} [tool_calls] - Optional array of tool calls.
 * @property {string} [tool_call_id] - Optional tool call ID.
 * @property {string} [tool_name] - The name of the tool that was executed.
 */

/**
 * @typedef {object} SearchResultMetadata
 * @property {string} filePath
 * @property {number} startLine
 * @property {number} endLine
 * @property {string} [className]
 * @property {string} [functionName]
 * @property {string} [summary]
 */

/**
 * @typedef {object} SearchResult
 * @property {string} text
 * @property {number} score
 * @property {SearchResultMetadata} metadata
 */

/**
 * @typedef {object} Tool
 * @property {string} type
 * @property {object} function
 * @property {string} function.name
 * @property {string} function.description
 * @property {object} function.parameters
 * @property {string} function.parameters.type
 * @property {{ [key: string]: { type?: string | string[], items?: any, description?: string, enum?: any[] } }} function.parameters.properties
 */

/**
 * @typedef {object} AIConfig
 * @property {string} host
 * @property {{chat: string, embedding: string, labeling: string, agent?: string}} models
 * @property {{path: string}} worker
 * @property {{path: string, dimensions: number}} db
 */

/**
 * @typedef {object} AgentDefinition
 * @property {string} name
 * @property {string} system_prompt
 * @property {Tool[]} tools
 * @property {string} [model]
 * @property {any} component
 */

/**
 * @typedef {object} ConversationContext
 * @property {BunDatabase} db
 * @property {any} user
 * @property {Record<string, Function>} syncActions
 * @property {BunServer} server
 */

export class AI {
  /** @param {AIConfig} config */
  constructor(config) {
    this.config = config;
    this.store = new Store(config, this);
    /** @type {import('bun').Subprocess | null} */
    this.worker = null;
    this.ollama = new Ollama({ host: config.host });
    this.isReady = false;
    this.requestEmitter = new EventEmitter();
  }

  /**
   * @param {BunServer} _server
   * @param {Record<string, AgentDefinition>} [_agentDefs]
   */
  initialize(_server, _agentDefs = {}) {}

  async init() {
    if (this.isReady) return;
    console.log('[AI] Initializing...');
    const workerPath = this.config.worker.path;
    if (!(await Bun.file(workerPath).exists())) {
      throw new AIErrors.AIError(
        `[AI] Worker script not found at: ${workerPath}`,
      );
    }
    this.worker = Bun.spawn(['bun', workerPath], {
      stdio: ['ignore', 'inherit', 'inherit'],
      ipc: (/** @type {{streamId?: string, opId?: string}} */ message) => {
        const channel = message.streamId || message.opId;
        if (channel) this.requestEmitter.emit(channel, message);
      },
      onExit: (_subprocess, code, _signal, error) => {
        console.warn(`[AI] Worker process exited with code: ${code}.`);
        if (error) {
          console.error('[AI] Worker process exited with error:', error);
        }
      },
      env: {
        ...process.env,
        OLLAMA_HOST: this.config.host,
        CHAT_MODEL: this.config.models.chat,
        AGENT_MODEL: this.config.models.agent,
      },
    });
    await this.store.init();
    this.isReady = true;
    console.log('[AI] Ready.');
  }

  async shutdown() {
    if (!this.isReady) return;
    console.log('[AI] Shutting down...');
    this.worker?.kill();
    this.store.close();
    this.isReady = false;
    await new Promise((resolve) => setTimeout(resolve, 100));
    console.log('[AI] Shutdown complete.');
  }

  /**
   * @param {Array<{path: string, content: string}>} files
   * @param {object & {userId?: string}} [metadata={}]
   */
  async indexDirectory(files, metadata = {}) {
    if (!files || files.length === 0) {
      return { successful: 0, failed: 0 };
    }
    console.log(`[AI] Starting batch indexing for ${files.length} files...`);

    for (const file of files) {
      await this.removeFileIndex(file.path, metadata);
    }

    const filesToProcess = files.filter(
      (f) => f.content && f.content.trim().length > 0,
    );
    const contents = filesToProcess.map((f) => f.content);

    if (contents.length === 0) {
      console.log('[AI] No non-empty files to index.');
      return { successful: files.length, failed: 0 };
    }

    try {
      const embeddings = await this.embedBatch(contents);
      const documentsToIndex = [];

      for (let i = 0; i < filesToProcess.length; i++) {
        const file = filesToProcess[i];
        const embedding = embeddings[i];
        if (file && embedding) {
          documentsToIndex.push({
            content: file.content,
            embedding: embedding,
            metadata: {
              filePath: file.path,
              startLine: 1,
              endLine: file.content.split('\n').length,
              ...metadata,
            },
          });
        }
      }

      await this.store.indexBatch(documentsToIndex);

      const successfulCount =
        documentsToIndex.length + (files.length - filesToProcess.length);
      console.log(
        `[AI] Batch indexing complete. Indexed ${successfulCount} files successfully.`,
      );
      return { successful: successfulCount, failed: 0 };
    } catch (error) {
      console.error('[AI] Batch indexing failed:', error);
      return { successful: 0, failed: files.length };
    }
  }

  /**
   * @param {{ path: string, content: string }} file
   * @param {object & {userId?: string}} [metadata={}]
   */
  async indexFile(file, metadata = {}) {
    if (!file.path || typeof file.content !== 'string') {
      console.warn(
        `[AI] Skipping invalid file data for: ${file.path || 'unknown file'}`,
      );
      return false;
    }

    console.log(`[AI]   - Processing file: ${file.path}`);
    try {
      await this.removeFileIndex(file.path, metadata);

      if (file.content.trim() === '') {
        console.log(`[AI]   - Skipped indexing empty file: ${file.path}`);
        return true;
      }

      const content = file.content;
      const lines = content.split('\n').length;
      const embedding = await this.embed(content);

      if (embedding) {
        await this.store.indexWithEmbedding(content, embedding, {
          filePath: file.path,
          startLine: 1,
          endLine: lines,
          ...metadata,
        });
      } else {
        throw new AIErrors.EmbeddingError(
          `Worker returned an empty embedding for ${file.path}.`,
        );
      }

      return true;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(`[AI] Failed to index file: ${file.path}`, errorMessage);
      return false;
    }
  }

  /**
   * @param {string} filePath
   * @param {object & {userId?: string}} [metadata={}]
   */
  async removeFileIndex(filePath, metadata = {}) {
    console.log(`[AI] Removing index for file: ${filePath}`);
    try {
      await this.store.remove(filePath, metadata.userId);
    } catch (error) {
      console.error(`[AI] Failed to remove index for ${filePath}:`, error);
    }
  }

  /** @param {string} text */
  async embed(text) {
    const opId = generateUUID();
    return new Promise((resolve, reject) => {
      this.requestEmitter.once(
        opId,
        (/** @type {{error: any, embedding: number[]}} */ res) => {
          if (res.error) {
            reject(
              new AIErrors.EmbeddingError(
                'Failed to generate embedding.',
                res.error,
              ),
            );
          } else if (!res.embedding || res.embedding.length === 0) {
            reject(
              new AIErrors.EmbeddingError(
                'Worker returned an empty embedding.',
              ),
            );
          } else {
            resolve(new Float32Array(res.embedding));
          }
        },
      );
      this.worker?.send({
        opId,
        type: 'embed',
        text,
        model: this.config.models.embedding,
      });
    });
  }

  /** @param {string[]} texts */
  async embedBatch(texts) {
    if (!texts || texts.length === 0) {
      return [];
    }
    const opId = generateUUID();
    return new Promise((resolve, reject) => {
      this.requestEmitter.once(
        opId,
        (
          /** @type {{error: any, embeddings: (number[] | undefined)[]}} */ res,
        ) => {
          if (res.error) {
            reject(
              new AIErrors.EmbeddingError(
                'Failed to generate batch embeddings.',
                res.error,
              ),
            );
          } else if (
            !res.embeddings ||
            res.embeddings.length !== texts.length
          ) {
            reject(
              new AIErrors.EmbeddingError(
                'Worker returned mismatched number of embeddings for batch.',
              ),
            );
          } else {
            resolve(
              res.embeddings.map((e) => (e ? new Float32Array(e) : undefined)),
            );
          }
        },
      );
      this.worker?.send({
        opId,
        type: 'embed-batch',
        texts,
        model: this.config.models.embedding,
      });
    });
  }
  /**
   * @param {string} prompt
   * @param {object} [options={}]
   */
  async generate(prompt, options = {}) {
    if (!prompt) {
      throw new AIErrors.ChatError('Prompt cannot be empty.');
    }
    const streamId = `generate-${generateUUID()}`;

    this.worker?.send({
      streamId,
      type: 'generate',
      prompt,
      model: /** @type {any} */ (options).model,
      options,
    });

    return new ReadableStream({
      start: (controller) => {
        const onMessage = (/** @type {{type: string, payload: any}} */ msg) => {
          try {
            if (msg.type === 'chunk') {
              controller.enqueue(
                new TextEncoder().encode(msg.payload.response),
              );
            } else if (msg.type === 'done') {
              controller.close();
              cleanup();
            } else if (msg.type === 'error') {
              controller.error(
                new AIErrors.ChatError(
                  'Generation stream failed.',
                  msg.payload,
                ),
              );
              cleanup();
            }
          } catch (e) {
            controller.error(
              new AIErrors.ChatError(
                'Failed to parse generation stream.',
                /** @type {Error} */ (e),
              ),
            );
            cleanup();
          }
        };
        const cleanup = () =>
          this.requestEmitter.removeListener(streamId, onMessage);
        this.requestEmitter.on(streamId, onMessage);
      },
    });
  }
  /**
   * @param {ChatMessage[]} messages
   * @param {object} [options={}]
   */
  async chat(messages, options = {}) {
    if (!messages || messages.length === 0) {
      throw new AIErrors.ChatError('Messages array cannot be empty.');
    }
    const streamId = `chat-${generateUUID()}`;

    this.worker?.send({
      streamId,
      type: 'chat',
      messages: messages,
      model: /** @type {any} */ (options).model,
      options,
    });

    return new ReadableStream({
      start: (controller) => {
        const onMessage = (/** @type {{type: string, payload: any}} */ msg) => {
          try {
            if (msg.type === 'chunk') {
              controller.enqueue(
                new TextEncoder().encode(msg.payload.message.content),
              );
            } else if (msg.type === 'done') {
              controller.close();
              cleanup();
            } else if (msg.type === 'error') {
              controller.error(
                new AIErrors.ChatError('Chat stream failed.', msg.payload),
              );
              cleanup();
            }
          } catch (e) {
            controller.error(
              new AIErrors.ChatError(
                'Failed to parse chat stream.',
                /** @type {Error} */ (e),
              ),
            );
            cleanup();
          }
        };
        const cleanup = () =>
          this.requestEmitter.removeListener(streamId, onMessage);
        this.requestEmitter.on(streamId, onMessage);
      },
    });
  }

  /**
   * @param {{channel_id: string, message: ChatMessage, options?: { model?: string }}} params
   * @param {ConversationContext} context
   */
  async startConversation({ channel_id, message, options }, context) {
    const { db, user, syncActions } = context;

    const userMessage = {
      id: generateUUID(),
      channel_id,
      username: user.username,
      message: message.content,
      user_id: user.id,
      created_at: new Date().toISOString(),
    };
    if (syncActions && syncActions.upsertChat_messages) {
      syncActions.upsertChat_messages({ user }, userMessage);
    }

    const historyRows = db
      .query(
        `SELECT username, message FROM chat_messages WHERE channel_id = ? ORDER BY created_at DESC LIMIT 20`,
      )
      .all(channel_id)
      .reverse();

    const history = historyRows.map(
      (/** @type {{username: string, message: string}} */ row) =>
        /** @type {ChatMessage} */ ({
          role: row.username === user.username ? 'user' : 'assistant',
          content: row.message,
        }),
    );

    const stream = await this.chat(history, options);
    let fullResponse = '';

    const transformStream = new TransformStream({
      transform(chunk, controller) {
        fullResponse += new TextDecoder().decode(chunk);
        controller.enqueue(chunk);
      },
      flush() {
        const aiMessage = {
          id: generateUUID(),
          channel_id,
          username: 'assistant',
          message: fullResponse,
          user_id: null,
          created_at: new Date().toISOString(),
        };
        if (syncActions && syncActions.upsertChat_messages) {
          syncActions.upsertChat_messages({ user: null }, aiMessage);
        }
      },
    });

    return stream.pipeThrough(transformStream);
  }

  /**
   * @param {ChatMessage[]} messages
   * @param {AgentDefinition} agentDef
   * @param {any} toolContext
   * @param {object} [options={}]
   */
  async agent(messages, agentDef, toolContext, options = {}) {
    const streamId = `agent-exec-${generateUUID()}`;
    const agentComponent = agentDef.component;
    const model =
      agentDef.model ||
      /** @type {any} */ (options).model ||
      this.config.models.agent;

    let currentMessages = [...messages];
    if (agentDef.system_prompt) {
      currentMessages.unshift({
        role: 'system',
        content: agentDef.system_prompt,
      });
    }

    const streamController = new AbortController();
    return new ReadableStream({
      start: async (controller) => {
        const send = (/** @type {any} */ data) =>
          controller.enqueue(
            new TextEncoder().encode(JSON.stringify(data) + '\n'),
          );
        try {
          for (let i = 0; i < 5; i++) {
            this.worker?.send({
              streamId,
              type: 'agent',
              messages: currentMessages,
              tools: agentDef.tools,
              model: model,
              options,
            });
            /** @type {ChatMessage} */
            let responseMessage = {
              role: 'assistant',
              content: '',
              tool_calls: [],
            };
            await new Promise((resolve, reject) => {
              const onMessage = (
                /** @type {{type: string, payload: any}} */ msg,
              ) => {
                if (msg.type === 'chunk') {
                  const chunk = msg.payload.message;
                  if (chunk.content) {
                    responseMessage.content += chunk.content;
                    send({ type: 'chunk', content: chunk.content });
                  }
                  if (chunk.tool_calls) {
                    responseMessage.tool_calls = chunk.tool_calls;
                  }
                } else if (msg.type === 'done') {
                  this.requestEmitter.removeListener(streamId, onMessage);
                  resolve(undefined);
                } else if (msg.type === 'error') {
                  this.requestEmitter.removeListener(streamId, onMessage);
                  reject(
                    new AIErrors.ChatError('Agent stream failed.', msg.payload),
                  );
                }
              };
              this.requestEmitter.on(streamId, onMessage);
            });

            if (
              !responseMessage.tool_calls ||
              responseMessage.tool_calls.length === 0
            ) {
              break;
            }

            currentMessages.push(responseMessage);
            /** @type {ChatMessage[]} */
            const toolResults = [];
            for (const toolCall of responseMessage.tool_calls) {
              const toolName = toolCall.function.name;
              const toolArgs = toolCall.function.arguments;
              const toolFn = agentComponent[toolName];

              if (typeof toolFn === 'function') {
                send({ type: 'tool_start', name: toolName, args: toolArgs });
                const result = await toolFn(toolContext, toolArgs);
                send({ type: 'tool_end', name: toolName, result: result });
                toolResults.push({
                  role: 'tool',
                  content: JSON.stringify(result),
                  tool_name: toolName,
                });
              }
            }
            currentMessages.push(...toolResults);
          }
        } catch (e) {
          controller.error(e);
        } finally {
          controller.close();
        }
      },
      cancel() {
        streamController.abort();
      },
    });
  }

  /**
   * @param {string} query
   * @param {number} [limit=5]
   * @param {object} [where={}]
   */
  async search(query, limit = 5, where = {}) {
    return this.store.search(query, limit, where);
  }

  async list() {
    return this.ollama.list();
  }

  /**
   * @param {string} model
   * @param {any} [options]
   */
  async pull(model, options) {
    return this.ollama.pull({ model, stream: true, ...options });
  }

  /** @param {string} model */
  async delete(model) {
    return this.ollama.delete({ model });
  }
}

---------- END: ai/ai.server.js ----------

---------- START: ai/ai.worker.js ----------
import { Ollama } from 'ollama';

/**
 * @typedef {object} ToolCall
 * @property {string} id
 * @property {object} function
 * @property {string} function.name
 * @property {object} function.arguments
 */

/**
 * @typedef {object} ChatMessage
 * @property {'user' | 'assistant' | 'system' | 'tool'} role - The role of the message sender.
 * @property {string} content - The content of the message.
 * @property {string | number} [user_id] - Optional user ID for filtering.
 * @property {ToolCall[]} [tool_calls] - Optional array of tool calls.
 * @property {string} [tool_call_id] - Optional tool call ID.
 */

/**
 * @typedef {object} Tool
 * @property {string} type
 * @property {object} function
 * @property {string} function.name
 * @property {string} function.description
 * @property {object} function.parameters
 * @property {string} function.parameters.type
 * @property {{ [key: string]: { type?: string | string[], items?: any, description?: string, enum?: any[] } }} function.parameters.properties
 */

const OLLAMA_HOST = process.env.OLLAMA_HOST || 'http://localhost:11434';
const CHAT_MODEL = process.env.CHAT_MODEL;
const AGENT_MODEL = process.env.AGENT_MODEL;

if (!CHAT_MODEL) {
  console.error(
    'AI Worker Error: CHAT_MODEL environment variable is required.',
  );
  process.exit(1);
}

const ollama = new Ollama({ host: OLLAMA_HOST });

/**
 * @param {{ opId: string; text: string; model: string; options: any; }} params
 */
async function handleEmbed({ opId, text, model, options }) {
  try {
    if (!model) {
      throw new Error('Embedding model was not provided in the request.');
    }
    const res = await ollama.embed({ model, input: text, options });
    const embedding =
      res.embeddings && res.embeddings[0] ? res.embeddings[0] : [];
    process.send?.({ opId, embedding });
  } catch (error) {
    process.send?.({
      opId,
      error: {
        message: /** @type {Error} */ (error).message,
        status: /** @type {any} */ (error).status,
      },
    });
  }
}

/**
 * @param {{ opId: string; texts: string[]; model: string; options: any; }} params
 */
async function handleEmbedBatch({ opId, texts, model, options }) {
  try {
    if (!model) {
      throw new Error('Embedding model was not provided in the request.');
    }
    const res = await ollama.embed({ model, input: texts, options });
    process.send?.({ opId, embeddings: res.embeddings });
  } catch (error) {
    process.send?.({
      opId,
      error: {
        message: /** @type {Error} */ (error).message,
        status: /** @type {any} */ (error).status,
      },
    });
  }
}

/**
 * @param {{ streamId: string; prompt: string; model: string; options: any; }} params
 */
async function handleGenerate({ streamId, prompt, model, options }) {
  try {
    const modelToUse = model || CHAT_MODEL;
    const stream = await ollama.generate({
      model: modelToUse ?? 'gemma3',
      prompt,
      stream: true,
      options,
    });
    for await (const chunk of stream) {
      process.send?.({
        streamId,
        type: 'chunk',
        payload: { response: chunk.response },
      });
    }
    process.send?.({ streamId, type: 'done' });
  } catch (error) {
    process.send?.({
      streamId,
      type: 'error',
      payload: {
        message: /** @type {Error} */ (error).message,
        status: /** @type {any} */ (error).status,
      },
    });
  }
}

/**
 * @param {{ streamId: string; messages: ChatMessage[]; model: string; options: any; }} params
 */
async function handleChat({ streamId, messages, model, options }) {
  try {
    const modelToUse = model || CHAT_MODEL;
    const stream = await ollama.chat({
      model: modelToUse ?? 'gemma3',
      messages,
      stream: true,
      options,
    });
    for await (const chunk of stream) {
      process.send?.({
        streamId,
        type: 'chunk',
        payload: { message: { content: chunk.message.content } },
      });
    }
    process.send?.({ streamId, type: 'done' });
  } catch (error) {
    process.send?.({
      streamId,
      type: 'error',
      payload: {
        message: /** @type {Error} */ (error).message,
        status: /** @type {any} */ (error).status,
      },
    });
  }
}

/**
 * @param {{ streamId: string; messages: ChatMessage[]; tools: Tool[]; model: string; options: any; }} params
 */
async function handleAgent({ streamId, messages, tools, model, options }) {
  try {
    const modelToUse = model || AGENT_MODEL;
    if (!modelToUse) {
      throw new Error('AGENT_MODEL environment variable is not set.');
    }
    const stream = await ollama.chat({
      model: modelToUse,
      messages,
      tools,
      stream: true,
      options,
    });

    for await (const chunk of stream) {
      process.send?.({
        streamId,
        type: 'chunk',
        payload: { message: chunk.message },
      });
    }
    process.send?.({ streamId, type: 'done' });
  } catch (error) {
    process.send?.({
      streamId,
      type: 'error',
      payload: {
        message: /** @type {Error} */ (error).message,
        status: /** @type {any} */ (error).status,
      },
    });
  }
}

process.on('message', (/** @type {any} */ msg) => {
  switch (msg.type) {
    case 'embed':
      handleEmbed(msg);
      break;
    case 'embed-batch':
      handleEmbedBatch(msg);
      break;
    case 'generate':
      handleGenerate(msg);
      break;
    case 'chat':
      handleChat(msg);
      break;
    case 'agent':
      handleAgent(msg);
      break;
  }
});

---------- END: ai/ai.worker.js ----------

---------- START: ai/ai.errors.js ----------
import { createLogger } from '../developer/logger.js';

const logger = createLogger('[Errors]');

/**
 * A custom error class for AI-related operations.
 * @class AIError
 * @extends {Error}
 * @property {Error | null} originalError - The original error that was caught, if any.
 */
export class AIError extends Error {
  /**
   * Creates an instance of AIError.
   * @param {string} message - The error message.
   * @param {Error | null} [originalError=null] - The original error object.
   */
  constructor(message, originalError = null) {
    const detailedMessage = originalError?.message
      ? `${message} -> ${originalError.message}`
      : message;
    super(detailedMessage);
    this.name = this.constructor.name;
    this.originalError = originalError;
    logger.error(`[AIError] ${detailedMessage}`);
  }
}

/** Error for timed-out operations. */
export class TimeoutError extends AIError {}
/** Error related to generating embeddings. */
export class EmbeddingError extends AIError {}
/** Error during a chat session. */
export class ChatError extends AIError {}
/** Error related to the vector store. */
export class StoreError extends AIError {}

/**
 * A collection of custom AI error classes.
 */
export const AIErrors = {
  AIError,
  TimeoutError,
  EmbeddingError,
  ChatError,
  StoreError,
};

---------- END: ai/ai.errors.js ----------

---------- START: ai/vector-store.js ----------
import { AIErrors } from './ai.errors.js';
import * as sqliteVec from 'sqlite-vec';
import { Database } from 'bun:sqlite';
import { dirname } from 'path';
import { ensureDir } from '../server/server-setup.js';

/**
 * @typedef {import('./ai.server.js').AI} AI
 */

/**
 * @typedef {object} AIConfig
 * @property {string} host
 * @property {{chat: string, embedding: string, labeling: string, agent?: string}} models
 * @property {{path: string}} worker
 * @property {{path: string, dimensions: number}} db
 */
/** @typedef {AIConfig} AIConfigForStore */

/**
 * @typedef {object} SearchResultMetadata
 * @property {string} filePath
 * @property {number} startLine
 * @property {number} endLine
 * @property {string} [className] - The name of the class containing the code chunk.
 * @property {string} [functionName] - The name of the function or method in the code chunk.
 * @property {string} [summary] - The AI-generated summary of the chunk.
 */

/**
 * @typedef {object} SearchResult
 * @property {string} text - The content of the search result.
 * @property {number} score - The relevance score of the result.
 * @property {SearchResultMetadata} metadata - Metadata associated with the result.
 */

export class Store {
  /**
   * @param {AIConfigForStore} config
   * @param {AI} aiInstance
   */
  constructor(config, aiInstance) {
    this.config = config;
    this.ai = aiInstance;
    /** @type {Database | null} */
    this.db = null;
  }

  async init() {
    if (process.platform === 'darwin') {
      try {
        Database.setCustomSQLite('/usr/local/opt/sqlite3/lib/libsqlite3.dylib');
      } catch (e) {
        console.warn(
          `[Store] Could not set custom SQLite library. If you're on macOS and this fails, please install SQLite with Homebrew ('brew install sqlite').`,
        );
      }
    }

    await ensureDir(dirname(this.config.db.path));

    this.db = new Database(this.config.db.path, { create: true });
    sqliteVec.load(this.db);

    this.db.exec(`
      CREATE VIRTUAL TABLE IF NOT EXISTS vec_store USING vec0(
        embedding float[${this.config.db.dimensions}]
      );
      CREATE TABLE IF NOT EXISTS text_meta (
          vec_id INTEGER PRIMARY KEY,
          text_content TEXT NOT NULL,
          file_path TEXT,
          start_line INTEGER,
          end_line INTEGER,
          summary TEXT
      );
    `);

    const columns = this.db.prepare('PRAGMA table_info(text_meta)').all();
    if (
      !columns.some(
        (/** @type {{ name: string; }} */ c) => c.name === 'user_id',
      )
    ) {
      this.db.exec('ALTER TABLE text_meta ADD COLUMN user_id INTEGER');
    }
    if (
      !columns.some(
        (/** @type {{ name: string; }} */ c) => c.name === 'class_name',
      )
    ) {
      this.db.exec('ALTER TABLE text_meta ADD COLUMN class_name TEXT');
    }
    if (
      !columns.some(
        (/** @type {{ name: string; }} */ c) => c.name === 'function_name',
      )
    ) {
      this.db.exec('ALTER TABLE text_meta ADD COLUMN function_name TEXT');
    }
    if (
      !columns.some(
        (/** @type {{ name: string; }} */ c) => c.name === 'summary',
      )
    ) {
      this.db.exec('ALTER TABLE text_meta ADD COLUMN summary TEXT');
    }
  }

  /**
   * @param {Array<{content: string, embedding: Float32Array, metadata: any}>} documents
   */
  async indexBatch(documents) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    if (!documents || documents.length === 0) return;

    try {
      const tx = this.db.transaction((docs) => {
        if (!this.db)
          throw new AIErrors.StoreError('Database not initialized.');
        const insertVecStmt = this.db.prepare(
          'INSERT INTO vec_store (embedding) VALUES (?)',
        );
        const insertMetaStmt = this.db.prepare(
          'INSERT INTO text_meta (vec_id, text_content, file_path, user_id, start_line, end_line, class_name, function_name, summary) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
        );

        for (const doc of docs) {
          const { lastInsertRowid } = insertVecStmt.run(doc.embedding);
          const meta = doc.metadata;
          insertMetaStmt.run(
            lastInsertRowid,
            doc.content,
            meta.filePath,
            meta.userId ?? null,
            meta.startLine,
            meta.endLine,
            meta.className ?? null,
            meta.functionName ?? null,
            meta.summary ?? null,
          );
        }
      });

      tx(documents);
    } catch (error) {
      const typedError =
        error instanceof Error ? error : new Error(String(error));
      throw new AIErrors.StoreError(
        'Failed to execute batch index.',
        typedError,
      );
    }
  }

  /**
   * @param {string} text
   * @param {any} metadata
   */
  async index(text, metadata) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    try {
      const embedding = await this.ai.embed(text);

      const tx = this.db.transaction(() => {
        if (!this.db)
          throw new AIErrors.StoreError('Database not initialized.');

        const { lastInsertRowid } = this.db
          .prepare('INSERT INTO vec_store (embedding) VALUES (?)')
          .run(embedding);

        this.db
          .prepare(
            'INSERT INTO text_meta (vec_id, text_content, file_path, user_id, start_line, end_line, class_name, function_name, summary) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
          )
          .run(
            lastInsertRowid,
            text,
            metadata.filePath,
            metadata.userId ?? null,
            metadata.startLine,
            metadata.endLine,
            metadata.className ?? null,
            metadata.functionName ?? null,
            metadata.summary ?? null,
          );
      });

      tx();
      return { success: true, text };
    } catch (error) {
      if (error instanceof AIErrors.AIError) throw error;
      throw new AIErrors.StoreError(
        `Failed to index chunk for ${metadata.filePath}.`,
        /** @type {Error} */ (error),
      );
    }
  }

  /**
   * @param {string} text
   * @param {Float32Array} embedding
   * @param {any} metadata
   */
  async indexWithEmbedding(text, embedding, metadata) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    try {
      const tx = this.db.transaction(() => {
        if (!this.db)
          throw new AIErrors.StoreError('Database not initialized.');
        const { lastInsertRowid } = this.db
          .prepare('INSERT INTO vec_store (embedding) VALUES (?)')
          .run(embedding);

        this.db
          .prepare(
            'INSERT INTO text_meta (vec_id, text_content, file_path, user_id, start_line, end_line, class_name, function_name, summary) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
          )
          .run(
            lastInsertRowid,
            text,
            metadata.filePath,
            metadata.userId ?? null,
            metadata.startLine,
            metadata.endLine,
            metadata.className ?? null,
            metadata.functionName ?? null,
            metadata.summary ?? null,
          );
      });

      tx();
      return { success: true, text };
    } catch (error) {
      if (error instanceof AIErrors.AIError) throw error;
      throw new AIErrors.StoreError(
        `Failed to index chunk for ${metadata.filePath}.`,
        /** @type {Error} */ (error),
      );
    }
  }
  /**
   * @param {string} filePath
   * @param {string | number | undefined} userId
   */
  async remove(filePath, userId) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    try {
      const tx = this.db.transaction(() => {
        if (!this.db)
          throw new AIErrors.StoreError('Database not initialized.');
        const records = this.db
          .prepare(
            'SELECT vec_id FROM text_meta WHERE file_path = ? AND (user_id = ? OR user_id IS NULL)',
          )
          .all(filePath, userId ?? null);
        if (records.length > 0) {
          const ids = records.map((/** @type {{vec_id: any}} */ r) => r.vec_id);
          const placeholders = ids.map(() => '?').join(',');
          this.db
            .prepare(`DELETE FROM vec_store WHERE rowid IN (${placeholders})`)
            .run(...ids);
          this.db
            .prepare(`DELETE FROM text_meta WHERE vec_id IN (${placeholders})`)
            .run(...ids);
        }
      });
      tx();
      return { success: true, filePath };
    } catch (error) {
      throw new AIErrors.StoreError(
        `Failed to remove document index for ${filePath}.`,
        /** @type {Error} */ (error),
      );
    }
  }
  /**
   * @param {string} query
   * @param {number} [limit=5]
   * @param {{userId?: string | number}} [where={}]
   */
  async search(query, limit = 5, where = {}) {
    if (!this.db) throw new AIErrors.StoreError('Database not initialized.');
    try {
      const embedding = await this.ai.embed(query);
      if (!embedding || embedding.length === 0) return [];

      const candidateLimit = limit * 10;
      let whereClause = '';
      /** @type {any[]} */
      const params = [embedding, candidateLimit];

      if (where.userId) {
        whereClause = 'WHERE meta.user_id = ?';
        params.push(where.userId);
      }

      const sql = `
        SELECT
          meta.text_content as text,
          meta.file_path as filePath,
          meta.start_line as startLine,
          meta.end_line as endLine,
          meta.class_name as className,
          meta.function_name as functionName,
          meta.summary as summary,
          v.distance as score
        FROM (
          SELECT rowid, distance
          FROM vec_store
          WHERE embedding MATCH ?
          ORDER BY distance
          LIMIT ?
        ) as v
        JOIN text_meta AS meta ON v.rowid = meta.vec_id
        ${whereClause};
      `;

      const candidateResults = this.db.query(sql).all(...params);

      /** @type {Map<string, SearchResult>} */
      const uniqueFileResults = new Map();
      for (const result of candidateResults) {
        const filePath = /** @type {string} */ (result.filePath);
        const existing = uniqueFileResults.get(filePath);
        if (
          !existing ||
          /** @type {number} */ (result.score) < existing.score
        ) {
          uniqueFileResults.set(filePath, {
            text: /** @type {string} */ (result.text),
            score: /** @type {number} */ (result.score),
            metadata: {
              filePath: filePath,
              startLine: /** @type {number} */ (result.startLine),
              endLine: /** @type {number} */ (result.endLine),
              className: /** @type {string | undefined} */ (result.className),
              functionName: /** @type {string | undefined} */ (
                result.functionName
              ),
              summary: /** @type {string | undefined} */ (result.summary),
            },
          });
        }
      }

      return Array.from(uniqueFileResults.values())
        .sort((a, b) => a.score - b.score)
        .slice(0, limit);
    } catch (error) {
      if (error instanceof AIErrors.AIError) throw error;
      throw new AIErrors.StoreError(
        `Failed to execute search.`,
        /** @type {Error} */ (error),
      );
    }
  }

  close() {
    if (this.db) {
      this.db.close();
    }
  }
}

---------- END: ai/vector-store.js ----------

---------- START: utils/lang.js ----------
/**
 * @file Contains basic language utility functions for type checking.
 */

/**
 * Checks if a value is a plain object.
 * @param {any} val - The value to check.
 * @returns {val is object} `true` if the value is an object, not an array, and not null.
 */
export const isObject = (val) =>
  val !== null && typeof val === 'object' && !Array.isArray(val);

/**
 * Checks if a value is a string.
 * @param {any} val - The value to check.
 * @returns {val is string} `true` if the value is a string.
 */
export const isString = (val) => typeof val === 'string';

/**
 * Checks if a value is a function.
 * @param {any} val - The value to check.
 * @returns {val is Function} `true` if the value is a function.
 */
export const isFunction = (val) => typeof val === 'function';

---------- END: utils/lang.js ----------

---------- START: utils/dom.js ----------
/**
 * @file DOM-related utility functions.
 */

import { isObject, isString } from './lang.js';

/**
 * @typedef {string | Record<string, boolean> | Array<string | Record<string, boolean>>} ClassValue
 */

/**
 * A set of HTML tags that are self-closing (void elements).
 * @type {Set<string>}
 */
export const voidElements = new Set([
  'area',
  'base',
  'br',
  'col',
  'embed',
  'hr',
  'img',
  'input',
  'link',
  'meta',
  'param',
  'source',
  'track',
  'wbr',
]);

/**
 * Normalizes a class attribute value into a single space-separated string.
 * It can handle string, object, and array formats for defining classes.
 *
 * @example
 * normalizeClass('foo bar');
 * normalizeClass({ foo: true, bar: false, baz: true });
 * normalizeClass(['foo', { bar: true }]);
 *
 * @param {ClassValue} value - The class value to normalize.
 * @returns {string} The normalized class string.
 */
export function normalizeClass(value) {
  let res = '';
  if (isString(value)) {
    res = value;
  } else if (Array.isArray(value)) {
    for (const item of value) {
      const normalized = normalizeClass(/** @type {ClassValue} */ (item));
      if (normalized) res += normalized + ' ';
    }
  } else if (isObject(value)) {
    for (const key in value) {
      if (value[key]) res += key + ' ';
    }
  }
  return res.trim();
}

---------- END: utils/dom.js ----------

---------- START: utils/common.js ----------
/**
 * @file Shared utility functions used across the framework, safe for both client and server environments.
 */

/**
 * Generates a universally unique identifier (UUID) v4.
 * Uses the browser's or Node.js's native `crypto.randomUUID` if available,
 * otherwise falls back to a Math.random-based implementation.
 * @returns {string} The generated UUID.
 */
export function generateUUID() {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

---------- END: utils/common.js ----------

---------- START: server/server-config.js ----------
import { resolve } from 'path';

/**
 * @typedef {object} Config
 * @property {string} CWD
 * @property {string | number} PORT
 * @property {boolean} IS_PROD
 * @property {string} OUTDIR
 * @property {string} TMPDIR
 * @property {string} TMP_COMPILED_DIR
 * @property {string} TMP_WRAPPERS_DIR
 * @property {string} TMP_APP_JS
 * @property {string} TMP_APP_CSS
 * @property {string} SRC_DIR
 * @property {string} APP_DIR
 * @property {string} PUB_DIR
 * @property {string} GUI_DIR
 * @property {string} LIB_DIR
 * @property {string} USER_FILES_ROOT
 * @property {string} TMP_GENERATED_ACTIONS
 * @property {string} TMP_COMPONENT_REGISTRY
 */

/**
 * @typedef {object} AIConfig
 * @property {string} host
 * @property {{ agent: string, chat: string, embedding: string, labeling: string }} models
 * @property {{ path: string, dimensions: number }} db
 * @property {{ path: string }} worker
 */

const userProjectDir = process.argv[2]
  ? resolve(process.argv[2])
  : process.cwd();
const FRAMEWORK_DIR = import.meta.dir;

/** @type {Config} */
export const config = {
  CWD: userProjectDir,
  PORT: process.env.PORT || 3000,
  IS_PROD: process.env.NODE_ENV === 'production',
  OUTDIR: resolve(userProjectDir, 'dist'),
  TMPDIR: resolve(userProjectDir, '.webs'),
  TMP_COMPILED_DIR: resolve(userProjectDir, '.webs/compiled'),
  TMP_WRAPPERS_DIR: resolve(userProjectDir, '.webs/layout'),
  TMP_APP_JS: resolve(userProjectDir, '.webs/app.js'),
  TMP_APP_CSS: resolve(userProjectDir, '.webs/app.css'),
  SRC_DIR: resolve(userProjectDir, 'src'),
  APP_DIR: resolve(userProjectDir, 'src/app'),
  PUB_DIR: resolve(userProjectDir, 'src/pub'),
  GUI_DIR: resolve(userProjectDir, 'src/gui'),
  LIB_DIR: resolve(FRAMEWORK_DIR, '../../lib'),
  USER_FILES_ROOT: resolve(userProjectDir, '.webs/files'),
  TMP_GENERATED_ACTIONS: resolve(userProjectDir, '.webs/actions.js'),
  TMP_COMPONENT_REGISTRY: resolve(userProjectDir, '.webs/registry.js'),
};

/** @type {AIConfig} */
export const aiConfig = {
  host: process.env.OLLAMA_HOST || 'http://localhost:11434',
  models: {
    agent: process.env.AGENT_MODEL || 'gpt-oss',
    chat: process.env.CHAT_MODEL || 'gemma3',
    labeling: process.env.LABEL_MODEL || 'gemma3:270m',
    embedding: process.env.EMBED_MODEL || 'embeddinggemma',
  },
  db: {
    path: '.webs/ai.db',
    dimensions: 768,
  },
  worker: {
    path: resolve(FRAMEWORK_DIR, '../ai/ai.worker.js'),
  },
};

export function getDbConfig() {
  const schema = {
    name: 'fw.db',
    version: 1, // Changed version from 0 to 1
    tables: {
      users: {
        keyPath: 'id',
        fields: {
          id: { type: 'integer', primaryKey: true },
          email: { type: 'text', notNull: true, unique: true },
          username: { type: 'text', notNull: true, unique: true },
          password: { type: 'text', notNull: true },
          created_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
      },
      sessions: {
        keyPath: 'id',
        fields: {
          id: { type: 'text', primaryKey: true },
          user_id: {
            type: 'integer',
            notNull: true,
            references: 'users(id)',
            onDelete: 'CASCADE',
          },
          expires_at: { type: 'timestamp', notNull: true },
        },
      },
      files: {
        sync: true,
        keyPath: 'path',
        primaryKeys: ['path', 'user_id'],
        fields: {
          path: { type: 'text', notNull: true },
          user_id: {
            type: 'integer',
            notNull: true,
            references: 'users(id)',
            onDelete: 'CASCADE',
          },
          content: { type: 'blob', notNull: true },
          access: { type: 'text', notNull: true, default: 'private' },
          size: { type: 'integer', notNull: true, default: 0 },
          last_modified: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
          updated_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
        indexes: [{ name: 'by-user', keyPath: 'user_id' }],
      },
      todos: {
        sync: true,
        keyPath: 'id',
        fields: {
          id: { type: 'text', primaryKey: true },
          content: { type: 'text', notNull: true },
          completed: { type: 'integer', notNull: true, default: 0 },
          user_id: {
            type: 'integer',
            notNull: true,
            references: 'users(id)',
            onDelete: 'CASCADE',
          },
          created_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
          updated_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
        indexes: [{ name: 'by-user', keyPath: 'user_id' }],
      },
      chat_channels: {
        sync: true,
        keyPath: 'id',
        fields: {
          id: { type: 'text', primaryKey: true },
          name: { type: 'text', notNull: true },
          topic: { type: 'text' },
          owner_id: {
            type: 'integer',
            references: 'users(id)',
            onDelete: 'SET NULL',
          },
          created_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
      },
      channel_members: {
        sync: true,
        primaryKeys: ['channel_id', 'user_id'],
        fields: {
          channel_id: {
            type: 'text',
            notNull: true,
            references: 'chat_channels(id)',
            onDelete: 'CASCADE',
          },
          user_id: {
            type: 'integer',
            notNull: true,
            references: 'users(id)',
            onDelete: 'CASCADE',
          },
          joined_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
        indexes: [{ name: 'by-user', keyPath: 'user_id' }],
      },
      chat_messages: {
        sync: true,
        keyPath: 'id',
        fields: {
          id: { type: 'text', primaryKey: true },
          channel_id: {
            type: 'text',
            notNull: true,
            references: 'chat_channels(id)',
            onDelete: 'CASCADE',
          },
          username: { type: 'text', notNull: true },
          message: { type: 'text', notNull: true },
          user_id: {
            type: 'integer',
            references: 'users(id)',
            onDelete: 'SET NULL',
          },
          created_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
          updated_at: { type: 'timestamp', default: 'CURRENT_TIMESTAMP' },
        },
        indexes: [{ name: 'by-channel', keyPath: 'channel_id' }],
      },
    },
  };

  const clientTables = Object.entries(schema.tables)
    .filter(([, def]) => /** @type {any} */ (def).sync)
    .map(([name, def]) => ({
      name,
      keyPath: /** @type {any} */ (def).keyPath,
      autoIncrement: /** @type {any} */ (def).autoIncrement,
      indexes: /** @type {any} */ (def).indexes,
    }));

  return { ...schema, clientTables };
}

---------- END: server/server-config.js ----------

---------- START: server/db.server.js ----------
import { resolve as pathResolve } from 'path';
import { Database } from 'bun:sqlite';
import { createLogger } from '../developer/logger.js';

/**
 * @typedef {object} Field
 * @property {string} type
 * @property {boolean} [primaryKey]
 * @property {boolean} [notNull]
 * @property {boolean} [unique]
 * @property {any} [default]
 * @property {string} [references]
 * @property {string} [onDelete]
 */

/**
 * @typedef {object} Table
 * @property {string[]} [primaryKeys]
 * @property {string} [keyPath]
 * @property {Record<string, Field | string>} fields
 * @property {boolean} [sync]
 * @property {{ name: string, keyPath: string }[]} [indexes]
 */

const logger = createLogger('[DB]');

/**
 * @param {string} type
 */
function toSqliteType(type) {
  switch (type) {
    case 'string':
    case 'text':
      return 'TEXT';
    case 'number':
    case 'integer':
      return 'INTEGER';
    case 'boolean':
      return 'INTEGER';
    case 'float':
    case 'real':
      return 'REAL';
    case 'buffer':
    case 'blob':
      return 'BLOB';
    case 'timestamp':
      return 'TIMESTAMP';
    default:
      return 'TEXT';
  }
}
/**
 * @param {string} name
 * @param {Field | string} props
 */
function getColumnSql(name, props) {
  const definition = typeof props === 'string' ? { type: props } : props;
  let columnSql = `"${name}" ${toSqliteType(definition.type)}`;
  if (definition.primaryKey) columnSql += ' PRIMARY KEY';
  if (definition.notNull) columnSql += ' NOT NULL';
  if (definition.unique) columnSql += ' UNIQUE';
  if (definition.default !== undefined) {
    columnSql += ` DEFAULT ${
      typeof definition.default === 'string'
        ? `'${definition.default}'`
        : definition.default
    }`;
  }
  return columnSql;
}

/**
 * @param {string} tableName
 * @param {Table} table
 */
function createTableSql(tableName, table) {
  const fields = Object.entries(table.fields).map(([name, props]) =>
    getColumnSql(name, props),
  );

  const foreignKeys = Object.entries(table.fields)
    .filter(([, props]) => typeof props !== 'string' && props.references)
    .map(([fieldName, props]) => {
      let fkSql = `FOREIGN KEY ("${fieldName}") REFERENCES ${
        /** @type {Field} */ (props).references
      }`;
      if (/** @type {Field} */ (props).onDelete)
        fkSql += ` ON DELETE ${/** @type {Field} */ (props).onDelete}`;
      return fkSql;
    });

  const constraints = [...foreignKeys];
  if (table.primaryKeys && table.primaryKeys.length > 0) {
    constraints.push(
      `PRIMARY KEY (${table.primaryKeys.map((pk) => `"${pk}"`).join(', ')})`,
    );
  }

  const constraintsSql =
    constraints.length > 0 ? `, ${constraints.join(', ')}` : '';

  return `CREATE TABLE IF NOT EXISTS "${tableName}" (${fields.join(
    ', ',
  )}${constraintsSql});`;
}
/**
 * @param {[string, Table][]} syncableTables
 */
function createActionsFileContent(syncableTables) {
  const actions = syncableTables
    .map(([tableName, table]) => {
      const upperCaseName =
        tableName.charAt(0).toUpperCase() + tableName.slice(1);
      const fieldNames = Object.keys(table.fields);

      let updateSet = fieldNames
        .filter((f) => {
          const pks =
            table.primaryKeys || (table.keyPath ? [table.keyPath] : []);
          return !pks.includes(f) && f !== 'created_at';
        })
        .map((f) => `"${f}" = excluded."${f}"`);

      if (table.fields.updated_at)
        updateSet.push(`updated_at = CURRENT_TIMESTAMP`);

      const conflictTarget = (
        table.primaryKeys || (table.keyPath ? [table.keyPath] : [])
      )
        .map((pk) => `"${pk}"`)
        .join(', ');

      const upsertSql = `INSERT INTO "${tableName}" (${fieldNames
        .map((f) => `"${f}"`)
        .join(', ')}) VALUES (${fieldNames
        .map((f) => `$${f}`)
        .join(
          ', ',
        )}) ON CONFLICT(${conflictTarget}) DO UPDATE SET ${updateSet.join(
        ', ',
      )}`
        .trim()
        .replace(/\s+/g, ' ');

      const deleteKeys =
        table.primaryKeys || (table.keyPath ? [table.keyPath] : []);
      const deleteWhereClause = deleteKeys
        .map((key) => `"${key}" = $${key}`)
        .join(' AND ');
      const deleteSql = `DELETE FROM "${tableName}" WHERE ${deleteWhereClause};`;

      const deleteActionBody =
        tableName === 'files'
          ? `
      if (!user?.id) throw new Error('Authorization error.');
      const recordToDelete = db.query('SELECT user_id FROM files WHERE path = ? AND user_id = ?').get(record.path, user.id);
      if (!recordToDelete) return { error: 'File not found or permission denied.'};
      delete${upperCaseName}Stmt.run({ $path: record.path, $user_id: user.id });
      return { broadcast: { tableName: '${tableName}', type: 'delete', id: [record.path, user.id] } };
    `
          : `
      if (!user?.id) throw new Error('Authorization error.');
      const recordToDelete = db.query('SELECT user_id FROM "${tableName}" WHERE id = ? AND user_id = ?').get(record.id, user.id);
      if (!recordToDelete) return { error: 'Record not found or permission denied.' };
      delete${upperCaseName}Stmt.run({ $id: record.id, $user_id: user.id });
      return { broadcast: { tableName: '${tableName}', type: 'delete', id: record.id } };
    `;

      return `
    const upsert${upperCaseName}Stmt = db.prepare(\`${upsertSql}\`);
    const delete${upperCaseName}Stmt = db.prepare(\`${deleteSql}\`);
    actions.upsert${upperCaseName} = ({ user }, record) => {
      if (!user?.id || (record.user_id && user.id !== record.user_id)) throw new Error('Authorization error.');
      const finalRecord = { ...record, user_id: user.id, updated_at: new Date().toISOString() };
      const params = Object.fromEntries(Object.entries(finalRecord).map(([key, value]) => [\`$\${key}\`, value]));
      upsert${upperCaseName}Stmt.run(params);
      return { broadcast: { tableName: '${tableName}', type: 'put', data: finalRecord } };
    };
    actions.delete${upperCaseName} = ({ user }, record) => {
      ${deleteActionBody}
    };`;
    })
    .join('');

  return `export function registerActions(db) { const actions = {}; ${actions} return actions; };`;
}
/**
 * @param {object} dbConfig
 * @param {string} dbConfig.name
 * @param {number} dbConfig.version
 * @param {Record<string, Table>} dbConfig.tables
 * @param {string} cwd
 * @param {(path: string, content: string) => Promise<void>} writeFile
 * @param {object} config
 * @param {string} config.TMP_GENERATED_ACTIONS
 * @returns {Promise<Database>}
 */
export async function setupDatabase(dbConfig, cwd, writeFile, config) {
  if (!dbConfig?.name) throw new Error('Database file name not specified.');
  const dbFilePath = pathResolve(cwd, `.webs/${dbConfig.name}`);
  const db = new Database(dbFilePath, { create: true });
  db.run('PRAGMA journal_mode = WAL; PRAGMA foreign_keys = ON;');
  db.run(
    `CREATE TABLE IF NOT EXISTS _migrations (version INTEGER PRIMARY KEY);`,
  );

  const lastVersion =
    db
      .query('SELECT version FROM _migrations ORDER BY version DESC LIMIT 1')
      .get()?.version || 0;

  if (dbConfig.version > lastVersion) {
    logger.info(
      `Migrating database from v${lastVersion} to v${dbConfig.version}...`,
    );
    const migrationTx = db.transaction(() => {
      Object.entries(dbConfig.tables).forEach(([tableName, tableDef]) => {
        db.run(createTableSql(tableName, tableDef));
        const existingColumns = db
          .prepare(`PRAGMA table_info("${tableName}")`)
          .all()
          .map((/** @type {{ name: any; }} */ col) => col.name);
        Object.entries(tableDef.fields).forEach(([fieldName, fieldProps]) => {
          if (!existingColumns.includes(fieldName)) {
            logger.debug(
              `Adding column '${fieldName}' to table '${tableName}'.`,
            );
            db.run(
              `ALTER TABLE "${tableName}" ADD COLUMN ${getColumnSql(
                fieldName,
                fieldProps,
              )}`,
            );
          }
        });
        if (tableDef.indexes) {
          tableDef.indexes.forEach((index) => {
            logger.debug(
              `Creating index '${index.name}' on table '${tableName}'.`,
            );
            db.run(
              `CREATE INDEX IF NOT EXISTS "${index.name}" ON "${tableName}" ("${index.keyPath}")`,
            );
          });
        }
      });
      db.query('INSERT INTO _migrations (version) VALUES (?)').run(
        dbConfig.version,
      );
    });
    migrationTx();
    logger.info('Database migration complete.');
  }

  const syncableTables = Object.entries(dbConfig.tables).filter(
    ([, def]) => def.sync,
  );
  const generatedActionsContent = createActionsFileContent(syncableTables);
  await writeFile(config.TMP_GENERATED_ACTIONS, generatedActionsContent);
  logger.info('Generated sync actions file.');
  return db;
}

---------- END: server/db.server.js ----------

---------- START: server/server.js ----------
import { createFetchHandler } from './router.js';
import { createLogger } from '../developer/logger.js';
import { createFileSystemForUser } from './fs.server.js';

/**
 * @typedef {import('bun:sqlite').Database} Database
 * @typedef {import('bun').Server} Server
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('../ai/ai.server.js').AI} AI
 */

/**
 * @template T
 * @typedef {import('bun').ServerWebSocket<T>} ServerWebSocket
 */

/**
 * @typedef {object} ServerContext
 * @property {Database} db
 * @property {any} dbConfig
 * @property {boolean} isProd
 * @property {Config} config
 * @property {string} SYNC_TOPIC
 * @property {string} HMR_TOPIC
 * @property {AI} ai
 * @property {Record<string, Function>} syncActions
 * @property {any} manifest
 * @property {Record<string, any>} appRoutes
 * @property {any} agentRoutes
 * @property {any} globalComponents
 * @property {any} sourceToComponentMap
 */

/**
 * @typedef {object} WebSocketData
 * @property {boolean} [isSyncChannel]
 * @property {boolean} [isHmrChannel]
 * @property {any} [user]
 * @property {any} [params]
 * @property {Record<string, Function>} [wsHandlers]
 */

/**
 * @typedef {object} WebSocketHandlerContext
 * @property {ServerWebSocket<WebSocketData>} socket - The WebSocket connection instance.
 * @property {import('./authentication.js').UserInfo | null} user - The authenticated user.
 * @property {Record<string, string>} params - The route parameters.
 * @property {Database} db - The database instance.
 * @property {import('./fs.server.js').ServerFsApi} fs - The user-scoped file system API.
 */

/**
 * @typedef {(context: WebSocketHandlerContext) => Promise<void> | void} OpenHandler
 * @typedef {(context: WebSocketHandlerContext & { message: string | Buffer }) => Promise<void> | void} MessageHandler
 * @typedef {(context: WebSocketHandlerContext) => Promise<void> | void} CloseHandler
 * @typedef {(context: WebSocketHandlerContext & { error: Error }) => Promise<void> | void} ErrorHandler
 */

const logger = createLogger('[Server]');

/**
 * This function starts the main web server, fully restoring the logic from `server-old.js`.
 * @param {ServerContext} serverContext
 */
export async function startServer(serverContext) {
  const { db, dbConfig, isProd, config, SYNC_TOPIC, HMR_TOPIC, syncActions } =
    serverContext;
  const { PORT } = config;

  const fetchHandler = createFetchHandler(serverContext);

  logger.info('Starting Webs server...');

  const serverOptions = {
    port: PORT,
    development: !isProd,
    fetch: fetchHandler,
    websocket: {
      /**
       * @param {ServerWebSocket<WebSocketData>} ws
       */
      open(ws) {
        if (ws.data?.isSyncChannel) {
          logger.info(
            'WebSocket client connected and subscribed to sync topic.',
          );
          ws.subscribe(SYNC_TOPIC);
          return;
        }

        if (ws.data?.isHmrChannel) {
          logger.info('HMR WebSocket client connected.');
          ws.subscribe(HMR_TOPIC);
          return;
        }

        const { wsHandlers, user, params } = ws.data;
        if (wsHandlers?.onOpen) {
          wsHandlers.onOpen({
            socket: ws,
            user,
            params,
            db,
            fs: createFileSystemForUser(user.id),
          });
        }
      },
      /**
       * @param {ServerWebSocket<WebSocketData>} ws
       * @param {string | Buffer} message
       */
      async message(ws, message) {
        if (ws.data?.isSyncChannel) {
          const server = Bun.serve(serverOptions);
          await handleSyncMessage(ws, message, server);
          server.stop();
          return;
        }

        const { wsHandlers, user, params } = ws.data;
        if (wsHandlers?.onMessage) {
          wsHandlers.onMessage({
            socket: ws,
            message,
            user,
            params,
            db,
            fs: createFileSystemForUser(user.id),
          });
        }
      },
      /**
       * @param {ServerWebSocket<WebSocketData>} ws
       * @param {number} _code
       * @param {string} _reason
       */
      close(ws, _code, _reason) {
        if (ws.data?.isSyncChannel) {
          ws.unsubscribe(SYNC_TOPIC);
          return;
        }
        if (ws.data?.isHmrChannel) {
          ws.unsubscribe(HMR_TOPIC);
          return;
        }

        const { wsHandlers, user, params } = ws.data;
        if (wsHandlers?.onClose) {
          wsHandlers.onClose({
            socket: ws,
            user,
            params,
            db,
            fs: createFileSystemForUser(user.id),
          });
        }
      },
      /**
       * @param {ServerWebSocket<WebSocketData>} ws
       * @param {Error} error
       */
      error(ws, error) {
        const { wsHandlers, user, params } = ws.data;
        if (wsHandlers?.onError) {
          wsHandlers.onError({
            socket: ws,
            error,
            user,
            params,
            db,
            fs: createFileSystemForUser(user?.id),
          });
        } else {
          logger.error('WebSocket error:', error);
        }
      },
    },
    error: (/** @type {Error} */ err) => {
      logger.error('Internal server error occurred:', err);
      return new Response('Internal Server Error', { status: 500 });
    },
  };

  /**
   * Handles incoming WebSocket messages for data synchronization.
   * @param {import('bun').ServerWebSocket<{user?: any}>} ws
   * @param {string | Buffer} message
   * @param {Server} server
   */
  async function handleSyncMessage(ws, message, server) {
    let payload;
    try {
      payload = JSON.parse(String(message));
      const { opId, type } = payload;
      const user = ws.data.user;

      if (type?.startsWith('fs:')) {
        const fs = createFileSystemForUser(user.id);
        const { path, data, options } = payload;
        let broadcastPayload;

        if (type === 'fs:write') {
          await fs.write(path, data, options);
          const stats = await fs.stat(path, options);
          const fileBlob = await fs.cat(path, options);
          const record = {
            path,
            user_id: user.id,
            content: await fileBlob.arrayBuffer(),
            access: options?.access || 'private',
            size: stats.size,
            last_modified: new Date().toISOString(),
          };
          if (syncActions.upsertFiles) {
            broadcastPayload = syncActions.upsertFiles(
              { user },
              record,
            )?.broadcast;
          }
        } else if (type === 'fs:rm') {
          await fs.rm(path, options);
          if (syncActions.deleteFiles) {
            broadcastPayload = syncActions.deleteFiles(
              { user },
              { path, user_id: user.id },
            )?.broadcast;
          }
        }

        ws.send(JSON.stringify({ type: 'ack', opId }));
        if (broadcastPayload) {
          server.publish(
            SYNC_TOPIC,
            JSON.stringify({ type: 'sync', data: broadcastPayload }),
          );
        }
      } else {
        const { tableName, data: recordData, id } = payload;
        if (
          !opId ||
          !type ||
          !tableName ||
          !dbConfig?.tables?.[tableName]?.sync
        ) {
          throw new Error('Invalid sync operation.');
        }

        const actionName =
          type === 'put'
            ? `upsert${tableName.charAt(0).toUpperCase() + tableName.slice(1)}`
            : `delete${tableName.charAt(0).toUpperCase() + tableName.slice(1)}`;
        const actionFn = syncActions[actionName];
        if (!actionFn)
          throw new Error(`Sync action '${actionName}' not found.`);

        const result = await actionFn(
          { user },
          type === 'put' ? recordData : { id },
        );
        if (result?.broadcast) {
          server.publish(
            SYNC_TOPIC,
            JSON.stringify({ type: 'sync', data: result.broadcast }),
          );
        }
        ws.send(JSON.stringify({ type: 'ack', opId }));
      }
    } catch (e) {
      const error = /** @type {Error} */ (e);
      logger.error('Sync Error:', error.message);
      ws.send(
        JSON.stringify({
          type: 'sync-error',
          opId: payload?.opId,
          error: error.message,
        }),
      );
    }
  }

  logger.info(`Server running at http://localhost:${PORT}`);
  return serverOptions;
}

---------- END: server/server.js ----------

---------- START: server/server-setup.js ----------
import { exists, mkdir, writeFile } from 'fs/promises';
import { join, dirname } from 'path';
import { hashPassword } from './authentication.js';
import { generateUUID } from '../utils/common.js';
import { createLogger } from '../developer/logger.js';

/**
 * @typedef {import('bun:sqlite').Database} Database
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('../ai/ai.server.js').AI} AI
 */

/**
 * @typedef {object} Todo
 * @property {string} id
 * @property {string} content
 * @property {number} completed
 * @property {any} user_id
 */

const logger = createLogger('[Dev]');

/**
 * Ensures that a directory exists, creating it if necessary.
 * @param {string} dirPath
 */
export async function ensureDir(dirPath) {
  if (!(await exists(dirPath))) await mkdir(dirPath, { recursive: true });
}

/**
 * @param {Database} db
 * @param {Config} config
 * @param {AI} ai
 */
export async function seedDevDatabase(db, config, ai) {
  const anonUser = {
    email: 'anon@webs.site',
    username: 'anon',
    password: 'password',
  };
  let existingUser = db
    .query('SELECT id FROM users WHERE username = ?')
    .get(anonUser.username);
  let anonUserId;

  if (existingUser) {
    anonUserId = existingUser.id;
  } else {
    const hashedPassword = await hashPassword(anonUser.password);
    const result = db
      .prepare('INSERT INTO users (email, username, password) VALUES (?, ?, ?)')
      .run(anonUser.email, anonUser.username, hashedPassword);
    anonUserId = result.lastInsertRowid;
  }

  if (!anonUserId) return;

  const anonPrivateDir = join(
    config.USER_FILES_ROOT,
    String(anonUserId),
    'private',
  );
  await ensureDir(anonPrivateDir);

  const seedFiles = {
    'welcome.txt': 'Welcome to your new Webs file system!',
    'docs/webs-framework.md':
      '# Webs Framework\n\nThe Webs framework is a modern, file-based, full-stack JavaScript framework.',
    'docs/ai-features.md':
      '# AI Features\n\nThe framework includes a powerful AI module for semantic search and Retrieval-Augmented Generation (RAG).',
  };

  for (const [filePath, content] of Object.entries(seedFiles)) {
    const fullPath = join(anonPrivateDir, filePath);
    await ensureDir(dirname(fullPath));

    if (!(await exists(fullPath))) {
      logger.info(`Seeding file: '${filePath}'...`);
      await writeFile(fullPath, content);
      if (
        !db
          .query('SELECT path FROM files WHERE path = ? AND user_id = ?')
          .get(filePath, anonUserId)
      ) {
        const now = new Date().toISOString();
        const fileRecord = {
          path: filePath,
          user_id: anonUserId,
          access: 'private',
          size: content.length,
          last_modified: now,
          updated_at: now,
          content: Buffer.from(content),
        };
        const insertStmt = db.prepare(
          'INSERT INTO files (path, user_id, access, size, last_modified, updated_at, content) VALUES ($path, $user_id, $access, $size, $last_modified, $updated_at, $content)',
        );

        const params = Object.fromEntries(
          Object.entries(fileRecord).map(([key, value]) => [`$${key}`, value]),
        );
        insertStmt.run(params);

        await ai.indexFile(
          { path: filePath, content: content },
          { userId: anonUserId },
        );
      }
    }
  }

  const todoCount =
    db
      .query('SELECT COUNT(*) as count FROM todos WHERE user_id = ?')
      .get(anonUserId)?.count || 0;
  if (todoCount === 0) {
    logger.info('Seeding initial todos for anon user.');
    /** @type {Todo[]} */
    const seedTodos = [
      {
        id: generateUUID(),
        content: 'Explore the Webs framework',
        completed: 1,
        user_id: anonUserId,
      },
      {
        id: generateUUID(),
        content: 'Build something awesome',
        completed: 0,
        user_id: anonUserId,
      },
      {
        id: generateUUID(),
        content: 'Check out the local-first sync',
        completed: 0,
        user_id: anonUserId,
      },
    ];
    const insert = db.prepare(
      'INSERT INTO todos (id, content, completed, user_id, created_at, updated_at) VALUES ($id, $content, $completed, $user_id, $created_at, $updated_at)',
    );
    const insertTx = db.transaction((/** @type {Todo[]} */ todos) => {
      for (const todo of todos) {
        const now = new Date().toISOString();
        const params = Object.fromEntries(
          Object.entries({ ...todo, created_at: now, updated_at: now }).map(
            ([key, value]) => [`$${key}`, value],
          ),
        );
        insert.run(params);
      }
    });
    insertTx(seedTodos);
  }

  const channelCount =
    db.query('SELECT COUNT(*) as count FROM chat_channels').get()?.count || 0;
  if (channelCount === 0) {
    logger.info('Seeding initial chat channels and messages.');
    const generalChannelId = generateUUID();
    db.prepare(
      'INSERT INTO chat_channels (id, name, topic, owner_id) VALUES (?, ?, ?, ?)',
    ).run(generalChannelId, 'general', 'General discussion', anonUserId);
    db.prepare(
      'INSERT INTO channel_members (channel_id, user_id) VALUES (?, ?)',
    ).run(generalChannelId, anonUserId);
    db.prepare(
      'INSERT INTO chat_messages (id, channel_id, username, message, user_id) VALUES (?, ?, ?, ?, ?)',
    ).run(
      generateUUID(),
      generalChannelId,
      'anon',
      'Welcome to the general channel!',
      anonUserId,
    );
  }
}

---------- END: server/server-setup.js ----------

---------- START: server/router.js ----------
import { getUserFromSession, createSession } from './authentication.js';
import { createFileSystemForUser } from './fs.server.js';
import { renderToString } from '../renderer/ssr.js';
import { handleApiRequest } from './api.js';
import { stat, exists } from 'fs/promises';
import { basename, join } from 'path';
import { h } from '../core/vdom.js';
import { createLogger } from '../developer/logger.js';

/**
 * @typedef {import('bun:sqlite').Database} BunDatabase
 * @typedef {import('../ai/ai.server.js').AI} AI
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('../ai/ai.server.js').AgentDefinition} AgentDefinition
 */

/**
 * @typedef {object} ServerManifest
 * @property {string | undefined} js
 * @property {string | undefined} css
 * @property {string | undefined} sw
 */

/**
 * @typedef {object} RouteDefinition
 * @property {any} component
 * @property {string} componentName
 * @property {Record<string, Function>} actions
 * @property {Record<string, Function>} handlers
 * @property {Record<string, Function>} wsHandlers
 */

/**
 * @typedef {object} ServerContext
 * @property {BunDatabase} db
 * @property {AI} ai
 * @property {any} dbConfig
 * @property {ServerManifest} manifest
 * @property {Record<string, RouteDefinition>} appRoutes
 * @property {Record<string, AgentDefinition>} agentRoutes
 * @property {Config} config
 * @property {boolean} isProd
 * @property {string} SYNC_TOPIC
 * @property {string} HMR_TOPIC
 * @property {string} actionsPath
 * @property {any} globalComponents
 * @property {Record<string, string>} sourceToComponentMap
 * @property {Record<string, Function>} syncActions
 */

const logger = createLogger('[Router]');
/** @type {Map<string, { gzippedBuffer: Buffer, contentType: string }>} */
const gzipCache = new Map();

/**
 * @param {Request} req
 * @param {string} filePath
 * @returns {Promise<Response>}
 */
async function serveStaticFile(req, filePath) {
  const acceptsGzip = req.headers.get('Accept-Encoding')?.includes('gzip');
  const file = Bun.file(filePath);

  if (acceptsGzip) {
    if (gzipCache.has(filePath)) {
      const cached = gzipCache.get(filePath);
      if (cached) {
        const { gzippedBuffer, contentType } = cached;
        logger.debug(`Serving gzipped file from cache: ${filePath}`);
        return new Response(
          /** @type {BodyInit} */ (/** @type {unknown} */ (gzippedBuffer)),
          {
            headers: {
              'Content-Encoding': 'gzip',
              'Content-Type': contentType,
            },
          },
        );
      }
    }

    logger.debug(`Gzipping and serving file: ${filePath}`);
    const buffer = await file.arrayBuffer();
    const gzippedBuffer = Bun.gzipSync(new Uint8Array(buffer));
    const contentType = file.type;

    gzipCache.set(filePath, {
      gzippedBuffer: /** @type {Buffer} */ (
        /** @type {unknown} */ (gzippedBuffer)
      ),
      contentType,
    });

    return new Response(
      /** @type {BodyInit} */ (/** @type {unknown} */ (gzippedBuffer)),
      {
        headers: {
          'Content-Encoding': 'gzip',
          'Content-Type': contentType,
        },
      },
    );
  }

  logger.debug(`Serving uncompressed file: ${filePath}`);
  return new Response(file);
}

/**
 * @param {object} options
 * @param {string} options.appHtml
 * @param {object} options.websState
 * @param {{ css?: string, js?: string, sw?: string }} options.manifest
 * @param {string} options.title
 * @returns {string}
 */
function renderHtmlShell({ appHtml, websState, manifest, title }) {
  const cssPath = manifest.css ? `/${basename(manifest.css)}` : '';
  const jsPath = manifest.js ? `/${basename(manifest.js)}` : '';

  logger.debug('Rendering HTML shell for', title);
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${title}</title>
    ${cssPath ? `<link rel="stylesheet" href="${cssPath}">` : ''}
</head>
<body>
    <div id="root">${appHtml}</div>
    <script>window.__WEBS_STATE__ = ${JSON.stringify(websState)};</script>
    <script type="module" src="${jsPath}"></script>
</body>
</html>`;
}

/**
 * @param {any} routeDefinition
 * @param {any} context
 */
async function executePrefetch(routeDefinition, context) {
  logger.debug(
    `Executing prefetch for component '${routeDefinition.componentName}'...`,
  );
  if (!routeDefinition.actions?.prefetch) {
    logger.warn('No prefetch action found.');
    return {};
  }
  try {
    const result = await routeDefinition.actions.prefetch(context);
    logger.debug('Prefetch action completed successfully.');
    return result;
  } catch (err) {
    logger.error(`Prefetch Error for "${routeDefinition.componentName}":`, err);
    return { error: 'Failed to load data on the server.' };
  }
}
/**
 * @param {Request & { db: any, user: any, params: any }} req
 * @param {any} routeDefinition
 * @param {any} context
 */
async function handleDataRequest(req, routeDefinition, context) {
  logger.info(`Handling data request for route '${req.url}'`);
  const { db, user, params } = req;
  const { manifest, sourceToComponentMap } = context;
  const fs = user ? createFileSystemForUser(user.id) : null;

  const componentState = await executePrefetch(routeDefinition, {
    db,
    user,
    params,
    fs,
  });

  const websState = {
    user,
    params,
    componentState,
    componentName: routeDefinition.componentName,
    title: routeDefinition.component.name || 'Webs App',
    swPath: manifest.sw ? `/${basename(manifest.sw)}` : null,
    sourceToComponentMap,
  };
  logger.debug('Sending JSON response for data request.');
  return new Response(JSON.stringify(websState), {
    headers: { 'Content-Type': 'application/json;charset=utf-8' },
  });
}
/**
 * @param {Request & { db: any, user: any, params: any }} req
 * @param {any} routeDefinition
 * @param {any} context
 */
async function handlePageRequest(req, routeDefinition, context) {
  logger.info(`Handling page request for route '${req.url}'`);
  const { manifest, globalComponents, sourceToComponentMap } = context;
  const { db, user, params } = req;
  const fs = user ? createFileSystemForUser(user.id) : null;

  const initialState = await executePrefetch(routeDefinition, {
    db,
    user,
    params,
    fs,
  });

  const { pathname } = new URL(req.url);
  const props = { user, params, initialState, path: pathname };

  const vnode = h(routeDefinition.component, props);
  vnode.appContext = {
    components: globalComponents || {},
    provides: {},
    patch: () => {},
    hydrate: () => null,
    params: params || {},
  };

  logger.debug('Starting SSR...');
  const { html: appHtml, componentState } = await renderToString(vnode);
  logger.debug('SSR complete.');

  const websState = {
    user,
    params,
    componentState: componentState || initialState,
    componentName: routeDefinition.componentName,
    swPath: manifest.sw ? `/${basename(manifest.sw)}` : null,
    sourceToComponentMap,
  };

  const fullHtml = renderHtmlShell({
    appHtml,
    websState,
    manifest,
    title: routeDefinition.component.name || 'Webs App',
  });
  logger.debug('Sending full HTML page response.');
  return new Response(fullHtml, {
    headers: { 'Content-Type': 'text/html;charset=utf-8' },
  });
}
/**
 * @param {import("bun:sqlite").Database} db
 * @param {boolean} isProd
 * @returns {(req: Request & { db?: any, user?: any, params?: any }) => void}
 */
const authMiddleware = (db, isProd) => (req) => {
  req.db = db;
  const cookie = req.headers.get('cookie');
  const sessionId = cookie?.match(/session_id=([^;]+)/)?.[1];
  let user = sessionId ? getUserFromSession(db, sessionId) : null;

  if (!isProd && !user) {
    const anonUser = db
      .query('SELECT id, username, email FROM users WHERE username = ?')
      .get('anon');
    if (anonUser) {
      const newSessionId = createSession(
        db,
        /** @type {{id: number}} */ (anonUser).id,
      );
      user = anonUser;
      req.headers.set('X-Set-Dev-Session', newSessionId);
    }
  }
  req.user = user;
};
/**
 * @param {object} context
 * @param {import("bun:sqlite").Database} context.db
 * @param {any} context.manifest
 * @param {Record<string, any>} context.appRoutes
 * @param {any} context.agentRoutes
 * @param {any} context.globalComponents
 * @param {any} context.config
 * @param {boolean} context.isProd
 * @param {any} context.sourceToComponentMap
 * @param {import('../ai/ai.server.js').AI} context.ai
 * @param {Record<string, Function>} context.syncActions
 * @param {string} context.SYNC_TOPIC
 */
export function createFetchHandler(context) {
  const {
    db,
    manifest,
    appRoutes,
    globalComponents,
    config,
    isProd,
    sourceToComponentMap,
  } = context;
  const { OUTDIR, SRC_DIR } = config;

  const attachContext = authMiddleware(db, isProd);
  const sortedAppRoutePaths = Object.keys(appRoutes || {});

  /**
   * @param {Request} req
   * @param {import("bun").Server} server
   */
  return async function fetch(req, server) {
    const url = new URL(req.url);
    const { pathname } = url;
    logger.info(`Received request for: ${pathname}`);

    if (pathname.includes('..')) {
      logger.warn('Path traversal attempt detected.');
      return new Response('Forbidden', { status: 403 });
    }

    const potentialFilePath = join(OUTDIR, pathname.substring(1));
    if (
      (await exists(potentialFilePath)) &&
      (await stat(potentialFilePath)).isFile()
    ) {
      return serveStaticFile(req, potentialFilePath);
    }

    if (!isProd) {
      const potentialSrcPath = join(SRC_DIR, pathname.substring(1));
      if (
        (await exists(potentialSrcPath)) &&
        (await stat(potentialSrcPath)).isFile()
      ) {
        return serveStaticFile(req, potentialSrcPath);
      }
    }
    const extendedReq =
      /** @type {Request & { db: any, user: any, params: any }} */ (req);
    attachContext(extendedReq);

    if (pathname.startsWith('/api/')) {
      const apiResponse = await handleApiRequest(extendedReq, server, {
        db: context.db,
        ai: context.ai,
        syncActions: context.syncActions,
        SYNC_TOPIC: context.SYNC_TOPIC,
        agentRoutes: context.agentRoutes,
      });
      if (apiResponse) return apiResponse;
    }

    if (req.headers.get('upgrade') === 'websocket') {
      if (pathname === '/api/sync') {
        if (extendedReq.user) {
          return server.upgrade(req, {
            data: { isSyncChannel: true, user: extendedReq.user },
          })
            ? undefined
            : new Response('Unauthorized', { status: 401 });
        }
      }
      if (pathname === '/api/hmr') {
        return server.upgrade(req, { data: { isHmrChannel: true } })
          ? undefined
          : new Response('HMR WebSocket upgrade failed', { status: 500 });
      }
    }

    const actionMatch = pathname.match(/^\/__actions__\/(.+?)\/(.+?)$/);
    if (actionMatch) {
      if (!extendedReq.user)
        return new Response('Unauthorized', { status: 401 });
      const [, componentName, actionName] = actionMatch;
      if (!componentName || !actionName) {
        return new Response('Action not found', { status: 404 });
      }
      const routeDef = Object.values(appRoutes).find(
        (
          /** @type {{ componentName: string; component: { name: string; }; actions: object }} */ r,
        ) =>
          (r.componentName === componentName ||
            r.component.name === componentName) &&
          r.actions &&
          actionName in r.actions,
      );
      const action = routeDef?.actions?.[actionName];

      if (typeof action !== 'function')
        return new Response('Action not found', { status: 404 });

      try {
        const args = await req.json();
        const result = await action(
          {
            req,
            db,
            fs: createFileSystemForUser(extendedReq.user.id),
            user: extendedReq.user,
          },
          ...args,
        );
        return result instanceof Response ? result : Response.json(result);
      } catch (e) {
        logger.error('Error executing action:', e);
        return new Response('Internal Server Error', { status: 500 });
      }
    }

    for (const path of sortedAppRoutePaths) {
      const routeDefinition = appRoutes[path];
      /** @type {string[]} */
      const paramNames = [];
      const regex = new RegExp(
        `^${path.replace(/:(\w+)(\*)?/g, (_, name, isCatchAll) => {
          paramNames.push(name);
          return isCatchAll === '*' ? '(.*)' : '([^/]+)';
        })}$`,
      );
      const match = pathname.match(regex);

      if (match) {
        logger.info(`Matched request to route: '${path}'`);
        extendedReq.params = paramNames.reduce((acc, name, i) => {
          let value = match[i + 1] || '';
          if (
            path.endsWith('*') &&
            name === paramNames[paramNames.length - 1]
          ) {
            value = value.startsWith('/') ? value.substring(1) : value;
          }
          /** @type {any} */ (acc)[name] = value;
          return acc;
        }, {});

        if (req.headers.get('upgrade') === 'websocket') {
          if (
            routeDefinition.wsHandlers &&
            Object.keys(routeDefinition.wsHandlers).length > 0
          ) {
            logger.info(`Upgrading to WebSocket for route: ${path}`);
            const success = server.upgrade(req, {
              data: {
                user: extendedReq.user,
                params: extendedReq.params,
                wsHandlers: routeDefinition.wsHandlers,
              },
            });
            return success
              ? undefined
              : new Response('WebSocket upgrade failed', { status: 500 });
          }
        }

        const requestMethod = req.method.toLowerCase();
        if (requestMethod !== 'get') {
          if (!extendedReq.user) {
            return new Response('Unauthorized', { status: 401 });
          }

          const handler = routeDefinition.handlers?.[requestMethod];

          if (handler && typeof handler === 'function') {
            try {
              const result = await handler({
                req: extendedReq,
                db,
                user: extendedReq.user,
                params: extendedReq.params,
                fs: createFileSystemForUser(extendedReq.user.id),
              });

              if (result instanceof Response) {
                return result;
              }
              if (result !== undefined) {
                return Response.json(result);
              }
              return new Response(null, { status: 204 });
            } catch (e) {
              const error = /** @type {Error} */ (e);
              logger.error(
                `Error executing '${requestMethod}' handler for route '${path}':`,
                error,
              );
              return new Response(error.message || 'Internal Server Error', {
                status: 500,
              });
            }
          } else {
            return new Response('Method Not Allowed', { status: 405 });
          }
        }

        const response = req.headers.get('X-Webs-Navigate')
          ? await handleDataRequest(extendedReq, routeDefinition, {
              manifest,
              sourceToComponentMap,
            })
          : await handlePageRequest(extendedReq, routeDefinition, {
              manifest,
              globalComponents,
              sourceToComponentMap,
            });

        const devSessionId = req.headers.get('X-Set-Dev-Session');
        if (devSessionId) {
          response.headers.append(
            'Set-Cookie',
            `session_id=${devSessionId}; HttpOnly; Path=/; SameSite=Strict; Max-Age=604800`,
          );
        }
        return response;
      }
    }

    logger.info('No route matched, returning 404.');
    return new Response('Not Found', { status: 404 });
  };
}

---------- END: server/router.js ----------

---------- START: server/fs.server.js ----------
/**
 * @file Server-side file system API for user-scoped file operations.
 */

import { join, resolve, dirname } from 'path';
import {
  cp as copy,
  mkdir as fsMkdir,
  rename,
  rm as fsRm,
  stat as fsStat,
  readdir,
} from 'node:fs/promises';
import { createLogger } from '../developer/logger.js';
import { write, file as bunFile } from 'bun';

/** @typedef {import('bun:sqlite').Database} BunDatabase */
/** @typedef {import('bun').BunFile} BunFile */

/**
 * @typedef {'public' | 'private'} FileAccessLevel
 */

/**
 * @typedef {object} FsOptions
 * @property {FileAccessLevel} [access='public'] - The access level for the file operation.
 */

/**
 * @typedef {object} FileStats
 * @property {boolean} isFile - True if the path points to a file.
 * @property {boolean} isDirectory - True if the path points to a directory.
 * @property {number} size - The size of the file in bytes.
 * @property {Date} mtime - The last modification time.
 * @property {Date} birthtime - The creation time.
 */

/**
 * @typedef {object} ServerFsApi
 * @property {() => string} getPrivateRootPath - Gets the absolute path to the user's private directory.
 * @property {(path: string, options?: FsOptions) => Promise<boolean>} exists - Checks if a file or directory exists.
 * @property {(path: string, options?: FsOptions) => Promise<FileStats>} stat - Retrieves stats for a file or directory.
 * @property {(path: string, options?: FsOptions) => Promise<import('bun').BunFile>} cat - Reads a file and returns a `BunFile` object for streaming or consumption.
 * @property {(path?: string, options?: FsOptions) => Promise<Array<{name: string, isDirectory: boolean, path: string}>>} ls - Lists the contents of a directory.
 * @property {(path: string, options?: FsOptions) => Promise<string | undefined>} mkdir - Creates a new directory.
 * @property {(path: string, data: import('bun').file | Blob | string | Buffer | ArrayBuffer | ReadableStream, options?: FsOptions) => Promise<number | void>} write - Writes data to a file.
 * @property {(from: string, to: string, options?: FsOptions) => Promise<void>} mv - Moves or renames a file or directory.
 * @property {(path: string, options?: FsOptions) => Promise<void>} rm - Removes a file or directory.
 * @property {(from: string, to: string, options?: FsOptions) => Promise<void>} cp - Copies a file or directory.
 */

const logger = createLogger('[FS]');

/**
 * The root directory for all user files on the server.
 * @internal
 * @type {string}
 */
const USER_FILES_ROOT = resolve(process.cwd(), '.webs/files');

/**
 * Creates a sandboxed file system API for a specific user.
 * All paths are resolved relative to the user's dedicated directory to prevent path traversal attacks.
 * @param {string | number} userId - The unique identifier for the user.
 * @returns {ServerFsApi} An object with secure methods for file system manipulation.
 */
export function createFileSystemForUser(userId) {
  if (!userId) throw new Error('A valid userId is required.');
  const userRootPath = join(USER_FILES_ROOT, String(userId));
  const publicPath = join(userRootPath, 'public');
  const privatePath = join(userRootPath, 'private');

  /**
   * @internal
   * Resolves a user-provided path to an absolute path within the user's sandboxed directory.
   * @param {string} [userPath='.'] - The path provided by the user.
   * @param {FileAccessLevel} [access='public'] - The access level.
   * @returns {string} The secure, absolute path.
   * @throws {Error} If the path attempts to traverse outside the user's directory.
   */
  const secureResolvePath = (userPath = '.', access = 'public') => {
    const basePath = access === 'private' ? privatePath : publicPath;
    const absolutePath = resolve(basePath, userPath);
    if (!absolutePath.startsWith(basePath)) {
      throw new Error('Permission denied: Path traversal attempt detected.');
    }
    return absolutePath;
  };

  /**
   * @internal
   * Ensures the parent directory of a given file path exists.
   * @param {string} filePath - The full path to the file.
   * @returns {Promise<void>}
   */
  const ensureDirectoryExists = async (filePath) => {
    const dir = dirname(filePath);
    try {
      await fsStat(dir);
    } catch (e) {
      const nodeError = /** @type {NodeJS.ErrnoException} */ (e);
      if (nodeError.code === 'ENOENT') {
        await fsMkdir(dir, { recursive: true });
      } else {
        throw e;
      }
    }
  };

  return {
    getPrivateRootPath: () => privatePath,

    exists: async (path, { access = 'public' } = {}) => {
      try {
        await fsStat(secureResolvePath(path, access));
        return true;
      } catch (error) {
        const nodeError = /** @type {NodeJS.ErrnoException} */ (error);
        if (nodeError.code === 'ENOENT') {
          return false;
        }
        throw error;
      }
    },
    stat: async (path, { access = 'public' } = {}) => {
      const stats = await fsStat(secureResolvePath(path, access));
      return {
        isFile: stats.isFile(),
        isDirectory: stats.isDirectory(),
        size: stats.size,
        mtime: stats.mtime,
        birthtime: stats.birthtime,
      };
    },
    cat: async (path, { access = 'public' } = {}) => {
      const resolvedPath = secureResolvePath(path, access);
      const file = bunFile(resolvedPath);
      if (!(await file.exists())) throw new Error(`File not found at: ${path}`);
      return file;
    },
    ls: async (path = '.', { access = 'public' } = {}) => {
      const resolvedPath = secureResolvePath(path, access);
      try {
        await fsStat(resolvedPath);
        const entries = await readdir(resolvedPath, { withFileTypes: true });
        return entries
          .map((entry) => ({
            name: entry.name,
            isDirectory: entry.isDirectory(),
            path: join(path, entry.name).replace(/\\/g, '/'),
          }))
          .sort((a, b) => a.name.localeCompare(b.name));
      } catch (error) {
        const nodeError = /** @type {NodeJS.ErrnoException} */ (error);
        if (nodeError.code === 'ENOENT') {
          return [];
        }
        logger.error(`[FS] Error in ls for path "${resolvedPath}":`, error);
        throw error;
      }
    },
    mkdir: async (path, { access = 'public' } = {}) => {
      const p = secureResolvePath(path, access);
      return fsMkdir(p, { recursive: true });
    },

    write: async (path, data, { access = 'public' } = {}) => {
      const resolvedPath = secureResolvePath(path, access);
      await ensureDirectoryExists(resolvedPath);

      if (data instanceof ReadableStream) {
        const writer = bunFile(resolvedPath).writer();
        const reader = data.getReader();
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            writer.end();
            break;
          }
          writer.write(value);
        }
        await writer.flush();
      } else {
        return write(
          resolvedPath,
          /** @type {Blob | Buffer | string | ArrayBuffer} */ (data),
        );
      }
    },

    mv: async (from, to, { access = 'public' } = {}) => {
      const fromPath = secureResolvePath(from, access);
      const toPath = secureResolvePath(to, access);
      await ensureDirectoryExists(toPath);
      return rename(fromPath, toPath);
    },
    rm: async (path, { access = 'public' } = {}) => {
      const p = secureResolvePath(path, access);
      return fsRm(p, { recursive: true, force: true });
    },
    cp: async (from, to, { access = 'public' } = {}) => {
      const fromPath = secureResolvePath(from, access);
      const toPath = secureResolvePath(to, access);
      await ensureDirectoryExists(toPath);
      const stats = await fsStat(fromPath);
      return copy(fromPath, toPath, { recursive: stats.isDirectory() });
    },
  };
}

---------- END: server/fs.server.js ----------

---------- START: server/api.js ----------
import { registerUser, loginUser, logoutUser } from './authentication.js';
import { createFileSystemForUser } from './fs.server.js';
import { createLogger } from '../developer/logger.js';

const logger = createLogger('[API]');

/**
 * @typedef {import('bun:sqlite').Database} BunDatabase
 * @typedef {import('../ai/ai.server.js').AgentDefinition} AgentDefinition
 * @typedef {import('../ai/ai.server.js').ConversationContext} ConversationContext
 */

/**
 * @typedef {'public' | 'private'} FileAccessLevel
 */

/**
 * @typedef {object} ApiContext
 * @property {BunDatabase} db
 * @property {import('../ai/ai.server.js').AI} ai
 * @property {Record<string, Function>} syncActions
 * @property {string} SYNC_TOPIC
 * @property {Record<string, AgentDefinition>} [agentRoutes]
 * @property {ConversationContext} [conversationContext]
 */

/**
 * @param {Request & { user?: any }} req
 * @param {import('bun').Server} server
 * @param {ApiContext} context
 */
export async function handleApiRequest(req, server, context) {
  const { db, ai, syncActions, agentRoutes } = context;
  const url = new URL(req.url);
  const { pathname } = url;

  if (pathname.startsWith('/api/ai/')) {
    if (!req.user) return new Response('Unauthorized', { status: 401 });
    try {
      if (pathname.endsWith('/generate') && req.method === 'POST') {
        const { prompt, options } = await req.json();
        const stream = await ai.generate(prompt, options);
        return new Response(stream, {
          headers: { 'Content-Type': 'text/plain; charset=utf-8' },
        });
      }

      const agentRunMatch = pathname.match(/^\/api\/ai\/agent\/run\/(.+)$/);
      if (agentRunMatch && req.method === 'POST') {
        const agentName = agentRunMatch[1];
        if (!agentName) {
          return new Response(`Agent name is missing.`, {
            status: 400,
          });
        }
        const agentDef = agentRoutes && agentRoutes[agentName];

        if (!agentDef) {
          return new Response(`Agent '${agentName}' not found.`, {
            status: 404,
          });
        }

        const { messages, options } = await req.json();

        const toolContext = {
          db,
          user: req.user,
          fs: createFileSystemForUser(req.user.id),
        };

        const stream = await ai.agent(messages, agentDef, toolContext, options);
        return new Response(stream, {
          headers: { 'Content-Type': 'application/x-ndjson; charset=utf-8' },
        });
      }

      if (pathname.endsWith('/search/files') && req.method === 'POST') {
        const { query, limit } = await req.json();
        const results = await ai.search(query, limit, {
          userId: req.user.id,
        });
        return Response.json(results);
      }
      if (pathname.endsWith('/chat') && req.method === 'POST') {
        const { messages, options } = await req.json();
        const stream = await ai.chat(messages, options);
        return new Response(stream, {
          headers: { 'Content-Type': 'text/plain; charset=utf-8' },
        });
      }
      if (pathname.startsWith('/api/ai/models/')) {
        if (pathname.endsWith('/list'))
          return Response.json((await ai.list())?.models || []);
        if (pathname.endsWith('/pull') && req.method === 'POST') {
          const { model } = await req.json();
          const pullStream = await ai.pull(model);
          const body = new ReadableStream({
            async start(controller) {
              for await (const chunk of pullStream) {
                controller.enqueue(
                  new TextEncoder().encode(JSON.stringify(chunk) + '\n'),
                );
              }
              controller.close();
            },
          });
          return new Response(body, {
            headers: { 'Content-Type': 'application/x-ndjson; charset=utf-8' },
          });
        }
        if (pathname.endsWith('/delete') && req.method === 'POST') {
          const { model } = await req.json();
          await ai.delete(model);
          return Response.json({ success: true, model });
        }
      }
    } catch (err) {
      logger.error('AI API Error:', err);
      const error = /** @type {Error} */ (err);
      return new Response(error.message, { status: 500 });
    }
  }

  if (pathname.startsWith('/api/fs/') && req.method === 'PUT') {
    if (!req.user) return new Response('Unauthorized', { status: 401 });
    const filePath = decodeURIComponent(pathname.substring('/api/fs/'.length));
    if (!filePath)
      return new Response('File path is required', { status: 400 });

    try {
      const fs = createFileSystemForUser(req.user.id);
      /** @type {FileAccessLevel} */
      const access =
        url.searchParams.get('access') === 'private' ? 'private' : 'public';

      if (!req.body) {
        return new Response('Request body is missing', { status: 400 });
      }
      await fs.write(filePath, req.body, { access });

      const fileBlob = await fs.cat(filePath, { access });
      const fileContent = await fileBlob.text();
      const stats = await fs.stat(filePath, { access });

      await ai.indexFile(
        { path: filePath, content: fileContent },
        { userId: req.user.id },
      );

      const record = {
        path: filePath,
        user_id: req.user.id,
        content: fileContent,
        access: access,
        size: stats.size,
        last_modified: new Date().toISOString(),
      };

      if (syncActions.upsertFiles) {
        const result = syncActions.upsertFiles({ user: req.user }, record);
        if (result?.broadcast) {
          server.publish(
            context.SYNC_TOPIC,
            JSON.stringify({ type: 'sync', data: result.broadcast }),
          );
        }
      }

      return new Response(JSON.stringify({ success: true, path: filePath }), {
        status: 201,
      });
    } catch (err) {
      logger.error('Upload Error:', err);
      const error = /** @type {Error} */ (err);
      return new Response(`Upload failed: ${error.message}`, { status: 500 });
    }
  }

  if (pathname.startsWith('/api/auth/')) {
    if (pathname.endsWith('/register')) return registerUser(req, db);
    if (pathname.endsWith('/login')) return loginUser(req, db);
    if (pathname.endsWith('/logout')) return logoutUser(req, db);
  }

  return null;
}

---------- END: server/api.js ----------

---------- START: server/authentication.js ----------
import { generateUUID } from '../utils/common.js';
import { createLogger } from '../developer/logger.js';

const logger = createLogger('[Auth]');
const SESSION_DURATION_MS = 1000 * 60 * 60 * 24 * 7;

/**
 * @typedef {import("bun:sqlite").Database} BunDatabase
 */

/**
 * @typedef {object} UserCredentials
 * @property {string} email
 * @property {string} username
 * @property {string} password
 */

/**
 * @typedef {object} UserInfo
 * @property {number} id
 * @property {string} username
 * @property {string} email
 */

/**
 * @param {string} password
 * @returns {Promise<string>}
 */
export async function hashPassword(password) {
  return Bun.password.hash(password, { algorithm: 'bcrypt', cost: 10 });
}

/**
 * @param {string} password
 * @param {string} hash
 * @returns {Promise<boolean>}
 */
async function verifyPassword(password, hash) {
  return Bun.password.verify(password, hash);
}

/**
 * @param {BunDatabase} db
 * @param {number} userId
 * @returns {string}
 */
export function createSession(db, userId) {
  const sessionId = generateUUID();
  const expiresAt = new Date(Date.now() + SESSION_DURATION_MS);
  db.query(
    'INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)',
  ).run(sessionId, userId, expiresAt.toISOString());
  return sessionId;
}

/**
 * @param {BunDatabase} db
 * @param {string} sessionId
 */
function deleteSession(db, sessionId) {
  db.query('DELETE FROM sessions WHERE id = ?').run(sessionId);
}

/**
 * @param {BunDatabase} db
 * @param {string | undefined} sessionId
 * @returns {any}
 */
export function getUserFromSession(db, sessionId) {
  if (!sessionId) return null;
  const session = db
    .query('SELECT user_id, expires_at FROM sessions WHERE id = ?')
    .get(sessionId);

  if (!session || new Date(session.expires_at) < new Date()) {
    if (session) deleteSession(db, sessionId);
    return null;
  }
  return db
    .query('SELECT id, username, email FROM users WHERE id = ?')
    .get(session.user_id);
}

/**
 * @param {BunDatabase} db
 * @param {UserCredentials} credentials
 */
async function createUser(db, { email, username, password }) {
  const hashedPassword = await hashPassword(password);
  return db
    .query(
      'INSERT INTO users (email, username, password) VALUES ($email, $username, $password) RETURNING id, email, username',
    )
    .get({ $email: email, $username: username, $password: hashedPassword });
}

/**
 * @param {Request} req
 * @param {BunDatabase} db
 * @returns {Promise<Response>}
 */
export async function registerUser(req, db) {
  try {
    const { email, username, password } = await req.json();
    if (!email || !username || !password || password.length < 8) {
      return new Response(
        'Email, username, and a password of at least 8 characters are required.',
        { status: 400 },
      );
    }
    const existingUser = db
      .query('SELECT id FROM users WHERE email = ? OR username = ?')
      .get(email, username);
    if (existingUser) {
      return new Response(
        'A user with this email or username already exists.',
        { status: 409 },
      );
    }
    const user = await createUser(db, { email, username, password });
    return Response.json(
      { id: user.id, username: user.username, email: user.email },
      { status: 201 },
    );
  } catch (error) {
    logger.error('Registration error:', error);
    return new Response('An internal error occurred.', { status: 500 });
  }
}

/**
 * @param {Request} req
 * @param {BunDatabase} db
 * @returns {Promise<Response>}
 */
export async function loginUser(req, db) {
  try {
    const { email, password } = await req.json();
    if (!email || !password)
      return new Response('Email and password are required.', { status: 400 });

    const user = db
      .query('SELECT id, username, email, password FROM users WHERE email = ?')
      .get(email);
    if (!user) return new Response('Invalid credentials.', { status: 401 });

    const passwordIsValid = await verifyPassword(password, user.password);
    if (!passwordIsValid) {
      return new Response('Invalid credentials.', { status: 401 });
    }

    const sessionId = createSession(db, user.id);
    const headers = new Headers();
    headers.append(
      'Set-Cookie',
      `session_id=${sessionId}; HttpOnly; Path=/; SameSite=Strict; Max-Age=${
        SESSION_DURATION_MS / 1000
      }`,
    );
    return new Response(
      JSON.stringify({
        id: user.id,
        email: user.email,
        username: user.username,
      }),
      { headers },
    );
  } catch (error) {
    logger.error('Login error:', error);
    const typedError = /** @type {Error & { code?: string }} */ (error);
    if (
      typedError.name === 'PasswordVerificationFailed' &&
      typedError.code === 'PASSWORD_UNSUPPORTED_ALGORITHM'
    ) {
      logger.error(
        'Password verification failed: The stored password hash is in an unsupported format.',
      );
      return new Response(
        'Password verification failed: The stored password hash is in an unsupported format.',
        { status: 500 },
      );
    }
    return new Response('An internal error occurred.', { status: 500 });
  }
}
/**
 * @param {Request} req
 * @param {BunDatabase} db
 * @returns {Promise<Response>}
 */
export async function logoutUser(req, db) {
  const sessionId = req.headers.get('cookie')?.match(/session_id=([^;]+)/)?.[1];
  if (sessionId) deleteSession(db, sessionId);
  const headers = new Headers();
  headers.append(
    'Set-Cookie',
    'session_id=; HttpOnly; Path=/; SameSite=Strict; Max-Age=0',
  );
  return new Response(null, { status: 204, headers });
}

---------- END: server/authentication.js ----------

---------- START: core/core.js ----------
/**
 * @file Core application logic, including app creation, routing, and client-side hydration.
 */

import { createRenderer } from '../renderer/renderer.js';
import { createVnode } from './vdom.js';
import { ref } from './reactivity.js';
import { createLogger } from '../developer/logger.js';
import { normalizeClass } from '../utils/dom.js';
import { initDevTools } from '../developer/developer.js';
import { session } from '../client/runtime.js';
import { coreDB } from '../client/db.client.js';
import { syncEngine } from '../client/sync-engine.js';

/**
 * @typedef {import('./vdom.js').VNode} VNode
 * @typedef {import('../renderer/renderer.js').Component<any>} Component
 * @typedef {import('./component.js').ComponentInstance<any>} ComponentInstance
 * @typedef {import('../renderer/renderer.js').Renderer<any>} Renderer
 */
/**
 * @template T
 * @typedef {import('./reactivity.js').Ref<T>} Ref
 */

/**
 * @typedef {Element & { _vei?: Record<string, any> }} ElementWithVEI
 */

/**
 * @typedef {object} WebsState
 * @property {string} componentName
 * @property {string} [swPath]
 * @property {object} [user]
 * @property {object} [params]
 * @property {object} [componentState]
 * @property {object} [sourceToComponentMap]
 */

/**
 * @internal
 * @typedef {object} AppContext
 * @property {Record<string, Component>} components - Registered components.
 * @property {Record<string | symbol, any>} provides - Dependency injection container.
 * @property {Renderer['patch']} patch - The renderer's patch function.
 * @property {Renderer['hydrate']} hydrate - The renderer's hydrate function.
 * @property {object} params - Route parameters.
 * @property {object} [globals] - Global properties accessible in templates.
 */

/**
 * @internal
 * @typedef {object} App
 * @property {Component} _component - The root component definition.
 * @property {Element | null} _container - The root DOM container.
 * @property {VNode | null} _vnode - The root virtual node.
 * @property {AppContext} _context - The application context.
 * @property {(rootContainer: Element) => ComponentInstance | undefined | null} mount - Mounts the application.
 */

const logger = createLogger('[Core]');

/**
 * @internal
 * @type {App | null}
 * The singleton application instance.
 */
let appInstance = null;

/**
 * @internal
 * @type {Map<string, () => Promise<{default: Component}>> | null}
 * The manifest for dynamically loading components.
 */
let componentManifestInstance = null;

/**
 * @internal
 * @type {Map<string, any>}
 * Cache for pre-fetched page data during navigation.
 */
const prefetchCache = new Map();

/**
 * @internal
 * @type {object | null}
 * A map from source file paths to component names, used in development.
 */
let sourceToComponentMap = null;

/**
 * @description A reactive object representing the current route.
 * @type {Ref<{path: string}>}
 */
export const route = ref({ path: '/' });

/**
 * @internal
 * @description Handles the logic for client-side navigation, fetching data and patching the DOM.
 * @param {URL} url - The URL to navigate to.
 * @param {{isPopState?: boolean, fromClick?: boolean}} [options={}] - Navigation options.
 * @returns {Promise<void>}
 */
async function performNavigation(
  url,
  { isPopState = false, fromClick = false } = {},
) {
  logger.info(`Starting navigation to: ${url.href}`);
  try {
    let data;
    if (!isPopState && fromClick && prefetchCache.has(url.href)) {
      data = prefetchCache.get(url.href);
      prefetchCache.delete(url.href);
      logger.debug('Used prefetched data for navigation.');
    } else {
      logger.debug('Fetching navigation data from server... ');
      const response = await fetch(url.pathname + url.search, {
        headers: { 'X-Webs-Navigate': 'true' },
      });
      if (
        !response.ok ||
        !response.headers.get('content-type')?.includes('application/json')
      ) {
        logger.warn(
          'Navigation fetch failed or returned non-JSON. Full page reload.',
        );
        window.location.assign(url.href);
        return;
      }
      data = deserializeState(await response.json());
      logger.debug('Successfully fetched navigation data:', data);
    }

    if (!componentManifestInstance) {
      throw new Error('Component manifest not available.');
    }

    const { componentName } = data;
    const componentLoader = componentManifestInstance.get(componentName);

    if (!componentLoader) {
      logger.error(
        `Component loader for "${componentName}" not found. Full page reload.`,
      );
      window.location.assign(url.href);
      return;
    }

    const newComponentModule = await componentLoader();
    const newComponentDef = newComponentModule.default;

    if (!appInstance || !appInstance._vnode || !appInstance._container) {
      throw new Error('App instance is not properly initialized.');
    }

    const oldVnode = appInstance._vnode;
    const newProps = {
      params: data.params,
      initialState: data.componentState || {},
      user: data.user || null,
      path: url.pathname,
    };
    logger.debug('New props for component update:', newProps);

    appInstance._context.params = data.params;

    const newVnode = createVnode(newComponentDef, newProps);
    newVnode.appContext = appInstance._context;

    route.value.path = url.pathname;
    if (
      session &&
      typeof (/** @type {any} */ (session).setUser) === 'function'
    ) {
      /** @type {any} */ (session).setUser(data.user);
    }

    logger.info('Patching DOM with new component vnode...');
    appInstance._context.patch(
      oldVnode,
      newVnode,
      appInstance._container,
      null,
      null,
    );
    appInstance._vnode = newVnode;
    logger.info('DOM patching complete.');

    if (!isPopState) {
      window.history.pushState({}, '', url.href);
    }
    document.title = data.title;

    /** @type {any} */ (window).__WEBS_STATE__ = {
      componentName: data.componentName,
      swPath: data.swPath,
      user: data.user,
      params: data.params,
      componentState: data.componentState,
    };
    logger.debug(
      'Updated window.__WEBS_STATE__',
      /** @type {any} */ (window).__WEBS_STATE__,
    );
  } catch (err) {
    logger.error(
      'Error during client-side navigation, falling back to full page reload.',
      err,
    );
    window.location.assign(url.href);
  }
}

/**
 * @description Client-side router for programmatic navigation.
 */
export const router = {
  /**
   * @description Navigates to a new URL.
   * @param {string} href - The destination URL.
   * @param {boolean} [fromClick=false] - Indicates if the navigation was triggered by a user click.
   */
  push(href, fromClick = false) {
    logger.debug(
      `Router push called with href: ${href}, fromClick: ${fromClick}`,
    );
    const url = new URL(href, window.location.origin);
    if (url.origin !== window.location.origin) {
      logger.debug(
        `External URL detected, performing full page load to: ${href}`,
      );
      window.location.assign(href);
      return;
    }
    if (url.href !== window.location.href) {
      logger.debug(`Internal navigation to: ${url.href}`);
      performNavigation(url, { fromClick });
    } else {
      logger.debug('URL is the same, no navigation needed.');
    }
  },
};

/**
 * @description Creates an application instance. This is the main entry point for the framework.
 */
export const createApp = (() => {
  const renderer = createRenderer({
    createElement: (tag) => document.createElement(tag),
    createText: (text) => document.createTextNode(text),
    createComment: (text) => document.createComment(text),
    setElementText: (el, text) => {
      el.textContent = text;
    },
    insert: (child, parent, anchor = null) => {
      parent.insertBefore(child, anchor);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) parent.removeChild(child);
    },
    patchProp: (/** @type {ElementWithVEI} */ el, key, prevVal, nextVal) => {
      if (key === 'ref') {
        if (prevVal && typeof prevVal === 'object' && 'value' in prevVal) {
          prevVal.value = null;
        }
        if (nextVal && typeof nextVal === 'object' && 'value' in nextVal) {
          nextVal.value = el;
        }
        return;
      }

      if (/^on[A-Z]/.test(key)) {
        const eventName = key.slice(2).toLowerCase();
        let invokers = el._vei || (el._vei = {});
        let invoker = invokers[eventName];
        if (nextVal) {
          if (!invoker) {
            invoker = el._vei[eventName] = (
              /** @type {{ timeStamp: number; }} */ e,
            ) => {
              if (e.timeStamp < invoker.attached) return;
              if (Array.isArray(invoker.value)) {
                invoker.value.forEach((/** @type {(arg0: any) => void} */ fn) =>
                  fn(e),
                );
              } else {
                invoker.value(e);
              }
            };
            invoker.value = nextVal;
            invoker.attached = performance.now();
            el.addEventListener(eventName, invoker);
          } else {
            invoker.value = nextVal;
          }
        } else if (invoker) {
          el.removeEventListener(eventName, invoker);
          invokers[eventName] = undefined;
        }
      } else if (key === 'class') {
        const newClassName = normalizeClass(nextVal) || '';
        if (el.className !== newClassName) {
          el.className = newClassName;
        }
      } else if (key === 'style') {
        if (typeof nextVal === 'string') {
          /** @type {HTMLElement} */ (el).style.cssText = nextVal;
        } else if (nextVal && typeof nextVal === 'object') {
          for (const styleKey in nextVal) {
            /** @type {any} */ (/** @type {HTMLElement} */ (el).style)[
              styleKey
            ] = nextVal[styleKey];
          }
          if (prevVal && typeof prevVal === 'object') {
            for (const oldKey in prevVal) {
              if (!(oldKey in nextVal)) {
                /** @type {any} */ (/** @type {HTMLElement} */ (el).style)[
                  oldKey
                ] = '';
              }
            }
          }
        }
      } else if (
        key in el &&
        typeof (/** @type {any} */ (el)[key]) === 'boolean'
      ) {
        /** @type {any} */ (el)[key] = !!nextVal;
      } else if (key in el) {
        if (/** @type {any} */ (el)[key] !== nextVal)
          /** @type {any} */ (el)[key] = nextVal;
      } else {
        if (nextVal === true || nextVal === '') {
          el.setAttribute(key, '');
        } else if (nextVal == null || nextVal === false) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, String(nextVal));
        }
      }
    },
    querySelector: (selector) => document.querySelector(selector),
  });

  /**
   * @param {Component} rootComponent - The root component for the application.
   * @param {object} [rootProps={}] - Initial props for the root component.
   * @param {Record<string, Component>} [globalComponents={}] - Components to register globally.
   * @returns {App} The application instance.
   */
  return function createApp(
    rootComponent,
    rootProps = {},
    globalComponents = {},
  ) {
    /** @type {App} */
    const app = {
      _component: rootComponent,
      _container: null,
      _vnode: null,
      _context: {
        components: { ...rootComponent.components, ...globalComponents },
        provides: {},
        patch: renderer.patch,
        hydrate: renderer.hydrate,
        params: /** @type {any} */ (rootProps).params || {},
      },
      /**
       * @param {Element} rootContainer
       */
      mount(rootContainer) {
        logger.info('Mounting application...', {
          rootComponent: rootComponent.name,
          rootProps,
        });
        const vnode = createVnode(rootComponent, rootProps);
        vnode.appContext = app._context;
        app._vnode = vnode;
        app._container = rootContainer;
        const rootInstance = app._context.hydrate(vnode, rootContainer);
        if (rootInstance) {
          installNavigationHandler(app);
        }
        return rootInstance;
      },
    };
    appInstance = app;
    return app;
  };
})();

/**
 * @internal
 * @description In development mode, connects to the Hot Module Replacement WebSocket server.
 */
function connectToHmrServer() {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const url = `${protocol}//${window.location.host}/api/hmr`;
  const hmrSocket = new WebSocket(url);

  hmrSocket.onmessage = async () => {
    logger.info('HMR message received from server, forcing reload.');
    window.location.reload();
  };

  hmrSocket.onopen = () => {
    logger.info('HMR WebSocket connected.');
  };

  hmrSocket.onclose = () => {
    logger.warn('HMR WebSocket disconnected. Attempting to reconnect in 2s...');
    setTimeout(connectToHmrServer, 2000);
  };

  hmrSocket.onerror = (err) => {
    logger.error('HMR WebSocket error:', err);
  };
}

/**
 * @description Initializes the application on the client-side by hydrating server-rendered HTML.
 * @param {Map<string, () => Promise<{default: Component}>>} componentManifest - A map of component names to their async loaders.
 * @param {object | null} [dbConfig=null] - Database configuration.
 * @returns {Promise<void>}
 */
export async function hydrate(componentManifest, dbConfig = null) {
  logger.info('Starting client-side hydration... ');
  if (typeof window === 'undefined') {
    logger.info('Not in a browser environment. Aborting hydration.');
    return;
  }
  componentManifestInstance = componentManifest;

  /** @type {WebsState} */
  const websState = deserializeState(
    /** @type {any} */ (window).__WEBS_STATE__ || {},
  );
  logger.debug(
    'Initial __WEBS_STATE__ from server:',
    JSON.parse(JSON.stringify(websState)),
  );

  if (dbConfig) {
    logger.info('Database configuration found. Setting global DB config.');
    /** @type {any} */ (window).__WEBS_DB_CONFIG__ = dbConfig;
  } else {
    logger.info('No database configuration provided.');
  }

  if (websState.sourceToComponentMap) {
    sourceToComponentMap = websState.sourceToComponentMap;
    logger.debug(
      'Source-to-component mapping loaded from server state.',
      sourceToComponentMap,
    );
  }

  coreDB.setSyncEngine(syncEngine);
  syncEngine.init(coreDB);

  logger.info('Starting sync engine...');
  syncEngine.start();

  if ('serviceWorker' in navigator && websState.swPath) {
    logger.info(
      `Attempting to register service worker at: ${websState.swPath}`,
    );
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register(websState.swPath || '')
        .then((registration) => {
          logger.info(
            'Service Worker registered successfully with scope:',
            registration.scope,
          );
        })
        .catch((err) => {
          logger.error('Service Worker registration failed:', err);
        });
    });
  } else {
    logger.info('Service worker not supported or no swPath provided in state.');
  }
  if (process.env.NODE_ENV !== 'production') {
    logger.info('Development mode detected. Initializing HMR connection...');
    connectToHmrServer();
  }

  const startHydrationProcess = async () => {
    const root = document.getElementById('root');
    if (!root) {
      logger.error('Root element #root not found. Aborting hydration.');
      return;
    }

    const { componentName, user = {}, params, componentState } = websState;
    if (!componentName) {
      logger.error(
        'No componentName found in __WEBS_STATE__. Aborting hydration.',
      );
      return;
    }

    const rootComponentLoader = componentManifest.get(componentName);

    if (!rootComponentLoader) {
      logger.error(
        `Could not find component loader for "${componentName}". This may be a bundling or routing error on the server.`,
      );
      return;
    }

    try {
      const rootModule = await rootComponentLoader();
      const rootComponent = rootModule.default;

      if (!rootComponent) {
        logger.error('Failed to load root component for hydration.');
        return;
      }

      const props = { params, initialState: componentState || {}, user };
      const rootVnode = createVnode(rootComponent, props);

      logger.info(
        'Creating app instance with props:',
        JSON.parse(JSON.stringify(props)),
      );

      const app = createApp(
        rootComponent,
        props,
        rootComponent.components || {},
      );
      app._vnode = rootVnode;
      app._container = root;

      app._context.hydrate(rootVnode, root);
      logger.info('App mounted successfully.');

      installNavigationHandler(app);

      if (/** @type {any} */ (window).__WEBS_DEVELOPER__) {
        initDevTools();
        /** @type {any} */ (window).__WEBS_DEVELOPER__.registerApp(appInstance);
      }
      if (
        session &&
        typeof (/** @type {any} */ (session).setUser) === 'function'
      ) {
        /** @type {any} */ (session).setUser(websState.user);
      }
      route.value.path = window.location.pathname;
    } catch (err) {
      logger.error('Failed to load components for hydration:', err);
    }
  };

  if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', startHydrationProcess);
  } else {
    setTimeout(startHydrationProcess, 0);
  }
}

/**
 * @internal
 * @description Sets up event listeners on the root container for client-side navigation.
 * @param {App} app - The application instance.
 */
function installNavigationHandler(app) {
  appInstance = app;

  /** @param {URL} url */
  const prefetch = async (url) => {
    const hasExtension = /\.[^/]+$/.test(url.pathname);
    if (hasExtension && !url.pathname.endsWith('.html')) return;

    if (prefetchCache.has(url.href)) return;
    const res = await fetch(url.pathname + url.search, {
      headers: { 'X-Webs-Navigate': 'true' },
    });
    if (
      res.ok &&
      res.headers.get('content-type')?.includes('application/json')
    ) {
      prefetchCache.set(url.href, deserializeState(await res.json()));
    }
  };

  const eventTarget = app._container;
  if (!eventTarget) return;

  eventTarget.addEventListener(
    'mouseover',
    /** @type {EventListener} */ (
      (e) => {
        const event = /** @type {MouseEvent} */ (e);
        if (!(event.target instanceof Element)) return;
        const link = event.target.closest('a');
        if (
          !link ||
          link.target ||
          link.hasAttribute('download') ||
          event.metaKey ||
          event.ctrlKey
        )
          return;
        const href = link.getAttribute('href');
        if (!href || href.startsWith('#')) return;
        const url = new URL(href, window.location.origin);
        if (url.origin === window.location.origin) prefetch(url);
      }
    ),
  );

  eventTarget.addEventListener(
    'click',
    /** @type {EventListener} */ (
      (e) => {
        const event = /** @type {MouseEvent} */ (e);
        if (!(event.target instanceof Element)) return;
        const link = event.target.closest('a');
        if (
          !link ||
          link.target ||
          link.hasAttribute('download') ||
          event.metaKey ||
          event.ctrlKey
        )
          return;
        const href = link.getAttribute('href');
        if (!href || href.startsWith('#')) return;

        event.preventDefault();
        router.push(href, true);
      }
    ),
  );

  window.addEventListener('popstate', () => {
    const url = new URL(window.location.href);
    performNavigation(url, { isPopState: true, fromClick: false });
  });
}

/**
 * @internal
 * @description Safely deserializes a value which may be a JSON string.
 * @param {any} input - The value to deserialize.
 * @returns {any} The deserialized object.
 */
function deserializeState(input) {
  try {
    if (typeof input === 'string') return JSON.parse(input);
    return input;
  } catch (e) {
    logger.error('Failed to deserialize state:', e);
    return input;
  }
}

---------- END: core/core.js ----------

---------- START: core/component.js ----------
/**
 * @file Manages the component instance, lifecycle hooks, and provide/inject system.
 */

import { VNode } from './vdom.js';
import { isRef, state } from './reactivity.js';
import { isObject, isFunction } from '../utils/lang.js';
import { createLogger } from '../developer/logger.js';
import { compile } from '../renderer/compiler.js';
import { normalizeClass } from '../utils/dom.js';

/**
 * @typedef {import('./vdom.js').Slots} Slots
 * @typedef {import('./vdom.js').Props} Props
 * @typedef {import('../server/server.js').OpenHandler} OpenHandler
 * @typedef {import('../server/server.js').MessageHandler} MessageHandler
 * @typedef {import('../server/server.js').CloseHandler} CloseHandler
 * @typedef {import('../server/server.js').ErrorHandler} ErrorHandler
 */

/**
 * @callback PropsReceivedHook
 * @param {Readonly<Record<string, any>>} newProps - The new props object.
 * @param {Readonly<Record<string, any>>} oldProps - The previous props object.
 * @returns {void}
 */

/**
 * @typedef {object} RouteHandlerContext
 * @property {Request & { user?: any, db?: any, params?: any }} req - The request object.
 * @property {import('bun:sqlite').Database} db - The database instance.
 * @property {import('../server/authentication.js')} user - The authenticated user.
 * @property {Record<string, string>} params - URL parameters.
 * @property {import('../server/fs.server.js').ServerFsApi} fs - The user's file system API.
 */

/**
 * @typedef {'onBeforeMount' | 'onMounted' | 'onBeforeUpdate' | 'onUpdated' | 'onUnmounted' | 'onReady' | 'onPropsReceived'} LifecycleHook
 */

/**
 * @template T
 * @typedef {object} ComponentInstance
 * @property {number} uid - A unique identifier for the component instance.
 * @property {VNode} vnode - The virtual node representing this component.
 * @property {Component<T>} type - The component definition object.
 * @property {Slots} slots - The slots passed to the component.
 * @property {Props} attrs - Fallthrough attributes.
 * @property {import('./reactivity.js').ReactiveProxy<Props>} props - The reactive props object.
 * @property {object} ctx - The public context proxy for the render function.
 * @property {object} internalCtx - The internal state and setup result.
 * @property {boolean} isMounted - Whether the component is currently mounted.
 * @property {VNode | null} subTree - The root VNode of the component's rendered template.
 * @property {(() => void) | null} update - The effect runner function for updates.
 * @property {((_ctx: object) => VNode | null) | null} render - The compiled render function for the component.
 * @property {AppContext} appContext - The application-level context.
 * @property {ComponentInstance<any> | null} parent - The parent component instance.
 * @property {Record<string | symbol, any>} provides - Provided values for dependency injection.
 * @property {{
 * onBeforeMount?: Function[],
 * onMounted?: Function[],
 * onBeforeUpdate?: Function[],
 * onUpdated?: Function[],
 * onUnmounted?: Function[],
 * onReady?: Function[],
 * onPropsReceived?: PropsReceivedHook[]
 * }} hooks - Registered lifecycle hooks.
 * @property {Node | null} lastEl - The last DOM element in the component's rendered output.
 */

/**
 * @typedef {object} PropOptions
 * @property {any} [default] - The default value for the prop.
 */

/**
 * @typedef {object} SetupContext
 * @property {Readonly<Record<string, any>>} attrs
 * @property {Readonly<Slots>} slots
 * @property {Readonly<Record<string, any>>} params
 */

/**
 * @template T
 * @typedef {object} Component
 * @property {string} name
 * @property {Record<string, PropOptions>} [props]
 * @property {(props: Readonly<Props>, context: SetupContext) => object | void} [setup]
 * @property {string | (() => string)} [template]
 * @property {() => VNode | null} [render]
 * @property {Record<string, Component<any>>} [components]
 * @property {Record<string, (context: object, ...args: any[]) => any>} [actions]
 * @property {(context: RouteHandlerContext) => Promise<Response | object | void>} [post]
 * @property {(context: RouteHandlerContext) => Promise<Response | object | void>} [patch]
 * @property {(context: RouteHandlerContext) => Promise<Response | object | void>} [put]
 * @property {(context: RouteHandlerContext) => Promise<Response | object | void>} [del]
 * @property {OpenHandler} [onOpen]
 * @property {MessageHandler} [onMessage]
 * @property {CloseHandler} [onClose]
 * @property {ErrorHandler} [onError]
 */

/**
 * @typedef {object} AppContext
 * @property {Record<string, Component<any>>} [components]
 * @property {object} [globals]
 * @property {Record<string | symbol, any>} [provides]
 * @property {Record<string, any>} [params]
 * @property {(n1: VNode | null, n2: VNode | null, container: Element, anchor?: Node | null, parentComponent?: ComponentInstance<any> | null) => void} [patch]
 * @property {(vnode: VNode, container: Element) => ComponentInstance<any> | undefined | null} [hydrate]
 */

/**
 * @typedef {object} RendererOptions
 * @property {(tag: string) => Element} createElement
 * @property {(text: string) => globalThis.Text} createText
 * @property {(text: string) => globalThis.Comment} createComment
 * @property {(el: Element, text: string) => void} setElementText
 * @property {(child: Node, parent: Element, anchor?: Node | null) => void} insert
 * @property {(child: Node) => void} remove
 * @property {(el: Element, key: string, prevValue: any, nextValue: any) => void} patchProp
 * @property {(selector: string) => Element | null} querySelector
 */

/**
 * @template T
 * @typedef {object} Renderer
 * @property {(n1: VNode | null, n2: VNode | null, container: Element, anchor?: Node | null, parentComponent?: ComponentInstance<any> | null) => void} patch
 * @property {(vnode: VNode, container: Element) => ComponentInstance<any> | undefined | null} hydrate
 */

/**
 * @typedef {Window & { __WEBS_DEVELOPER__?: { events: { emit: (event: string, data: any) => void; } } }} DevtoolsWindow
 */

const logger = createLogger('[Component]');
let instanceIdCounter = 0;

/**
 * @internal
 * @type {ComponentInstance<any> | null}
 */
let currentInstance = null;

/**
 * @internal
 * @type {ComponentInstance<any>[]}
 */
const instanceStack = [];

/**
 * Provides a value that can be injected by any descendant component.
 * @param {string | symbol} key - The injection key.
 * @param {any} value - The value to provide.
 */
export function provide(key, value) {
  if (!currentInstance) return;

  if (currentInstance.provides === currentInstance.parent?.provides) {
    currentInstance.provides = Object.create(
      currentInstance.parent?.provides || null,
    );
  }
  currentInstance.provides[key] = value;
}

/**
 * Injects a value provided by an ancestor component.
 * @template T
 * @param {string | symbol} key - The injection key.
 * @param {T} [defaultValue] - A default value to return if no matching key is found.
 * @returns {T | undefined} The injected value.
 */
export function inject(key, defaultValue) {
  if (!currentInstance) return defaultValue;

  /** @type {ComponentInstance<any> | null} */
  let instance = currentInstance;
  while (instance) {
    if (instance.provides && key in instance.provides) {
      return instance.provides[key];
    }
    instance = instance.parent;
  }

  return defaultValue;
}

/**
 * @internal
 * @param {ComponentInstance<any> | null} instance
 */
export function setCurrentInstance(instance) {
  currentInstance = instance;
}

/**
 * @internal
 * @param {ComponentInstance<any>} instance
 */
export function pushInstance(instance) {
  instanceStack.push(instance);
  setCurrentInstance(instance);
}

/**
 * @internal
 */
export function popInstance() {
  instanceStack.pop();
  setCurrentInstance(instanceStack[instanceStack.length - 1] || null);
}

/**
 * @internal
 * @param {LifecycleHook} name
 * @returns {(hook: Function) => void}
 */
function createLifecycleMethod(name) {
  return (hook) => {
    if (!currentInstance) return;
    const inst = currentInstance;
    if (!inst.hooks[name]) {
      inst.hooks[name] = [];
    }
    /** @type {Function[]} */ (inst.hooks[name]).push(hook);
  };
}

export const onBeforeMount = createLifecycleMethod('onBeforeMount');
export const onMounted = createLifecycleMethod('onMounted');
export const onBeforeUpdate = createLifecycleMethod('onBeforeUpdate');
export const onUpdated = createLifecycleMethod('onUpdated');
export const onUnmounted = createLifecycleMethod('onUnmounted');
export const onReady = createLifecycleMethod('onReady');
export const onPropsReceived = createLifecycleMethod('onPropsReceived');

/**
 * @internal
 * @param {Props} vnodeProps
 * @param {Props} fallthroughAttrs
 * @returns {Props}
 */
export function mergeProps(vnodeProps, fallthroughAttrs) {
  const merged = { ...vnodeProps };
  for (const key in fallthroughAttrs) {
    if (key === 'class' && fallthroughAttrs[key]) {
      merged.class = normalizeClass([vnodeProps.class, fallthroughAttrs.class]);
    } else if (key === 'style' && fallthroughAttrs[key]) {
      merged.style = {
        ...(isObject(vnodeProps.style) ? vnodeProps.style : {}),
        ...(isObject(fallthroughAttrs.style) ? fallthroughAttrs.style : {}),
      };
    } else if (!(key in merged)) {
      merged[key] = fallthroughAttrs[key];
    }
  }
  return merged;
}

/**
 * @internal
 * @param {object} targetState
 * @param {object} serverState
 */
export function applyServerState(targetState, serverState) {
  logger.debug('Applying server state...', {
    targetState: { ...targetState },
    serverState: { ...serverState },
  });
  if (!isObject(targetState) || !isObject(serverState)) return;

  for (const key in serverState) {
    if (!Object.prototype.hasOwnProperty.call(serverState, key)) continue;
    const serverVal = /** @type {any} */ (serverState)[key];
    const existing = /** @type {Record<string, any>} */ (targetState)[key];

    if (isRef(existing)) {
      if (existing.value !== serverVal) {
        logger.debug(`Updating ref for key: ${key}`, {
          from: existing.value,
          to: serverVal,
        });
        if (isObject(existing.value) && isObject(serverVal)) {
          applyServerState(existing.value, serverVal);
        } else {
          existing.value = serverVal;
        }
      }
    } else if (Array.isArray(existing) && Array.isArray(serverVal)) {
      logger.debug(`Updating array for key: ${key}`);
      existing.length = 0;
      existing.push(...serverVal);
    } else if (
      isObject(existing) &&
      isObject(serverVal) &&
      !Array.isArray(existing)
    ) {
      logger.debug(`Recursively applying state for key: ${key}`);
      applyServerState(existing, serverVal);
    } else {
      logger.debug(`Directly setting state for key: ${key}`);
      /** @type {any} */ (targetState)[key] = serverVal;
    }
  }
}

/**
 * @internal
 * @param {VNode} vnode
 * @param {ComponentInstance<any> | null} parent
 * @param {boolean} isSsr
 * @returns {ComponentInstance<any>}
 */
export function createComponent(vnode, parent, isSsr = false) {
  const parentAppContext = parent ? parent.appContext : {};
  const appContext = vnode.appContext || parentAppContext;
  if (!appContext.globals) appContext.globals = {};
  if (!appContext.provides) appContext.provides = {};

  if (isSsr) {
    logger.debug(
      `SSR: Creating component instance for <${/**@type {Component<any>}*/ (vnode.type).name}>`,
    );
  } else {
    logger.info(
      `Creating component instance for <${/**@type {Component<any>}*/ (vnode.type).name}>`,
    );
  }

  /** @type {ComponentInstance<any>} */
  const instance = {
    uid: instanceIdCounter++,
    vnode,
    type: /**@type {Component<any>}*/ (vnode.type),
    slots: /** @type {Slots} */ (vnode.children) || {},
    attrs: {},
    props: {},
    ctx: {},
    internalCtx: {},
    isMounted: false,
    subTree: null,
    update: null,
    render: null,
    appContext,
    parent,
    provides: parent
      ? parent.provides
      : Object.create(appContext.provides || null),
    hooks: {
      onBeforeMount: [],
      onMounted: [],
      onBeforeUpdate: [],
      onUpdated: [],
      onUnmounted: [],
      onReady: [],
      onPropsReceived: [],
    },
    lastEl: null,
  };

  const { props: propsOptions, setup } = instance.type;
  const vnodeProps = vnode.props || {};
  const resolvedProps = {};

  for (const key in vnodeProps) {
    if (
      propsOptions &&
      Object.prototype.hasOwnProperty.call(propsOptions, key)
    ) {
      /** @type {any} */ (resolvedProps)[key] = vnodeProps[key];
    } else {
      /** @type {any} */ (instance.attrs)[key] = vnodeProps[key];
    }
  }

  if (propsOptions) {
    for (const key in propsOptions) {
      if (!Object.prototype.hasOwnProperty.call(resolvedProps, key)) {
        const options = propsOptions[key];
        const def = options?.hasOwnProperty('default')
          ? options.default
          : undefined;
        /** @type {any} */ (resolvedProps)[key] = isFunction(def) ? def() : def;
      }
    }
  }

  instance.props = state(resolvedProps);

  let setupResult = {};
  if (setup) {
    const setupContext = {
      attrs: instance.attrs,
      slots: instance.slots,
      params: instance.appContext.params || {},
    };
    pushInstance(instance);
    setupResult = setup(instance.props, setupContext) || {};
    popInstance();
  }

  instance.internalCtx = setupResult;

  if (!isSsr) {
    const serverState = (vnode.props || {}).initialState || {};
    const stateForHydration = { ...instance.internalCtx, ...instance.props };
    applyServerState(stateForHydration, serverState);
  }

  instance.ctx = new Proxy(
    {},
    {
      has: (_, key) =>
        !!(
          (instance.internalCtx && key in instance.internalCtx) ||
          (instance.props && key in instance.props) ||
          key === '$attrs' ||
          key === '$slots' ||
          key === '$props' ||
          (instance.appContext.params && key === 'params') ||
          (instance.type.components && key in instance.type.components) ||
          (instance.appContext.components &&
            key in instance.appContext.components) ||
          (instance.appContext.globals && key in instance.appContext.globals)
        ),
      get: (_, key) => {
        if (instance.internalCtx && key in instance.internalCtx) {
          const val = /** @type {any} */ (instance.internalCtx)[key];
          return isRef(val) ? val.value : val;
        }
        if (instance.props && key in instance.props) {
          const val = /** @type {any} */ (instance.props)[key];
          return isRef(val) ? val.value : val;
        }

        if (instance.appContext.params && key === 'params') {
          return instance.appContext.params;
        }
        if (key === '$attrs') {
          return instance.attrs;
        }
        if (key === '$slots') {
          return instance.slots;
        }
        if (key === '$props') {
          return instance.props;
        }

        if (isSsr) {
          const allComponents = {
            ...(instance.type.components || {}),
            ...(instance.appContext.components || {}),
          };
          if (key in allComponents) {
            return allComponents[/** @type {string} */ (key)];
          }
        }

        if (instance.type.components && key in instance.type.components)
          return instance.type.components[/** @type {string} */ (key)];
        if (
          instance.appContext.components &&
          key in instance.appContext.components
        )
          return instance.appContext.components[/** @type {string} */ (key)];
        if (instance.appContext.globals && key in instance.appContext.globals)
          return /** @type {any} */ (instance.appContext.globals)[key];

        return undefined;
      },
      set: (_, key, value) => {
        if (isSsr) return false;
        if (instance.internalCtx && key in instance.internalCtx) {
          const s = /** @type {any} */ (instance.internalCtx)[key];
          if (isRef(s)) {
            s.value = value;
          } else {
            /** @type {any} */ (instance.internalCtx)[key] = value;
          }
          return true;
        }
        if (instance.props && key in instance.props) {
          logger.warn(
            `Attempted to mutate prop "${String(key)}". Props are readonly.`,
          );
        }
        return false;
      },
    },
  );

  instance.render = compile(instance.type, {
    globalComponents: instance.appContext.components,
  });

  return instance;
}

---------- END: core/component.js ----------

---------- START: core/reactivity.js ----------
/**
 * @file Manages the core reactivity system, including refs, effects, and reactive proxies.
 */

import { isObject } from '../utils/lang.js';
import { createLogger } from '../developer/logger.js';

/**
 * @callback EffectScheduler
 * @returns {void}
 */

/**
 * @typedef {object} ReactiveEffect
 * @property {Function} fn - The function to execute.
 * @property {EffectScheduler} [scheduler] - A scheduler to control when the effect runs.
 * @property {boolean} active - Whether the effect is currently active.
 * @property {Set<ReactiveEffect>[]} deps - The dependencies this effect is subscribed to.
 * @property {() => any} run - Executes the effect function.
 * @property {() => void} stop - Deactivates the effect and cleans up its dependencies.
 */

/**
 * @template T
 * @typedef {object} Ref
 * @property {T} value - The reactive value.
 * @property {true} __is_ref - A flag to identify this as a Ref.
 */

/**
 * @template T
 * @typedef {object} ComputedRef
 * @property {T} value - The read-only computed value.
 * @property {true} __is_ref - A flag to identify this as a Ref.
 * @property {true} __is_computed - A flag to identify this as a computed property.
 * @property {T} oldValue - The previous value of the computed property.
 */

/**
 * @template T
 * @typedef {T & {}} ReactiveProxy
 */

/**
 * @template S, G, A
 * @typedef {object} StoreOptions
 * @property {() => S} state - A function that returns the initial state object.
 * @property {G} [getters] - An object of computed properties for the store.
 * @property {A} [actions] - An object of methods to mutate the store's state.
 */

/**
 * @typedef {object} EffectOptions
 * @property {EffectScheduler} [scheduler] - An optional scheduler function.
 */

/**
 * @template T
 * @callback ComputedGetter
 * @returns {T}
 */

const logger = createLogger('[Reactivity]');

/**
 * @internal
 * @type {ReactiveEffect | null}
 * The currently running effect. Dependencies are tracked against this effect.
 */
let activeEffect = null;

/**
 * @internal
 * @type {ReactiveEffect[]}
 * A stack of active effects, used to handle nested effects correctly.
 */
const effectStack = [];

/**
 * @internal
 * @type {WeakMap<object, Map<any, Set<ReactiveEffect>>>}
 * Maps a reactive object to a map of its properties and the effects that depend on them.
 * WeakMap: target -> Map: key -> Set: effects
 */
const targetMap = new WeakMap();

/**
 * @internal
 * @type {WeakMap<object, any>}
 * Caches reactive proxies to ensure the same object always returns the same proxy.
 */
const proxyMap = new WeakMap();

/**
 * A symbol used to retrieve the original, raw object from a reactive proxy.
 * @type {symbol}
 */
export const RAW_SYMBOL = Symbol('raw');

/**
 * @internal
 * Tracks a dependency between a reactive property and the currently active effect.
 * @param {object} target - The reactive object being accessed.
 * @param {string | symbol | number} key - The property key being accessed.
 */
function track(target, key) {
  if (activeEffect) {
    logger.debug(`Tracking dependency for key: "${String(key)}"`);
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      depsMap = new Map();
      targetMap.set(target, depsMap);
      logger.debug(`- Created new dependency map for target:`, target);
    }
    let dep = depsMap.get(key);
    if (!dep) {
      dep = new Set();
      depsMap.set(key, dep);
      logger.debug(`- Created new dependency set for key: "${String(key)}"`);
    }
    dep.add(/** @type {ReactiveEffect} */ (activeEffect));
    /** @type {ReactiveEffect} */ (activeEffect).deps.push(dep);
    logger.debug(`- Added effect to dependency set for key: "${String(key)}"`);
  }
}

/**
 * @internal
 * Triggers all effects that depend on a specific reactive property.
 * @param {object} target - The reactive object that was mutated.
 * @param {string | symbol | number} key - The property key that was mutated.
 */
function trigger(target, key) {
  logger.debug(`Triggering effects for key: "${String(key)}"`);
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    logger.debug('- No dependency map found, skipping trigger.');
    return;
  }

  const effectsToRun = new Set();
  const dep = depsMap.get(key);
  if (dep) {
    logger.debug('- Found direct dependencies.');
    dep.forEach((effect) => effectsToRun.add(effect));
  }

  if (Array.isArray(target) && key === 'length') {
    logger.debug(
      '- Array length change detected, checking for out-of-bounds dependencies.',
    );
    depsMap.forEach((dep, depKey) => {
      if (typeof depKey === 'number' && depKey >= target.length) {
        dep.forEach((effect) => effectsToRun.add(effect));
      }
    });
  }

  if (effectsToRun.size > 0) {
    logger.info(`Running ${effectsToRun.size} effects.`);
  }

  effectsToRun.forEach((effect) => {
    if (effect.scheduler) {
      logger.debug('Executing scheduler for effect:', effect);
      effect.scheduler();
    } else {
      logger.debug('Running effect:', effect);
      effect.run();
    }
  });
}

/**
 * @internal
 * Removes an effect from all of its dependency sets.
 * @param {ReactiveEffect} effect - The effect to clean up.
 */
function cleanup(effect) {
  logger.debug('Cleaning up dependencies for effect:', effect);
  const { deps } = effect;
  for (let i = 0; i < deps.length; i++) {
    const dep = deps[i];
    if (dep) dep.delete(effect);
  }
  deps.length = 0;
  logger.debug('Cleanup complete.');
}

/**
 * Checks if a value is a ref.
 * @param {any} r - The value to check.
 * @returns {r is Ref<any>} `true` if the value is a ref, otherwise `false`.
 */
export function isRef(r) {
  return !!(r && r.__is_ref === true);
}

/**
 * Creates a reactive reference (ref) from a value.
 * @template T
 * @param {T} value - The initial value.
 * @returns {Ref<T>} A reactive ref object.
 * @example
 * const count = ref(0);
 * console.log(count.value);
 * count.value++;
 */
export function ref(value) {
  logger.debug('Creating new ref.');
  return createRef(value);
}

/**
 * @internal
 * @template T
 * @param {T} value
 * @returns {Ref<T>}
 */
function createRef(value) {
  const wrapper = {
    _value: value,
    __is_ref: /** @type {const} */ (true),
    get value() {
      track(this, 'value');
      return this._value;
    },
    set value(newValue) {
      if (newValue !== this._value) {
        this._value = newValue;
        trigger(this, 'value');
      }
    },
  };
  return wrapper;
}

/**
 * @internal
 * Creates a reactive proxy for an object.
 * @template {object} T
 * @param {T} target - The object to make reactive.
 * @returns {ReactiveProxy<T>} A reactive proxy of the target.
 */
function reactive(target) {
  if (!isObject(target) && !Array.isArray(target)) return target;
  if (proxyMap.has(target)) return proxyMap.get(target);

  /** @type {ProxyHandler<any>} */
  let handlers;
  if (Array.isArray(target)) {
    handlers = arrayHandlers;
  } else if (target instanceof Map) {
    handlers = collectionHandlers.map;
  } else if (target instanceof Set) {
    handlers = collectionHandlers.set;
  } else {
    handlers = baseHandlers;
  }

  const proxy = new Proxy(target, handlers);
  proxyMap.set(target, proxy);
  logger.debug('Created new reactive proxy.', {
    originalTarget: target,
    proxy,
  });
  return proxy;
}

/**
 * Creates a reactive state object or ref.
 * If the initial value is an object or an array, it returns a reactive proxy.
 * Otherwise, it returns a ref.
 * @template T
 * @param {T} initialValue - The initial state value.
 * @returns {T extends object ? ReactiveProxy<T> : Ref<T>}
 * @example
 * const counter = state(0);
 * const user = state({ name: 'webs' });
 */
export function state(initialValue) {
  logger.debug('Creating new state object/ref.');
  if (isObject(initialValue) || Array.isArray(initialValue)) {
    return /** @type {T extends object ? ReactiveProxy<T> : Ref<T>} */ (
      reactive(initialValue)
    );
  }
  return /** @type {T extends object ? ReactiveProxy<T> : Ref<T>} */ (
    createRef(initialValue)
  );
}

/**
 * Creates a centralized state management store.
 * @template {object} S
 * @template {Record<string, (...args: any[]) => any>} [G={}]
 * @template {Record<string, (...args: any[]) => any>} [A={}]
 * @param {StoreOptions<S, G, A>} options - The store configuration.
 * @returns {ReactiveProxy<S> & G & A} A reactive store instance.
 */
export function store(options) {
  const state = reactive(options.state());
  /** @type {Record<string | symbol, any>} */
  const methodsAndGetters = {};

  const proxy = new Proxy(state, {
    get(target, key, receiver) {
      if (key in methodsAndGetters) {
        return methodsAndGetters[key];
      }
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      if (key in methodsAndGetters) {
        logger.warn(
          `Attempted to overwrite store getter or action: "${String(key)}"`,
        );
        return false;
      }
      return Reflect.set(target, key, value, receiver);
    },
    has(target, key) {
      return key in methodsAndGetters || Reflect.has(target, key);
    },
    ownKeys(target) {
      return [...Reflect.ownKeys(target), ...Object.keys(methodsAndGetters)];
    },
    getOwnPropertyDescriptor(target, key) {
      if (key in methodsAndGetters) {
        return Object.getOwnPropertyDescriptor(methodsAndGetters, key);
      }
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
  });

  if (options.getters) {
    for (const key in options.getters) {
      const getterFn = options.getters[key];
      const computedFn = computed(() => getterFn?.call(proxy));
      Object.defineProperty(methodsAndGetters, key, {
        get: () => computedFn.value,
        enumerable: true,
      });
    }
  }

  if (options.actions) {
    for (const key in options.actions) {
      const actionFn = options.actions[key];
      methodsAndGetters[key] = actionFn?.bind(proxy);
    }
  }

  return /** @type {ReactiveProxy<S> & G & A} */ (proxy);
}

/**
 * @internal
 * Base handlers for reactive object proxies.
 * @type {ProxyHandler<object>}
 */
const baseHandlers = {
  get(target, key, receiver) {
    if (key === RAW_SYMBOL) return target;
    const value = Reflect.get(target, key, receiver);
    track(target, key);
    const unwrapped = isRef(value) ? value.value : value;
    return isObject(unwrapped) || Array.isArray(unwrapped)
      ? reactive(unwrapped)
      : unwrapped;
  },
  set(target, key, value, receiver) {
    const oldValue = Reflect.get(target, key, receiver);
    const result = Reflect.set(target, key, value, receiver);
    if (oldValue !== value) {
      trigger(target, key);
    }
    return result;
  },
};

/**
 * @internal
 * A map of array mutation methods that should trigger a length change.
 */
const arrayMutationMethods = new Set([
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse',
]);

/**
 * @internal
 * Handlers for reactive array proxies.
 * @type {ProxyHandler<any[]>}
 */
const arrayHandlers = {
  get(target, key, receiver) {
    if (key === RAW_SYMBOL) return target;

    if (typeof key === 'string' || typeof key === 'number') {
      track(target, key);
    }

    const value = Reflect.get(target, key, receiver);

    if (typeof value === 'function' && arrayMutationMethods.has(String(key))) {
      // @ts-ignore
      return function (...args) {
        const result = Reflect.apply(value, target, args);
        trigger(target, 'length');
        for (let i = 0; i < target.length; i++) {
          trigger(target, i);
        }
        return result;
      };
    }

    return isObject(value) || Array.isArray(value) ? reactive(value) : value;
  },
  set(target, key, value, receiver) {
    const oldValue = Reflect.get(target, key, receiver);
    const hadKey = Object.prototype.hasOwnProperty.call(target, key);
    const result = Reflect.set(target, key, value, receiver);

    if (!hadKey) {
      if (typeof key === 'string' && /^\d+$/.test(key)) {
        trigger(target, 'length');
      }
      trigger(target, key);
    } else if (oldValue !== value) {
      trigger(target, key);
    }
    return result;
  },
};

/**
 * @internal
 * Handlers for reactive Map and Set proxies.
 * @type {{map: ProxyHandler<Map<any, any>>, set: ProxyHandler<Set<any>>}}
 */
const collectionHandlers = {
  map: {
    get(target, key, _receiver) {
      if (key === RAW_SYMBOL) return target;
      if (key === 'size') {
        track(target, 'size');
        return Reflect.get(target, 'size', target);
      }

      const value = Reflect.get(target, key, target);

      if (typeof value === 'function') {
        switch (key) {
          case 'get':
            return (/** @type {any} */ k) => {
              track(target, k);
              const res = target.get(k);
              return isObject(res) ? reactive(res) : res;
            };
          case 'has':
            return (/** @type {any} */ k) => {
              track(target, k);
              return target.has(k);
            };
          case 'set':
            return (/** @type {any} */ k, /** @type {any} */ v) => {
              const had = target.has(k);
              const oldValue = target.get(k);
              const result = target.set(k, v);
              if (!had) {
                trigger(target, 'size');
              }
              if (!had || oldValue !== v) {
                trigger(target, k);
              }
              return result;
            };
          case 'delete':
            return (/** @type {any} */ k) => {
              const had = target.has(k);
              const result = target.delete(k);
              if (had) {
                trigger(target, 'size');
                trigger(target, k);
              }
              return result;
            };
          case 'clear':
            return () => {
              const hadItems = target.size > 0;
              const result = target.clear();
              if (hadItems) {
                trigger(target, 'size');
              }
              return result;
            };
          default:
            return value.bind(target);
        }
      }
      return value;
    },
    set: (target, key, value, receiver) => {
      return Reflect.set(target, key, value, receiver);
    },
  },
  set: {
    get(target, key) {
      if (key === RAW_SYMBOL) return target;
      if (key === 'size') {
        track(target, 'size');
        return Reflect.get(target, key, target);
      }

      const value = Reflect.get(target, key, target);
      if (typeof value === 'function') {
        switch (key) {
          case 'has':
            return (/** @type {any} */ v) => {
              track(target, v);
              return target.has(v);
            };
          case 'add':
            return (/** @type {any} */ v) => {
              const had = target.has(v);
              const result = target.add(v);
              if (!had) {
                trigger(target, 'size');
                trigger(target, v);
              }
              return result;
            };
          case 'delete':
            return (/** @type {any} */ v) => {
              const had = target.has(v);
              const result = target.delete(v);
              if (had) {
                trigger(target, 'size');
                trigger(target, v);
              }
              return result;
            };
          case 'clear':
            return () => {
              const hadItems = target.size > 0;
              const result = target.clear();
              if (hadItems) {
                trigger(target, 'size');
              }
              return result;
            };
          default:
            return value.bind(target);
        }
      }
      return value;
    },
    set: (target, key, value, receiver) => {
      return Reflect.set(target, key, value, receiver);
    },
  },
};

/**
 * @internal
 * Creates a reactive effect runner.
 * @param {Function} fn - The function to be executed inside the effect.
 * @param {EffectScheduler} [scheduler] - An optional scheduler function.
 * @returns {ReactiveEffect} The created effect object.
 */
function createReactiveEffect(fn, scheduler) {
  /** @type {ReactiveEffect} */
  const effect = {
    fn,
    scheduler,
    active: true,
    deps: [],
    run() {
      logger.debug('Running effect function...');
      if (!effect.active) {
        logger.debug('- Effect is inactive, skipping.');
        return effect.fn();
      }
      if (effectStack.includes(effect)) {
        logger.debug('- Effect already in stack, avoiding infinite loop.');
        return;
      }

      cleanup(effect);
      try {
        effectStack.push(effect);
        activeEffect = effect;
        const result = effect.fn();
        logger.debug('- Effect function completed.');
        return result;
      } finally {
        effectStack.pop();
        activeEffect = effectStack[effectStack.length - 1] || null;
        logger.debug('- Restored active effect from stack.');
      }
    },
    stop() {
      if (effect.active) {
        logger.info('Stopping effect...');
        cleanup(effect);
        effect.active = false;
        logger.info('Effect stopped successfully.');
      } else {
        logger.warn('Attempted to stop an inactive effect.');
      }
    },
  };
  return effect;
}

/**
 * Runs a function and reactively tracks its dependencies.
 * @param {Function | Ref<any> | ReactiveProxy<any>} source - The function to run and track, or a reactive source to watch.
 * @param {Function} [callback] - The callback function to run when the source changes.
 * @param {EffectOptions} [options] - Optional effect options.
 * @returns {(() => any) & { effect: ReactiveEffect }} A function to stop the effect.
 * @example
 * const count = state(0);
 * effect(() => console.log(count.value));
 * const user = state({ name: 'Webs' });
 * effect(() => user.name, (newName, oldName) => console.log(newName));
 */
export function effect(source, callback, options) {
  logger.info('Creating new effect.');
  let runner;
  const isWatcher = typeof callback === 'function';

  if (isWatcher) {
    /** @type {any} */
    let oldValue;
    const getter = () => {
      return typeof source === 'function'
        ? source()
        : isRef(source)
          ? source.value
          : source;
    };

    const computedRef = computed(getter);

    runner = createReactiveEffect(() => {
      const newValue = computedRef.value;
      if (newValue !== oldValue) {
        logger.debug('Effect callback triggered due to value change.');
        callback(newValue, oldValue);
        oldValue = newValue;
      }
    }, options?.scheduler);
  } else {
    if (typeof source !== 'function') {
      logger.error(
        'Invalid source provided. effect with a single argument must be a function.',
      );
      throw new Error('effect with a single argument must be a function.');
    }
    const effectOptions = /** @type {EffectOptions | undefined} */ (callback);
    runner = createReactiveEffect(source, effectOptions?.scheduler);
  }
  runner.run();
  const runnerWrapper =
    /** @type {(() => any) & { effect: ReactiveEffect }} */ (
      () => runner.run()
    );
  runnerWrapper.effect = runner;
  logger.info('Effect created and ran for the first time.');
  return runnerWrapper;
}

/**
 * Creates a computed property that reactively calculates its value.
 * @template T
 * @param {ComputedGetter<T>} getter - The function to compute the value.
 * @returns {ComputedRef<T>} A read-only ref whose value is the result of the getter.
 * @example
 * const count = ref(1);
 * const double = computed(() => count.value * 2);
 * console.log(double.value);
 */
export function computed(getter) {
  logger.debug('Creating new computed property.');
  /** @type {any} */
  let computedValue;
  /** @type {any} */
  let oldValue;
  let isDirty = true;

  const scheduler = () => {
    if (!isDirty) {
      isDirty = true;
      trigger(computedRef, 'value');
      logger.debug('Scheduler: marked computed property as dirty.');
    }
  };

  const getterEffect = createReactiveEffect(getter, scheduler);

  const computedRef = {
    get value() {
      if (isDirty) {
        logger.debug('Computed property is dirty, recalculating value.');
        oldValue = computedValue;
        computedValue = getterEffect.run();
        isDirty = false;
      }
      track(computedRef, 'value');
      logger.debug(
        `Computed value accessed, tracking dependency. Current value: ${JSON.stringify(computedValue)}`,
      );
      return computedValue;
    },
    get oldValue() {
      logger.debug(
        `Old computed value accessed. Old value: ${JSON.stringify(oldValue)}`,
      );
      return oldValue;
    },
    __is_ref: /** @type {const} */ (true),
    __is_computed: /** @type {const} */ (true),
  };
  logger.debug('Computed property created.');
  return /** @type {ComputedRef<any>} */ (/** @type {unknown} */ (computedRef));
}

---------- END: core/reactivity.js ----------

---------- START: core/vdom.js ----------
/**
 * @file Defines the core Virtual DOM (VDOM) structures and creation functions.
 */

import { isObject } from '../utils/lang.js';

/**
 * @typedef {import('../renderer/renderer.js').Component<any>} Component
 * @typedef {import('./component.js').ComponentInstance<any>} ComponentInstance
 * @typedef {import('../renderer/renderer.js').AppContext} AppContext
 */

/**
 * @typedef {Record<string, any>} Props
 */

/**
 * @typedef {VNode | string | number | null | undefined} VNodeChild
 */

/**
 * @typedef {VNodeChild[]} VNodeChildrenArray
 */

/**
 * @typedef {VNodeChild | VNodeChildrenArray} VNodeChildren
 */

/**
 * @typedef {Record<string, () => VNodeChildren>} Slots
 */

export const Text = Symbol('Text');
export const Comment = Symbol('Comment');
export const Fragment = Symbol('Fragment');
export const Teleport = Symbol('Teleport');
export const DynamicText = Symbol('DynamicText');

export class VNode {
  /**
   * @param {string | symbol | Component} type
   * @param {Props | null} props
   * @param {VNodeChildren | Slots | string | null} children
   */
  constructor(type, props, children) {
    this.type = type;
    this.props = props || {};
    this.children = children;
    /** @type {Node | null} */
    this.el = null;
    this.key = this.props.key;
    /** @type {ComponentInstance | null} */
    this.component = null;
    /** @type {AppContext | null} */
    this.appContext = null;
  }
}

/**
 * Low-level VNode creation. The `h` function is the public-facing API.
 * @param {string | symbol | Component} type
 * @param {Props | null} props
 * @param {VNodeChildren | string | null} [children]
 * @returns {VNode}
 */
export function createVnode(type, props, children) {
  let normalizedChildren = null;

  if (children !== undefined && children !== null) {
    if (type === Text || type === Comment) {
      normalizedChildren = Array.isArray(children)
        ? children.filter((c) => c != null).join('')
        : String(children);
    } else {
      const childNodes = Array.isArray(children) ? children : [children];
      const flattened = childNodes
        .flat()
        .filter((c) => c !== null && c !== undefined && typeof c !== 'boolean')
        .map((c) =>
          isObject(c) && 'type' in c
            ? /** @type {VNode} */ (c)
            : new VNode(Text, null, String(c)),
        );

      if (flattened.length > 0) {
        normalizedChildren = /** @type {VNodeChildrenArray} */ (flattened);
      }
    }
  }

  return new VNode(type, props, normalizedChildren);
}

/**
 * Hyperscript function for creating VNodes. Public API for manual render functions.
 * @param {string | symbol | Component} type
 * @param {Props | VNodeChildren | null} [propsOrChildren]
 * @param {...(VNodeChildren | Slots)} childrenArgs - Can be VNode children or a single slots object.
 * @returns {VNode}
 */
export function h(type, propsOrChildren, ...childrenArgs) {
  const isComponent = typeof type === 'function' || isObject(type);
  const hasProps =
    isObject(propsOrChildren) &&
    !Array.isArray(propsOrChildren) &&
    !(propsOrChildren instanceof VNode);

  const props = hasProps ? /** @type {Props} */ (propsOrChildren) : {};
  const children = hasProps ? childrenArgs : [propsOrChildren, ...childrenArgs];

  if (
    isComponent &&
    children.length === 1 &&
    isObject(children[0]) &&
    !Array.isArray(children[0]) &&
    !(/** @type {any} */ (children[0] instanceof VNode))
  ) {
    const slots = /** @type {Slots} */ (children[0]);
    return new VNode(type, props, slots);
  }

  const finalChildren = /** @type {VNodeChildren} */ (
    /** @type {unknown} */ (children)
  );
  return createVnode(type, props, finalChildren);
}

---------- END: core/vdom.js ----------

---------- START: renderer/template-parser.js ----------
/**
 * @file Type definitions for the template parser.
 */

/**
 * @typedef {object} HtmlToken
 * @property {string} type - The type of the token.
 */

/** @typedef {HtmlToken & { content: string }} TextToken */
/** @typedef {HtmlToken & { content: string }} CommentToken */
/** @typedef {HtmlToken & { expression: string }} IfStartToken */
/** @typedef {HtmlToken & { expression: string, item: string, key: string | null }} EachStartToken */
/** @typedef {HtmlToken & { expression: string }} ElseIfToken */
/** @typedef {HtmlToken} ElseToken */
/** @typedef {HtmlToken} IfEndToken */
/** @typedef {HtmlToken} EachEndToken */
/** @typedef {HtmlToken & { tagName: string, attributes: AttributeToken[], selfClosing: boolean }} TagStartToken */
/** @typedef {HtmlToken & { tagName: string }} TagEndToken */
/** @typedef {{ name: string, value: string | true }} AttributeToken */

/** @typedef {TextToken | CommentToken | IfStartToken | EachStartToken | ElseIfToken | ElseToken | IfEndToken | EachEndToken | TagStartToken | TagEndToken} AnyHtmlToken */

/**
 * @typedef {object} HtmlAstNode
 * @property {string} type - The type of the AST node.
 * @property {HtmlAstNode[]} [children] - Child nodes.
 */

/** @typedef {HtmlAstNode & { children: HtmlAstNode[] }} RootNode */
/** @typedef {HtmlAstNode & { test: string, children: HtmlAstNode[] }} IfBlockNode */
/** @typedef {HtmlAstNode & { test: string, children: HtmlAstNode[] }} ElseIfBlockNode */
/** @typedef {HtmlAstNode & { children: HtmlAstNode[] }} ElseBlockNode */
/** @typedef {HtmlAstNode & { expression: string, item: string, key: string | null, children: HtmlAstNode[] }} EachBlockNode */
/** @typedef {HtmlAstNode & { tagName: string, attributes: AttributeToken[], children: HtmlAstNode[] }} ElementNode */
/** @typedef {HtmlAstNode & { content: string }} TextNode */
/** @typedef {HtmlAstNode & { content: string }} CommentNode */

/**
 * @file A high-performance, caching HTML parser designed specifically for the framework's custom template syntax, including directives and bindings.
 */

import { voidElements } from '../utils/dom.js';

/** @type {Map<string, RootNode>} */
const htmlAstCache = new Map();

const directiveRegex =
  /{#if\s+(.+?)}|{#each\s+(.+?)\s+as\s+(.+?)(?:\s*\((.+?)\))?}|{:else if\s+(.+?)}|{:else}|{\/if}|{\/each}/g;

/**
 * @internal
 * Tokenizes an HTML string, separating template directives from HTML content.
 * @param {string} html - The HTML string to tokenize.
 * @returns {AnyHtmlToken[]} An array of tokens.
 */
function tokenizeHtml(html) {
  /** @type {AnyHtmlToken[]} */
  const tokens = [];
  let lastIndex = 0;

  html.replace(
    directiveRegex,
    (match, ifExpr, eachExpr, eachItem, eachKey, elseIfExpr, offset) => {
      if (offset > lastIndex) {
        tokens.push({
          type: 'text',
          content: html.substring(lastIndex, offset),
        });
      }

      if (ifExpr) {
        tokens.push({ type: 'ifStart', expression: ifExpr.trim() });
      } else if (eachExpr) {
        tokens.push({
          type: 'eachStart',
          expression: eachExpr.trim(),
          item: eachItem.trim(),
          key: eachKey ? eachKey.trim() : null,
        });
      } else if (elseIfExpr) {
        tokens.push({ type: 'elseIf', expression: elseIfExpr.trim() });
      } else if (match === '{:else}') {
        tokens.push({ type: 'else' });
      } else if (match === '{/if}') {
        tokens.push({ type: 'ifEnd' });
      } else if (match === '{/each}') {
        tokens.push({ type: 'eachEnd' });
      }

      lastIndex = offset + match.length;
      return match;
    },
  );

  if (lastIndex < html.length) {
    tokens.push({ type: 'text', content: html.substring(lastIndex) });
  }

  /** @type {AnyHtmlToken[]} */
  const finalTokens = [];
  for (const token of tokens) {
    if (token.type === 'text') {
      finalTokens.push(
        ...tokenizeHtmlContent(/** @type {TextToken} */ (token).content),
      );
    } else {
      finalTokens.push(token);
    }
  }

  return finalTokens;
}

/**
 * @internal
 * Tokenizes the content part of an HTML string (tags, text, comments).
 * @param {string} html - The HTML content string.
 * @returns {Array<TextToken | CommentToken | TagStartToken | TagEndToken>} An array of content tokens.
 */
function tokenizeHtmlContent(html) {
  /** @type {Array<TextToken | CommentToken | TagStartToken | TagEndToken>} */
  const tokens = [];
  const tagRegex = /<\/?([a-zA-Z0-9:-]+)\s*([^>]*)>|<!--([\s\S]*?)-->/g;
  let lastIndex = 0;

  html.replace(tagRegex, (match, tagName, attrs, comment, offset) => {
    if (offset > lastIndex) {
      const textContent = html.substring(lastIndex, offset);
      if (textContent) {
        tokens.push({
          type: 'text',
          content: textContent,
        });
      }
    }

    if (comment !== undefined) {
      tokens.push({ type: 'comment', content: comment || '' });
    } else if (match.startsWith('</')) {
      tokens.push({ type: 'tagEnd', tagName });
    } else {
      /** @type {AttributeToken[]} */
      const attributes = [];
      const attrRegex =
        /([:@#]?[a-zA-Z0-9:.-]+)(?:=(?:"([^"]*)"|'([^']*)'|([^>\s]+)))?/g;
      let attrMatch;
      while ((attrMatch = attrRegex.exec(attrs))) {
        const name = attrMatch[1];
        if (name) {
          attributes.push({
            name: name,
            value: attrMatch[2] ?? attrMatch[3] ?? attrMatch[4] ?? true,
          });
        }
      }
      tokens.push({
        type: 'tagStart',
        tagName,
        attributes,
        selfClosing: match.endsWith('/>'),
      });
    }
    lastIndex = offset + match.length;
    return match;
  });

  if (lastIndex < html.length) {
    const textContent = html.substring(lastIndex);
    if (textContent) {
      tokens.push({ type: 'text', content: textContent });
    }
  }
  return tokens;
}

/**
 * @internal
 * Builds an Abstract Syntax Tree (AST) from an array of tokens.
 * @param {AnyHtmlToken[]} tokens - The flat array of tokens.
 * @returns {RootNode} The root of the AST.
 */
function buildTree(tokens) {
  /** @type {RootNode} */
  const root = { type: 'root', children: [] };
  /** @type {(RootNode | ElementNode | IfBlockNode | ElseIfBlockNode | ElseBlockNode | EachBlockNode)[]} */
  const stack = [root];

  for (const token of tokens) {
    let parent = stack[stack.length - 1];
    if (!parent) continue;

    switch (token.type) {
      case 'ifStart': {
        const node = /** @type {IfBlockNode} */ ({
          type: 'ifBlock',
          test: /** @type {IfStartToken} */ (token).expression,
          children: [],
        });
        parent.children?.push(node);
        stack.push(node);
        break;
      }
      case 'elseIf': {
        stack.pop();
        parent = stack[stack.length - 1];
        if (!parent) continue;
        const node = /** @type {ElseIfBlockNode} */ ({
          type: 'elseIfBlock',
          test: /** @type {ElseIfToken} */ (token).expression,
          children: [],
        });
        parent.children?.push(node);
        stack.push(node);
        break;
      }
      case 'else': {
        stack.pop();
        parent = stack[stack.length - 1];
        if (!parent) continue;
        const node = /** @type {ElseBlockNode} */ ({
          type: 'elseBlock',
          children: [],
        });
        parent.children?.push(node);
        stack.push(node);
        break;
      }
      case 'eachStart': {
        const eachToken = /** @type {EachStartToken} */ (token);
        const node = /** @type {EachBlockNode} */ ({
          type: 'eachBlock',
          expression: eachToken.expression,
          item: eachToken.item,
          key: eachToken.key,
          children: [],
        });
        parent.children?.push(node);
        stack.push(node);
        break;
      }
      case 'ifEnd':
      case 'eachEnd': {
        stack.pop();
        break;
      }
      case 'tagStart': {
        const tagToken = /** @type {TagStartToken} */ (token);
        const node = /** @type {ElementNode} */ ({
          type: 'element',
          tagName: tagToken.tagName.toLowerCase(),
          attributes: tagToken.attributes,
          children: [],
        });
        parent.children?.push(node);
        if (!tagToken.selfClosing && !voidElements.has(node.tagName)) {
          stack.push(node);
        }
        break;
      }
      case 'tagEnd': {
        if (
          stack.length > 1 &&
          /** @type {ElementNode} */ (parent).tagName ===
            /** @type {TagEndToken} */ (token).tagName.toLowerCase()
        ) {
          stack.pop();
        }
        break;
      }
      case 'text': {
        const content = /** @type {TextToken} */ (token).content;
        if (content.trim().length > 0) {
          parent.children?.push(
            /** @type {TextNode} */ ({ type: 'text', content: content }),
          );
        }
        break;
      }
      case 'comment': {
        parent.children?.push(
          /** @type {CommentNode} */ ({
            type: 'comment',
            content: /** @type {CommentToken} */ (token).content,
          }),
        );
        break;
      }
    }
  }
  return root;
}

/**
 * Parses an HTML string into an Abstract Syntax Tree (AST).
 * This function handles standard HTML, comments, and custom templating directives
 * like `{#if}` and `{#each}`. The result is cached.
 * @param {string} html - The HTML template string to parse.
 * @returns {RootNode} The root node of the generated AST.
 */
export function parseHtml(html) {
  const cached = htmlAstCache.get(html);
  if (cached) {
    return cached;
  }
  const tokens = tokenizeHtml(html);
  const ast = buildTree(tokens);
  htmlAstCache.set(html, ast);
  return ast;
}

---------- END: renderer/template-parser.js ----------

---------- START: renderer/renderer.js ----------
/**
 * @typedef {import('../core/vdom.js').VNode} VNode
 * @typedef {import('../core/vdom.js').Slots} Slots
 * @typedef {import('../core/vdom.js').Props} Props
 */

/**
 * A generic function type for lifecycle hooks.
 * @typedef {(...args: any[]) => void} Hook
 */

/**
 * @typedef {object} PropOptions
 * @property {any} [default] - The default value for the prop.
 */

/**
 * @typedef {object} SetupContext
 * @property {Readonly<Record<string, any>>} attrs
 * @property {Readonly<Slots>} slots
 * @property {Readonly<Record<string, any>>} params
 */

/**
 * @template T
 * @typedef {object} Component
 * @property {string} name
 * @property {Record<string, PropOptions>} [props]
 * @property {(props: Readonly<Props>, context: SetupContext) => object | void} [setup]
 * @property {string | (() => string)} [template]
 * @property {() => VNode | null} [render]
 * @property {Record<string, Component<any>>} [components]
 */

/**
 * @typedef {object} AppContext
 * @property {Record<string, Component<any>>} [components]
 * @property {object} [globals]
 * @property {Record<string | symbol, any>} [provides]
 * @property {Record<string, any>} [params]
 * @property {(n1: VNode | null, n2: VNode | null, container: Element, anchor?: Node | null, parentComponent?: any | null) => void} [patch]
 * @property {(vnode: VNode, container: Element) => any | undefined | null} [hydrate]
 */

/**
 * @typedef {object} RendererOptions
 * @property {(tag: string) => Element} createElement
 * @property {(text: string) => globalThis.Text} createText
 * @property {(text: string) => globalThis.Comment} createComment
 * @property {(el: Element, text: string) => void} setElementText
 * @property {(child: Node, parent: Element, anchor?: Node | null) => void} insert
 * @property {(child: Node) => void} remove
 * @property {(el: Element, key: string, prevValue: any, nextValue: any) => void} patchProp
 * @property {(selector: string) => Element | null} querySelector
 */

/**
 * @template T
 * @typedef {object} Renderer
 * @property {(n1: VNode | null, n2: VNode | null, container: Element, anchor?: Node | null, parentComponent?: import('../core/component.js').ComponentInstance<any> | null) => void} patch
 * @property {(vnode: VNode, container: Element) => import('../core/component.js').ComponentInstance<any> | undefined | null} hydrate
 */

/**
 * @typedef {Window & { __WEBS_DEVELOPER__?: { events: { emit: (event: string, data: any) => void; } } }} DevtoolsWindow
 */

/**
 * @file Core DOM rendering engine. Handles VDOM patching, component lifecycle, and hydration.
 */

import { effect } from '../core/reactivity.js';
import { createLogger } from '../developer/logger.js';
import { isObject, isString } from '../utils/lang.js';
import {
  createComponent,
  pushInstance,
  popInstance,
  mergeProps,
  applyServerState,
} from '../core/component.js';
import {
  Text,
  Comment,
  Fragment,
  Teleport,
  DynamicText,
  createVnode,
} from '../core/vdom.js';

const logger = createLogger('[Renderer]');
/** @type {DevtoolsWindow} */
const devtools =
  typeof window !== 'undefined' ? /** @type {any} */ (window) : {};

/**
 * @internal
 * @param {Node | null} node
 * @returns {string}
 */
function getNodeDescription(node) {
  if (!node) return 'null';
  switch (node.nodeType) {
    case 1:
      return `<${/** @type {Element} */ (node).tagName.toLowerCase()}>`;
    case 3:
      const text = (node.textContent || '').trim();
      return `#text \"${text.length > 30 ? text.slice(0, 27) + '...' : text}\"`;
    case 8:
      return `<!--${/** @type {Comment} */ (node).data}-->`;
    default:
      return node.nodeName;
  }
}

/**
 * Creates a renderer instance with platform-specific DOM manipulation methods.
 * @param {RendererOptions} options - The platform-specific renderer options.
 * @returns {Renderer<any>} A renderer object with `patch` and `hydrate` methods.
 */
export function createRenderer(options) {
  const {
    createElement: hostCreateElement,
    patchProp: hostPatchProp,
    insert: hostInsert,
    remove: hostRemove,
    setElementText: hostSetElementText,
    createText: hostCreateText,
    createComment: hostCreateComment,
    querySelector: hostQuerySelector,
  } = options;

  /** @type {Renderer<any>['patch']} */
  const patch = (n1, n2, container, anchor = null, parentComponent = null) => {
    if (n1 === n2) {
      return;
    }

    if (n1 && !n2) {
      unmount(n1);
      return;
    }

    if (n1 && n2 && (n1.type !== n2.type || n1.key !== n2.key)) {
      const anchor = n1.el?.nextSibling ?? null;
      unmount(n1);
      patch(null, n2, container, anchor, parentComponent);
      return;
    }

    if (!n2) {
      return;
    }

    const { type } = n2;
    switch (type) {
      case Text:
        logger.debug('Patching Text node.');
        n2.el = n1 ? n1.el : hostCreateText(/**@type {string}*/ (n2.children));
        if (n1) {
          if (n2.children !== n1.children) {
            /** @type {Node} */ (n2.el).textContent = String(n2.children);
          }
        } else {
          hostInsert(/**@type {Node}*/ (n2.el), container, anchor);
        }
        break;
      case Comment:
        logger.debug('Patching Comment node.');
        n2.el = n1
          ? n1.el
          : hostCreateComment(/**@type {string}*/ (n2.children));
        if (!n1) {
          hostInsert(/**@type {Node}*/ (n2.el), container, anchor);
        }
        break;
      case Fragment:
        logger.debug('Patching Fragment node.');
        if (!n1) {
          const childrenToPatch = Array.isArray(n2.children)
            ? n2.children
            : [n2.children];
          childrenToPatch.forEach((c) => {
            const childVnode =
              isString(c) || typeof c === 'number'
                ? createVnode(Text, null, c)
                : /** @type {import('../core/vdom.js').VNode} */ (c);
            patch(null, childVnode, container, anchor, parentComponent);
          });
        } else {
          patchChildren(n1, n2, container, anchor, parentComponent);
        }
        break;
      case Teleport:
        logger.debug('Patching Teleport node.');
        if (n2.props?.to) {
          const target = hostQuerySelector(n2.props.to);
          if (target) {
            patchChildren(n1, n2, target, null, parentComponent);
          }
        }
        break;
      case DynamicText:
        logger.debug('Patching Dynamic Text node.');
        const dummyN1 = { type: Fragment, children: n1?.children };
        const dummyN2 = { type: Fragment, children: n2.children };

        patchChildren(
          /** @type {import('../core/vdom.js').VNode} */ (dummyN1),
          /** @type {import('../core/vdom.js').VNode} */ (dummyN2),
          container,
          anchor,
          parentComponent,
        );
        break;
      default:
        if (isString(type)) {
          logger.debug(`Patching native element: <${type}>`);
          patchElement(n1, n2, container, anchor, parentComponent);
        } else if (isObject(type)) {
          logger.debug(
            `Patching component: <${
              /** @type {Component<any>} */ (type).name
            }>`,
          );
          if (!n1) {
            mountComponent(n2, container, anchor, parentComponent);
          } else {
            updateComponent(n1, n2);
          }
        }
    }
  };

  /**
   * @param {import('../core/vdom.js').VNode | null} n1
   * @param {import('../core/vdom.js').VNode} n2
   * @param {Element} container
   * @param {Node | null} anchor
   * @param {import('../core/component.js').ComponentInstance<any> | null} parentComponent
   */
  const patchElement = (n1, n2, container, anchor, parentComponent) => {
    const el = (n2.el = n1
      ? /** @type {Element} */ (n1.el)
      : hostCreateElement(/**@type {string}*/ (n2.type)));
    const oldProps = n1?.props || {};
    const newProps = n2.props || {};

    for (const key in newProps) {
      hostPatchProp(el, key, oldProps[key], newProps[key]);
    }
    for (const key in oldProps) {
      if (!(key in newProps)) {
        hostPatchProp(el, key, oldProps[key], null);
      }
    }

    patchChildren(n1, n2, el, anchor, parentComponent);
    if (!n1) {
      hostInsert(el, container, anchor);
    }
  };

  /**
   * @param {import('../core/vdom.js').VNode | null} n1
   * @param {import('../core/vdom.js').VNode} n2
   * @param {Element} container
   * @param {Node | null} anchor
   * @param {import('../core/component.js').ComponentInstance<any> | null} parentComponent
   */
  const patchChildren = (n1, n2, container, anchor, parentComponent) => {
    const c1 = n1?.children;
    const c2 = n2?.children;

    if (isString(c2)) {
      if (c1 && !isString(c1)) {
        unmountChildren(
          /** @type {import('../core/vdom.js').VNodeChildren} */ (c1),
        );
      }
      hostSetElementText(container, c2);
      return;
    }
    /** @param {any} c */
    const isSlotsObject = (c) =>
      isObject(c) && !('type' in c) && !Array.isArray(c);
    const oldChildren =
      c1 && !isSlotsObject(c1) ? (Array.isArray(c1) ? c1 : [c1]).flat() : [];
    const newChildren =
      c2 && !isSlotsObject(c2) ? (Array.isArray(c2) ? c2 : [c2]).flat() : [];

    if (newChildren.length === 0) {
      if (oldChildren.length > 0) {
        unmountChildren(
          /** @type {import('../core/vdom.js').VNodeChildren} */ (oldChildren),
        );
      }
      if (!isString(c1)) {
        hostSetElementText(container, '');
      }
      return;
    }

    if (oldChildren.length === 0) {
      newChildren.forEach((c) => {
        // @ts-ignore
        if (c && (c.type !== Text || c.children?.trim())) {
          patch(
            null,
            /** @type {import('../core/vdom.js').VNode} */ (c),
            container,
            anchor,
            parentComponent,
          );
        }
      });
      return;
    }

    const oldVNodes = /** @type {import('../core/vdom.js').VNode[]} */ (
      oldChildren.filter(isObject)
    );
    const newVNodes = /** @type {import('../core/vdom.js').VNode[]} */ (
      newChildren.filter(isObject)
    );

    if (newVNodes.some((child) => child.key != null)) {
      patchKeyedChildren(oldVNodes, newVNodes, container, parentComponent);
    } else {
      patchUnkeyedChildren(oldVNodes, newVNodes, container, parentComponent);
    }
  };

  /**
   * @param {import('../core/vdom.js').VNode[]} c1
   * @param {import('../core/vdom.js').VNode[]} c2
   * @param {Element} container
   * @param {import('../core/component.js').ComponentInstance<any> | null} parentComponent
   */
  const patchUnkeyedChildren = (c1, c2, container, parentComponent) => {
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);

    for (let i = 0; i < commonLength; i++) {
      const nextChild = c2[i];
      const oldChild = c1[i];
      if (nextChild && oldChild) {
        patch(oldChild, nextChild, container, null, parentComponent);
      }
    }
    if (newLength > oldLength) {
      for (let i = commonLength; i < newLength; i++) {
        const nextChild = c2[i];
        if (nextChild) {
          patch(null, nextChild, container, null, parentComponent);
        }
      }
    } else if (oldLength > newLength) {
      unmountChildren(c1.slice(commonLength));
    }
  };

  /**
   * @param {import('../core/vdom.js').VNode[]} c1
   * @param {import('../core/vdom.js').VNode[]} c2
   * @param {Element} container
   * @param {import('../core/component.js').ComponentInstance<any> | null} parentComponent
   */
  const patchKeyedChildren = (c1, c2, container, parentComponent) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;

    while (i <= e1 && i <= e2) {
      const p = c1[i];
      const n = c2[i];
      if (p && n && p.key === n.key) {
        patch(p, n, container, null, parentComponent);
        i++;
      } else {
        break;
      }
    }
    while (i <= e1 && i <= e2) {
      const p = c1[e1];
      const n = c2[e2];
      if (p && n && p.key === n.key) {
        patch(p, n, container, null, parentComponent);
        e1--;
        e2--;
      } else {
        break;
      }
    }

    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos]?.el : null;
        while (i <= e2) {
          const nextChild = c2[i++];
          if (nextChild)
            patch(null, nextChild, container, anchor, parentComponent);
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        const oldChild = c1[i++];
        if (oldChild) unmount(oldChild);
      }
    } else {
      const s1 = i,
        s2 = i;
      /** @type {Map<any, number>} */
      const keyToNewIndexMap = new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i];
        if (nextChild?.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      const toBePatched = e2 - s2 + 1;
      const newIndexToOldIndexMap = new Array(toBePatched).fill(0);
      let moved = false;
      let maxNewIndexSoFar = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (prevChild) {
          const newIndex = keyToNewIndexMap.get(prevChild.key);
          if (newIndex === undefined) {
            unmount(prevChild);
          } else {
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            const nextChild = c2[newIndex];
            if (nextChild)
              patch(prevChild, nextChild, container, null, parentComponent);
          }
        }
      }
      const increasingNewIndexSequence = moved
        ? getLongestIncreasingSubsequence(newIndexToOldIndexMap)
        : [];
      let j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1]?.el : null;
        if (newIndexToOldIndexMap[i] === 0) {
          if (nextChild)
            patch(null, nextChild, container, anchor, parentComponent);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            if (nextChild?.el) {
              hostInsert(nextChild.el, container, anchor);
            }
          } else {
            j--;
          }
        }
      }
    }
  };

  /**
   * @param {import('../core/vdom.js').VNode} vnode
   * @param {Element} container
   * @param {Node | null} anchor
   * @param {import('../core/component.js').ComponentInstance<any> | null} parentComponent
   * @param {boolean} [isHydrating=false]
   */
  const mountComponent = (
    vnode,
    container,
    anchor,
    parentComponent,
    isHydrating = false,
  ) => {
    const instance = (vnode.component = createComponent(
      vnode,
      parentComponent,
      false,
    ));

    const runner = effect(
      () => {
        pushInstance(instance);

        if (!instance.isMounted) {
          instance.hooks.onBeforeMount?.forEach((h) => h.call(instance.ctx));
          let subTree = instance.render
            ? instance.render.call(instance.ctx, instance.ctx)
            : null;

          if (!subTree) {
            subTree = createVnode(Comment, null, 'w-if');
          }
          instance.subTree = subTree;

          if (
            Object.keys(instance.attrs).length > 0 &&
            subTree.type !== Fragment &&
            subTree.props
          ) {
            subTree.props = mergeProps(subTree.props, instance.attrs);
          }

          if (isHydrating) {
            if (!vnode.el) {
              logger.warn(
                `Hydration failed for <${instance.type.name}>: no DOM element to hydrate against.`,
              );
            }
            const parentEl = vnode.el ? vnode.el.parentElement : null;
            if (!parentEl) {
              logger.warn(
                `Hydration failed for component <${instance.type.name}>: DOM node is detached.`,
              );
            }
            hydrateNode(subTree, vnode.el, parentEl, instance);
          } else {
            patch(null, subTree, container, anchor, instance);
          }

          vnode.el = subTree.el;
          if (subTree.type === Fragment) {
            /** @type {any[]} */
            const children = (
              Array.isArray(subTree.children)
                ? subTree.children
                : [subTree.children]
            )
              .flat()
              .filter(Boolean);
            for (let i = children.length - 1; i >= 0; i--) {
              const child = children[i];
              if (
                isObject(child) &&
                /** @type {import('../core/vdom.js').VNode} */ (child).el
              ) {
                instance.lastEl =
                  /** @type {import('../core/vdom.js').VNode} */ (child).el;
                break;
              }
            }
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (
                isObject(child) &&
                /** @type {import('../core/vdom.js').VNode} */ (child).el
              ) {
                vnode.el = /** @type {import('../core/vdom.js').VNode} */ (
                  child
                ).el;
                break;
              }
            }
          } else {
            instance.lastEl = subTree.el;
          }

          instance.isMounted = true;
          instance.hooks.onMounted?.forEach((h) => h.call(instance.ctx));

          if (devtools && devtools.__WEBS_DEVELOPER__) {
            devtools.__WEBS_DEVELOPER__.events.emit('component:added', {
              uid: instance.uid,
              parentId: instance.parent ? instance.parent.uid : null,
              name: instance.type.name || 'Anonymous',
              props: instance.props,
              state: instance.internalCtx,
            });
          }
        } else {
          instance.hooks.onBeforeUpdate?.forEach((h) => h.call(instance.ctx));
          const prevTree = instance.subTree;
          let nextTree = instance.render
            ? instance.render.call(instance.ctx, instance.ctx)
            : null;

          if (!nextTree) {
            nextTree = createVnode(Comment, null, 'w-if');
          }
          instance.subTree = nextTree;

          const newAttrs = instance.attrs;
          if (
            Object.keys(newAttrs).length > 0 &&
            nextTree.type !== Fragment &&
            nextTree.props
          ) {
            nextTree.props = mergeProps(nextTree.props, newAttrs);
          }

          let anchorNodeForParent = prevTree?.el;

          if (prevTree?.type === Fragment && prevTree.children) {
            const children = Array.isArray(prevTree.children)
              ? prevTree.children
              : [prevTree.children];
            if (children.length > 0 && isObject(children[0])) {
              anchorNodeForParent =
                /** @type {import('../core/vdom.js').VNode}*/ (children[0]).el;
            }
          }

          const parentContainer = anchorNodeForParent
            ? anchorNodeForParent.parentElement
            : null;

          if (parentContainer) {
            patch(prevTree, nextTree, parentContainer, null, instance);
            instance.vnode.el = nextTree.el;
            instance.hooks.onUpdated?.forEach((h) => h.call(instance.ctx));
            if (devtools && devtools.__WEBS_DEVELOPER__) {
              devtools.__WEBS_DEVELOPER__.events.emit('component:updated', {
                uid: instance.uid,
                props: instance.props,
                state: instance.internalCtx,
              });
            }
          }
        }

        popInstance();
      },
      undefined,
      {
        scheduler: () => {
          if (instance.update) instance.update();
        },
      },
    );
    instance.update = runner;
    instance.hooks.onReady?.forEach((h) => h.call(instance.ctx));
  };
  /**
   * @param {import('../core/vdom.js').Props} prevProps
   * @param {import('../core/vdom.js').Props} nextProps
   * @returns {boolean}
   */
  const hasPropsChanged = (prevProps, nextProps) => {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for (const key of nextKeys) {
      if (nextProps[key] !== prevProps[key]) return true;
    }
    return false;
  };

  /**
   * @param {import('../core/vdom.js').VNode} n1
   * @param {import('../core/vdom.js').VNode} n2
   * @returns {boolean}
   */
  const shouldUpdateComponent = (n1, n2) => {
    const { props: prevProps, children: prevChildren } = n1;
    const { props: nextProps, children: nextChildren } = n2;

    if (prevChildren || nextChildren) return true;
    if (prevProps === nextProps) return false;
    if (!prevProps) return !!nextProps;
    if (!nextProps) return true;

    return hasPropsChanged(prevProps, nextProps);
  };

  /**
   * @param {import('../core/vdom.js').VNode} n1
   * @param {import('../core/vdom.js').VNode} n2
   */
  const updateComponent = (n1, n2) => {
    const instance = (n2.component =
      /** @type {import('../core/component.js').ComponentInstance<any>} */ (
        n1.component
      ));

    if (!shouldUpdateComponent(n1, n2)) {
      n2.el = n1.el;
      instance.vnode = n2;
      return;
    }

    instance.vnode = n2;
    n2.el = n1.el;

    const { props: propsOptions } = instance.type;
    const vnodeProps = n2.props || {};
    const nextProps = {};
    const nextAttrs = {};

    for (const key in vnodeProps) {
      if (
        propsOptions &&
        Object.prototype.hasOwnProperty.call(propsOptions, key)
      ) {
        /** @type {any} */ (nextProps)[key] = vnodeProps[key];
      } else {
        /** @type {any} */ (nextAttrs)[key] = vnodeProps[key];
      }
    }

    instance.attrs = nextAttrs;
    instance.slots =
      /** @type {import('../core/vdom.js').Slots} */ (n2.children) || {};

    if (instance.hooks.onPropsReceived) {
      instance.hooks.onPropsReceived.forEach((h) =>
        h.call(instance.ctx, nextProps, instance.props),
      );
    }

    for (const key in nextProps) {
      instance.props[key] = /** @type {any} */ (nextProps)[key];
    }
    for (const key in instance.props) {
      if (!Object.prototype.hasOwnProperty.call(nextProps, key)) {
        delete instance.props[key];
      }
    }

    if (vnodeProps.initialState) {
      applyServerState(instance.internalCtx, vnodeProps.initialState);
    }

    if (instance.update) {
      instance.update();
    }
  };

  /** @param {import('../core/vdom.js').VNode | import('../core/vdom.js').VNodeChild} vnode */
  const unmount = (vnode) => {
    if (!vnode || !isObject(vnode)) return;

    if (vnode.component) {
      if (devtools && devtools.__WEBS_DEVELOPER__) {
        devtools.__WEBS_DEVELOPER__.events.emit('component:removed', {
          uid: vnode.component.uid,
        });
      }

      if (vnode.component.update) {
        /** @type {any} */ (vnode.component.update).effect?.stop();
      }
      vnode.component.hooks.onUnmounted?.forEach(
        /** @type {any} */ (h) => h.call(vnode.component?.ctx),
      );
      unmount(vnode.component.subTree);
      return;
    }
    if (vnode.type === Fragment || vnode.type === Teleport) {
      if (vnode.children) {
        unmountChildren(
          /** @type {import('../core/vdom.js').VNodeChildren} */ (
            vnode.children
          ),
        );
      }
      return;
    }
    if (vnode.el) {
      hostRemove(vnode.el);
    }
  };

  /** @param {import('../core/vdom.js').VNodeChildren} children */
  const unmountChildren = (children) => {
    const childrenToUnmount = (
      Array.isArray(children) ? children : [children]
    ).filter(Boolean);
    childrenToUnmount.forEach(unmount);
  };

  /** @type {Renderer<any>['hydrate']} */
  const hydrate = (vnode, container) => {
    if (!container.firstChild) {
      patch(null, vnode, container);
      return vnode.component;
    }
    const rootDomNode = skipNonEssentialNodes(container.firstChild);
    if (!rootDomNode) {
      patch(null, vnode, container);
      return vnode.component;
    }

    hydrateNode(vnode, rootDomNode, container, null);
    return vnode.component;
  };

  /**
   * @param {Node | null} node
   * @returns {Node | null}
   */
  const skipNonEssentialNodes = (node) => {
    let currentNode = node;
    while (
      currentNode &&
      (currentNode.nodeType === 8 ||
        (currentNode.nodeType === 3 &&
          (currentNode.textContent || '').trim() === ''))
    ) {
      currentNode = currentNode.nextSibling;
    }
    return currentNode;
  };

  /**
   * @param {import('../core/vdom.js').VNode} vnode
   * @param {Node | null} domNode
   * @param {Element | null} parentDom
   * @param {import('../core/component.js').ComponentInstance<any> | null} parentComponent
   * @returns {Node | null}
   */
  const hydrateNode = (vnode, domNode, parentDom, parentComponent = null) => {
    if (!vnode) {
      return domNode;
    }

    if (isObject(vnode.type)) {
      vnode.el = domNode;
      if (parentDom) {
        mountComponent(vnode, parentDom, domNode, parentComponent, true);
      }
      const lastNode = vnode.component?.lastEl;
      return lastNode ? lastNode.nextSibling : domNode;
    }

    if (vnode.type === Fragment) {
      const nextDomNode = hydrateChildren(
        /** @type {import('../core/vdom.js').VNodeChildren} */ (vnode.children),
        /** @type {Element} */ (parentDom),
        domNode,
        parentComponent,
      );
      /** @type {any[]} */
      const childVnodes = (
        Array.isArray(vnode.children) ? vnode.children : [vnode.children]
      )
        .flat()
        .filter(Boolean);

      const firstChildVnode = childVnodes.find(
        (c) =>
          isObject(c) && /**@type {import('../core/vdom.js').VNode}*/ (c).el,
      );

      if (isObject(firstChildVnode)) {
        vnode.el = /**@type {import('../core/vdom.js').VNode}*/ (
          firstChildVnode
        ).el;
      }
      return nextDomNode;
    }

    let currentDomNode = skipNonEssentialNodes(/**@type {Node}*/ (domNode));

    if (!currentDomNode || !parentDom) {
      if (parentDom) {
        patch(null, vnode, parentDom, null, parentComponent);
      }
      return null;
    }

    const { type, props, children } = vnode;

    /**
     * @param {string} expected
     * @param {string} found
     * @param {import('../core/vdom.js').VNode} vnodeDetails
     * @returns {Node | null}
     */
    const handleMismatch = (expected, found, vnodeDetails) => {
      logger.error(
        `[Hydration Mismatch] Expected ${expected}, but found ${found}.`,
        vnodeDetails,
      );
      if (process.env.NODE_ENV !== 'production') {
        patch(null, vnode, parentDom, currentDomNode, parentComponent);
        if (currentDomNode) hostRemove(currentDomNode);
        return vnode.el ? vnode.el.nextSibling : null;
      } else {
        return currentDomNode?.nextSibling ?? null;
      }
    };

    if (type === Text && props && props['w-dynamic']) {
      if (
        currentDomNode &&
        currentDomNode.nodeType === 8 &&
        /**@type {Comment}*/ (currentDomNode).data === '['
      ) {
        const textNode = currentDomNode.nextSibling;
        const closingComment = textNode ? textNode.nextSibling : null;

        if (
          closingComment &&
          closingComment.nodeType === 8 &&
          /**@type {Comment}*/ (closingComment).data === ']'
        ) {
          vnode.el = textNode;
          return closingComment.nextSibling;
        } else {
          return handleMismatch(
            "closing comment '<!--]-->'",
            getNodeDescription(closingComment),
            vnode,
          );
        }
      }
    }

    vnode.el = currentDomNode;

    switch (type) {
      case Text:
        if (!currentDomNode || currentDomNode.nodeType !== 3) {
          return handleMismatch(
            'a text node',
            getNodeDescription(currentDomNode),
            /** @type {import('../core/vdom.js').VNode} */ ({
              expectedContent: vnode.children,
              ...vnode,
            }),
          );
        } else if (
          String(currentDomNode.textContent) !== String(vnode.children)
        ) {
          if (process.env.NODE_ENV !== 'production') {
            currentDomNode.textContent = String(vnode.children);
          }
        }
        return currentDomNode.nextSibling;

      case Comment:
        if (!currentDomNode || currentDomNode.nodeType !== 8) {
          return handleMismatch(
            'a comment node',
            getNodeDescription(currentDomNode),
            vnode,
          );
        }
        return currentDomNode.nextSibling;
      case Teleport:
        if (props && props.to) {
          return hydrateChildren(
            /** @type {import('../core/vdom.js').VNodeChildren} */ (children),
            hostQuerySelector(props.to),
            null,
            parentComponent,
          );
        }
        return currentDomNode.nextSibling;
      default:
        if (isString(type)) {
          const vnodeTagName = type.toLowerCase();
          const domTagName = /** @type {Element} */ (
            currentDomNode
          )?.tagName?.toLowerCase();

          if (
            !currentDomNode ||
            currentDomNode.nodeType !== 1 ||
            domTagName !== vnodeTagName
          ) {
            return handleMismatch(
              `element <${type}>`,
              getNodeDescription(currentDomNode),
              vnode,
            );
          }
          if (props) {
            for (const key in props) {
              hostPatchProp(
                /**@type {Element}*/ (currentDomNode),
                key,
                null,
                props[key],
              );
            }
          }
          hydrateChildren(
            /** @type {import('../core/vdom.js').VNodeChildren} */ (children),
            /**@type {Element}*/ (currentDomNode),
            currentDomNode.firstChild,
            parentComponent,
          );
          return currentDomNode.nextSibling;
        }
    }
    return currentDomNode ? currentDomNode.nextSibling : null;
  };

  /**
   * @param {import('../core/vdom.js').VNodeChildren} children
   * @param {Element | null} parentDom
   * @param {Node | null} startNode
   * @param {import('../core/component.js').ComponentInstance<any> | null} parentComponent
   * @returns {Node | null}
   */
  const hydrateChildren = (
    children,
    parentDom,
    startNode,
    parentComponent = null,
  ) => {
    let nextDomNode = startNode;
    if (!children || !parentDom) {
      return nextDomNode;
    }

    const childVnodes = (
      Array.isArray(children) ? children : [children]
    ).flat();

    for (const childVnode of childVnodes) {
      if (!childVnode) continue;
      nextDomNode = hydrateNode(
        /** @type {import('../core/vdom.js').VNode} */ (childVnode),
        nextDomNode,
        parentDom,
        parentComponent,
      );
    }
    return nextDomNode;
  };

  return { patch, hydrate };
}

/**
 * @internal
 * @param {number[]} arr
 * @returns {number[]}
 */
function getLongestIncreasingSubsequence(arr) {
  if (arr.length === 0) return [];
  /** @type {(number | undefined)[]} */
  const p = new Array(arr.length);
  const result = [0];
  let i, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0 && arrI != null) {
      const j = result[result.length - 1];
      if (j !== undefined) {
        const arrJ = arr[j];
        if (arrJ != null && arrJ < arrI) {
          p[i] = j;
          result.push(i);
          continue;
        }
      }

      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = (u + v) >> 1;
        const resultC = result[c];
        if (resultC !== undefined) {
          const arrResultC = arr[resultC];
          if (arrResultC != null && arrResultC < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
      }
      const resultU = result[u];
      if (resultU !== undefined) {
        const arrResultU = arr[resultU];
        if (arrResultU && arrI != null && arrI < arrI) {
          if (u > 0) {
            const prevResult = result[u - 1];
            if (prevResult !== undefined) p[i] = prevResult;
          }
          result[u] = i;
        }
      }
    }
  }
  u = result.length;
  let v_ = result[u - 1];
  if (v_ === undefined) return [];

  /** @type {number} */
  let currentV = v_;

  while (u-- > 0) {
    result[u] = currentV;
    const p_v_ = p[currentV];
    if (p_v_ === undefined) break;
    currentV = p_v_;
  }
  return result;
}

---------- END: renderer/renderer.js ----------

---------- START: renderer/ssr.js ----------
/**
 * @file Type definitions for Server-Side Rendering (SSR) functionality.
 * @typedef {import('../core/vdom.js').VNodeChild} VNodeChild
 * @typedef {import('../core/vdom.js').VNodeChildren} VNodeChildren
 * @typedef {import('../core/vdom.js').Slots} Slots
 * @typedef {import('../core/vdom.js').Props} Props
 * @typedef {import('../core/component.js').ComponentInstance<any>} ComponentInstance
 */

/**
 * @typedef {object} RenderResult
 * @property {string} html - The rendered HTML string.
 * @property {object} componentState - The initial state of the components.
 */

/**
 * @typedef {object} SsrContext
 * @property {object} componentState - An object to hold the component state.
 */

/**
 * @file Handles Server-Side Rendering (SSR) of VNodes to an HTML string.
 */

import { isObject, isString, isFunction } from '../utils/lang.js';
import { createLogger } from '../developer/logger.js';
import { normalizeClass, voidElements } from '../utils/dom.js';
import { createComponent, mergeProps } from '../core/component.js';
import { isRef } from '../core/reactivity.js';
import { Text, Comment, Fragment, Teleport, VNode } from '../core/vdom.js';

const logger = createLogger('[SSR]');

/**
 * @internal
 * @param {any} obj
 * @returns {any}
 */
function unwrapRefs(obj) {
  if (!obj || typeof obj !== 'object') return obj;
  /** @type {Record<string, any>} */
  const res = {};
  for (const key in obj) {
    const val = /** @type {any} */ (obj)[key];
    if (isRef(val)) {
      res[key] = unwrapRefs(val.value);
    } else if (Array.isArray(val)) {
      res[key] = val.map(unwrapRefs);
    } else if (
      typeof val === 'object' &&
      val !== null &&
      !(val instanceof Set) &&
      !(val instanceof Map)
    ) {
      res[key] = unwrapRefs(val);
    } else {
      res[key] = val;
    }
  }
  return res;
}

/**
 * Renders a VNode to an HTML string on the server.
 * @param {VNode} vnode The root VNode to render.
 * @returns {Promise<RenderResult>} An object containing the rendered HTML and the initial state.
 */
export async function renderToString(vnode) {
  try {
    /** @type {SsrContext} */
    const context = { componentState: {} };
    const html = await renderVnode(vnode, null, context);
    const unwrappedState = unwrapRefs(context.componentState);

    if (unwrappedState && /** @type {any} */ (unwrappedState).session) {
      delete (/** @type {any} */ (unwrappedState).session);
    }

    return { html, componentState: unwrappedState };
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    logger.error('SSR rendering error:', e);
    const html = `<div style=\"color:red; background:lightyellow; border: 1px solid red; padding: 1rem;\">SSR Error: ${escapeHtml(
      message,
    )}</div>`;
    return { html, componentState: {} };
  }
}

/**
 * @internal
 * @param {VNodeChild} vnode
 * @param {ComponentInstance | null} parentComponent
 * @param {SsrContext} context
 * @returns {Promise<string>}
 */
async function renderVnode(vnode, parentComponent, context) {
  if (vnode == null) return '';
  if (isString(vnode) || typeof vnode === 'number') {
    return escapeHtml(String(vnode));
  }
  if (!isObject(vnode) || !(vnode instanceof VNode)) {
    return `<!-- invalid vnode detected -->`;
  }

  const { type, props, children } = vnode;

  switch (type) {
    case Text:
      const content = children != null ? escapeHtml(String(children)) : '';
      return props && props['w-dynamic']
        ? `<!--[-->${content}<!--]-->`
        : content;
    case Comment:
      return `<!--${children != null ? escapeHtml(String(children)) : ''}-->`;
    case Fragment:
    case Teleport:
      if (
        isObject(children) &&
        !Array.isArray(children) &&
        !('type' in children)
      ) {
        const slots = /** @type {Slots} */ (children);
        if (slots.default) {
          const defaultContent = slots.default();
          const childArray = (
            Array.isArray(defaultContent) ? defaultContent : [defaultContent]
          ).flat();
          let result = '';
          for (const child of childArray) {
            result += await renderVnode(
              /** @type{VNodeChild} */ (child),
              parentComponent,
              context,
            );
          }
          return result;
        }
        return '';
      }
      return await renderChildren(
        /** @type {VNodeChildren | Slots} */ (children),
        parentComponent,
        context,
      );
    default:
      if (isString(type)) {
        const tag = type.toLowerCase();
        let html = `<${tag}${renderProps(props)}>`;
        if (!voidElements.has(tag)) {
          html += await renderChildren(children, parentComponent, context);
          html += `</${tag}>`;
        }
        return html;
      } else if (isObject(type)) {
        const instance = createComponent(vnode, parentComponent, true);

        if (parentComponent) {
          instance.appContext.components = {
            ...(parentComponent.appContext.components || {}),
            ...(parentComponent.type.components || {}),
            ...(instance.type.components || {}),
          };
        }

        let subTree = instance.render
          ? instance.render.call(instance.ctx, instance.ctx)
          : null;

        if (!subTree) {
          return `<!--w-if-->`;
        }

        if (
          Object.keys(instance.attrs).length > 0 &&
          subTree.type !== Fragment &&
          subTree.props
        ) {
          subTree.props = mergeProps(subTree.props, instance.attrs);
        }
        if (!parentComponent && context) {
          context.componentState = instance.internalCtx;
        }
        if (isFunction(instance.render)) {
          return await renderVnode(subTree, instance, context);
        }
        return `<!-- component failed to render -->`;
      }
      return `<!-- invalid vnode type -->`;
  }
}

/**
 * @internal
 * @param {VNodeChildren | Slots} children
 * @param {ComponentInstance | null} parentComponent
 * @param {SsrContext} context
 * @returns {Promise<string>}
 */
async function renderChildren(children, parentComponent, context) {
  if (!children) return '';
  const childArray = (Array.isArray(children) ? children : [children]).flat();
  let result = '';
  for (const child of childArray) {
    result += await renderVnode(
      /** @type{VNodeChild} */ (child),
      parentComponent,
      context,
    );
  }
  return result;
}

/**
 * @internal
 * @param {Props | null} props
 * @returns {string}
 */
function renderProps(props) {
  if (!props) return '';
  let result = '';
  for (const key in props) {
    if (key === 'key' || key.startsWith('on') || key === 'w-dynamic') continue;
    const value = props[key];
    if (key === 'class') {
      const classValue = normalizeClass(value);
      if (classValue) {
        result += ` class=\"${escapeHtml(classValue)}\"`;
      }
    } else if (key === 'style') {
      const styleString = isObject(value)
        ? Object.entries(value)
            .map(
              ([k, v]) => `${k.replace(/([A-Z])/g, '-$1').toLowerCase()}:${v}`,
            )
            .join(';')
        : String(value);
      if (styleString) {
        result += ` style=\"${escapeHtml(styleString)}\"`;
      }
    } else if (typeof value === 'boolean') {
      if (value) result += ` ${key}`;
    } else if (value != null) {
      result += ` ${key}=\"${escapeHtml(String(value))}\"`;
    }
  }
  return result;
}

/**
 * @internal
 * @param {any} str
 * @returns {string}
 */
function escapeHtml(str) {
  if (str == null) return '';
  return String(str).replace(/[&<>\"']/g, (match) => {
    switch (match) {
      case '&':
        return '&amp;';
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '\"':
        return '&quot;';
      case "'":
        return '&#039;';
      default:
        return match;
    }
  });
}

---------- END: renderer/ssr.js ----------

---------- START: renderer/compiler.js ----------
/**
 * @file Type definitions for the compiler.
 */

/** @typedef {import('../core/vdom.js').VNode} VNode */
/** @typedef {import('./renderer.js').Component<any>} Component */
/** @typedef {import('./expression-evaluator.js').AstNode} JsAstNode */
/** @typedef {import('./template-parser.js').HtmlAstNode} HtmlAstNode */
/** @typedef {import('./template-parser.js').ElementNode} ElementNode */
/** @typedef {import('./template-parser.js').AttributeToken} AttributeToken */

/**
 * @typedef {object} ComponentOptions
 * @property {Record<string, Component>} [globalComponents]
 */

/**
 * @typedef {Window & { __WEBS_DEVELOPER__?: { events: { emit: (event: string, data: any) => void; } } }} DevtoolsWindow
 */

/**
 * Enum for intermediate AST node types used by the compiler.
 * @enum {number}
 */
export const NODE_TYPES = {
  ROOT: 0,
  ELEMENT: 1,
  COMPONENT: 2,
  TEXT: 3,
  INTERPOLATION: 4,
  COMMENT: 5,
  FRAGMENT: 6,
  IF: 7,
  FOR: 8,
  SLOT: 9,
  DYNAMIC_TEXT: 10,
};

/**
 * Enum for intermediate AST attribute types used by the compiler.
 * @enum {number}
 */
export const ATTR_TYPES = {
  STATIC: 10,
  DIRECTIVE: 11,
  EVENT_HANDLER: 12,
};

/**
 * @file Compiles component templates into optimized render functions.
 */

import { parseHtml } from './template-parser.js';
import { parseJs, tokenizeJs } from './expression-evaluator.js';
import * as VDOM from '../core/vdom.js';
import { createLogger } from '../developer/logger.js';

/** @typedef {import('./expression-evaluator.js').JsToken} JsToken */
/** @typedef {import('./expression-evaluator.js').LiteralNode} LiteralNode */
/** @typedef {import('./expression-evaluator.js').IdentifierNode} IdentifierNode */
/** @typedef {import('./expression-evaluator.js').TemplateLiteralNode} TemplateLiteralNode */
/** @typedef {import('./expression-evaluator.js').ObjectExpressionNode} ObjectExpressionNode */
/** @typedef {import('./expression-evaluator.js').ArrayExpressionNode} ArrayExpressionNode */
/** @typedef {import('./expression-evaluator.js').BinaryExpressionNode} BinaryExpressionNode */
/** @typedef {import('./expression-evaluator.js').UnaryExpressionNode} UnaryExpressionNode */
/** @typedef {import('./expression-evaluator.js').MemberExpressionNode} MemberExpressionNode */
/** @typedef {import('./expression-evaluator.js').ComputedMemberExpressionNode} ComputedMemberExpressionNode */
/** @typedef {import('./expression-evaluator.js').CallExpressionNode} CallExpressionNode */
/** @typedef {import('./expression-evaluator.js').ConditionalExpressionNode} ConditionalExpressionNode */
/** @typedef {import('./expression-evaluator.js').AssignmentExpressionNode} AssignmentExpressionNode */
/** @typedef {import('./expression-evaluator.js').ArrowFunctionExpressionNode} ArrowFunctionExpressionNode */
/** @typedef {import('./template-parser.js').IfBlockNode} IfBlockNode */
/** @typedef {import('./template-parser.js').ElseIfBlockNode} ElseIfBlockNode */
/** @typedef {import('./template-parser.js').EachBlockNode} EachBlockNode */
/** @typedef {import('./template-parser.js').TextNode} TextNode */
/** @typedef {import('./template-parser.js').CommentNode} CommentNode */

/**
 * @internal
 * @type {DevtoolsWindow}
 */
const devtools =
  typeof window !== 'undefined' ? window : /** @type {DevtoolsWindow} */ ({});

const logger = createLogger('[Compiler]');

/**
 * @internal
 * Caches the result of a function that takes a string argument.
 * @param {(str: string) => string} fn The function to memoize.
 * @returns {(str: string) => string} The memoized function.
 */
const cacheStringFunction = (fn) => {
  const cache = Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

/**
 * @internal
 * Converts kebab-case to camelCase.
 * @type {(str: string) => string}
 */
const camelize = cacheStringFunction((str) => {
  /**
   * @param {string} _
   * @param {string} character
   */
  return str.replace(/-(\w)/g, (_, character) =>
    character ? character.toUpperCase() : '',
  );
});

/**
 * @internal
 * Generates the body of a render function from a transformed AST.
 * @param {any} ast The transformed Abstract Syntax Tree of the template.
 * @returns {{ fn: (_ctx: object) => VNode | null, source: string }} The generated render function and its source code.
 */
export function generateRenderFn(ast) {
  const ctx = {
    /** @type {Set<string>} */
    scope: new Set(),
    /** @param {JsAstNode | null} expr
     * @returns {string}
     */
    genExpr(expr) {
      if (!expr) return 'null';
      switch (expr.type) {
        case 'Identifier':
          return this.scope.has(/** @type {IdentifierNode} */ (expr).name)
            ? /** @type {IdentifierNode} */ (expr).name
            : `_ctx.${/** @type {IdentifierNode} */ (expr).name}`;
        case 'Literal':
          return JSON.stringify(/** @type {LiteralNode} */ (expr).value);
        case 'TemplateLiteral': {
          let code = '`';
          let i = 0;
          const templateNode = /** @type {TemplateLiteralNode} */ (expr);
          for (const quasi of templateNode.quasis) {
            code += quasi.value.raw.replace(/`/g, '\\`');
            if (!quasi.tail) {
              const expression = templateNode.expressions[i++];
              if (expression) {
                code += `\${${this.genExpr(expression)}}`;
              }
            }
          }
          code += '`';
          return code;
        }
        case 'ObjectExpression': {
          const props = /** @type {ObjectExpressionNode} */ (expr).properties
            .map((p) => {
              const key =
                p.key.type === 'Identifier'
                  ? `'${/** @type {IdentifierNode} */ (p.key).name}'`
                  : this.genExpr(p.key);
              const value = this.genExpr(p.value);
              return `${key}: ${value}`;
            })
            .join(',');
          return `{${props}}`;
        }
        case 'ArrayExpression': {
          return `[${
            /** @type {ArrayExpressionNode} */ (expr).elements
              .map((e) => this.genExpr(e))
              .join(',')
          }]`;
        }
        case 'BinaryExpression':
          const binaryNode = /** @type {BinaryExpressionNode} */ (expr);
          return `(${this.genExpr(binaryNode.left)} ${
            binaryNode.operator
          } ${this.genExpr(binaryNode.right)})`;
        case 'UnaryExpression':
          const unaryNode = /** @type {UnaryExpressionNode} */ (expr);
          return `${unaryNode.operator}${this.genExpr(unaryNode.argument)}`;
        case 'MemberExpression': {
          const memberNode = /** @type {MemberExpressionNode} */ (expr);
          const objectExpr = this.genExpr(memberNode.object);
          const propertyName = memberNode.property.name;
          return `(${objectExpr}?.${propertyName})`;
        }
        case 'ComputedMemberExpression':
          const computedNode = /** @type {ComputedMemberExpressionNode} */ (
            expr
          );
          return `${this.genExpr(computedNode.object)}[${this.genExpr(
            computedNode.property,
          )}]`;
        case 'CallExpression':
          const callNode = /** @type {CallExpressionNode} */ (expr);
          return `${this.genExpr(callNode.callee)}(${callNode.arguments
            .map((a) => this.genExpr(a))
            .join(',')})`;
        case 'ConditionalExpression':
          const conditionalNode = /** @type {ConditionalExpressionNode} */ (
            expr
          );
          return `(${this.genExpr(conditionalNode.test)} ? ${this.genExpr(
            conditionalNode.consequent,
          )} : ${this.genExpr(conditionalNode.alternate)})`;
        case 'AssignmentExpression':
          const assignmentNode = /** @type {AssignmentExpressionNode} */ (expr);
          return `(${this.genExpr(assignmentNode.left)} = ${this.genExpr(
            assignmentNode.right,
          )})`;
        default:
          return 'null';
      }
    },
    /** @param {any[]} props
     * @returns {string}
     */
    genProps(props) {
      /** @param {any} p */
      const genProp = (p) => {
        if (p.type === ATTR_TYPES.STATIC) {
          return `'${p.name}': ${JSON.stringify(p.value)}`;
        }
        if (p.type === ATTR_TYPES.DIRECTIVE)
          return `'${p.name}': ${this.genExpr(p.expression)}`;
        if (p.type === ATTR_TYPES.EVENT_HANDLER) {
          this.scope.add('$event');
          const exprCode = this.genExpr(p.expression);
          this.scope.delete('$event');

          let handlerBody = exprCode;
          if (p.expression && p.expression.type === 'Identifier') {
            handlerBody = `${exprCode}($event)`;
          }
          if (p.modifiers && p.modifiers.has('prevent')) {
            handlerBody = `$event.preventDefault(); ${handlerBody}`;
          }
          if (p.modifiers && p.modifiers.has('stop')) {
            handlerBody = `$event.stopPropagation(); ${handlerBody}`;
          }

          return `'${p.name}': ($event) => { ${handlerBody} }`;
        }
        return '';
      };
      return `{${props
        .map((p) => p && genProp(p))
        .filter(Boolean)
        .join(',')}}`;
    },
    /** @param {Record<string, any[]>} slots
     * @returns {string}
     */
    genSlots(slots) {
      const slotEntries = Object.entries(slots).map(([name, children]) => {
        return `'${name}': () => ${this.genChildren(children)}`;
      });
      return `{ ${slotEntries.join(', ')} }`;
    },
    /** @param {any[] | any} children
     * @returns {string}
     */
    genChildren(children) {
      if (!children || (Array.isArray(children) && children.length === 0)) {
        return '[]';
      }
      const childNodes = (Array.isArray(children) ? children : [children])
        .map((/** @type {HtmlAstNode} */ c) => this.genNode(c))
        .filter((c) => c && c !== 'null');

      if (childNodes.length === 0) return '[]';
      return `[${childNodes.join(',')}]`;
    },
    /** @param {any} node
     * @returns {string}
     */
    genNode(node) {
      if (!node) return 'null';

      switch (node.type) {
        case NODE_TYPES.ROOT: {
          const childrenCode = this.genChildren(node.children);
          if (!node.children || node.children.length === 0) return 'null';
          if (node.children.length === 1) {
            return this.genNode(node.children[0]);
          }
          return `_h(_Fragment, {}, ${childrenCode})`;
        }
        case NODE_TYPES.FRAGMENT:
          const fragmentChildren = (
            Array.isArray(node.children) ? node.children : [node.children]
          )
            .map((/** @type {HtmlAstNode} */ c) => this.genNode(c))
            .filter(Boolean);
          if (fragmentChildren.length === 0) return 'null';
          if (fragmentChildren.length === 1) return fragmentChildren[0];
          return `_h(_Fragment, {}, [${fragmentChildren.join(',')}])`;
        case NODE_TYPES.COMPONENT: {
          const slots = this.genSlots(node.slots);
          let componentAccess;
          if (node.isDynamic) {
            const dynamicNameExpr = this.genExpr(node.tagName);
            componentAccess = `_ctx[${dynamicNameExpr}]`;
          } else {
            componentAccess = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(node.tagName)
              ? `_ctx.${node.tagName}`
              : `_ctx['${node.tagName}']`;
          }

          return `_h(${componentAccess}, ${this.genProps(
            node.properties,
          )}, ${slots})`;
        }
        case NODE_TYPES.ELEMENT: {
          let props = this.genProps(node.properties);
          if (node.key) {
            const keyExpr = this.genExpr(node.key);
            if (props.length > 2) {
              props = `{ 'key': ${keyExpr}, ${props.slice(1, -1)} }`;
            } else {
              props = `{ 'key': ${keyExpr} }`;
            }
          }
          return `_h('${node.tagName}', ${props}, ${this.genChildren(
            node.children,
          )})`;
        }
        case NODE_TYPES.TEXT:
          return `_h(_Text, {}, ${JSON.stringify(node.value)})`;
        case NODE_TYPES.INTERPOLATION:
          return `_h(_Text, { 'w-dynamic': true }, String(${this.genExpr(
            node.expression,
          )}))`;
        case NODE_TYPES.COMMENT:
          return `_h(_Comment, {}, ${JSON.stringify(node.value)})`;
        case NODE_TYPES.SLOT: {
          const slotName = node.name || 'default';
          const fallbackContent = this.genChildren(node.children);
          const slotOutlet = `(_ctx.$slots && typeof _ctx.$slots['${slotName}'] === 'function' && _ctx.$slots['${slotName}']())`;
          const normalizedSlots = `(Array.isArray(${slotOutlet}) ? ${slotOutlet} : (${slotOutlet} ? [${slotOutlet}] : null))`;
          const finalChildren = `${normalizedSlots} || ${fallbackContent}`;

          return `_h(_Fragment, {}, ...(${finalChildren} || []))`;
        }
        case NODE_TYPES.IF: {
          /**
           * @param {any} branch
           * @param {number} index
           * @returns {string}
           */
          const genBranch = (branch, index) => {
            if (!branch) return 'null';
            const alternate = node.branches[index + 1]
              ? genBranch(node.branches[index + 1], index + 1)
              : 'null';
            return `(${this.genExpr(
              branch.condition,
            )}) ? ${this.genNode(branch.node)} : ${alternate}`;
          };
          return genBranch(node.branches[0], 0);
        }
        case NODE_TYPES.FOR: {
          const { source, value, key, keyName } = node;
          const params = key ? `(${value}, ${key})` : value;
          this.scope.add(value);
          if (key) this.scope.add(key);

          const childNode = this.genNode(node.children[0]);

          let childCode = childNode;
          if (keyName) {
            childCode = `(() => {
                const child = ${childNode};
                if (child && child.props) child.props.key = ${this.genExpr(
                  keyName,
                )};
                return child;
            })()`;
          }

          this.scope.delete(value);
          if (key) this.scope.delete(key);
          return `_h(_Fragment, {}, (${this.genExpr(
            source,
          )} || []).map(${params} => ${childCode}))`;
        }
        case NODE_TYPES.DYNAMIC_TEXT: {
          const childrenCode = this.genChildren(node.children);
          return `_h(_DynamicText, {}, ${childrenCode})`;
        }
      }
      return 'null';
    },
  };
  const functionBody = `
const { h: _h, Text: _Text, Fragment: _Fragment, Comment: _Comment, DynamicText: _DynamicText } = VDOM;
return ${ctx.genNode(ast) || 'null'};
`;
  try {
    logger.debug('Generated render function source:', functionBody);
    /** @type {(_ctx: object) => VNode | null} */
    const fn = new Function('VDOM', '_ctx', functionBody).bind(null, VDOM);
    return { fn, source: functionBody };
  } catch (e) {
    logger.error('Render function compilation error', e, functionBody);
    /** @type {() => VNode} */
    const errorFn = () =>
      VDOM.h(VDOM.Comment, {}, 'Render function compile error');
    return {
      fn: errorFn,
      source: `return VDOM.h(VDOM.Comment, {}, 'Render function compile error');`,
    };
  }
}

/** @type {Map<string, JsAstNode | null>} */
const parseExprCache = new Map();

export class Compiler {
  /**
   * @param {Component} componentDef
   * @param {ComponentOptions | null} options
   */
  constructor(componentDef, options = null) {
    this.definition = componentDef;
    /** @type {Map<string, string>} */
    this.componentNameMap = new Map();
    const allComponents = {
      ...(componentDef.components || {}),
      ...(options?.globalComponents || {}),
    };

    /** @param {Record<string, Component> | undefined} comps */
    const collectComponents = (comps) => {
      if (!comps) return;
      for (const key in comps) {
        const compDef = comps[key];
        if (compDef && typeof compDef === 'object') {
          this.componentNameMap.set(key.toLowerCase(), key);
          if (compDef.components) {
            collectComponents(compDef.components);
          }
        }
      }
    };

    collectComponents(allComponents);
    this.options = options;
  }

  /** @param {string} html */
  parseHtml(html) {
    logger.debug('Parsing HTML template:', html);
    const ast = parseHtml(html);
    logger.debug('Parsed HTML AST:', JSON.stringify(ast, null, 2));
    return ast;
  }

  compile() {
    logger.info(`Starting compilation for component: ${this.definition.name}`);
    const rawAst = this.parseHtml(
      /** @type {string} */ (this.definition.template),
    );
    const transformedAst = this._transformNode(rawAst);
    logger.debug('Transformed AST:', JSON.stringify(transformedAst, null, 2));
    const { fn, source } = generateRenderFn(transformedAst);
    logger.info('Compilation finished.');

    devtools?.__WEBS_DEVELOPER__?.events.emit('component:compiled', {
      name: this.definition.name,
      template: this.definition.template,
      source: source,
    });

    return fn;
  }

  /**
   * @param {string | null | undefined} str
   * @returns {JsAstNode | null}
   */
  _parseExpr(str) {
    if (str === null || str === undefined) return null;
    const cleanStr = String(str).replace(/\n/g, ' ').trim();
    if (!cleanStr) return null;
    if (parseExprCache.has(cleanStr)) {
      return parseExprCache.get(cleanStr) || null;
    }

    try {
      const ast = parseJs(tokenizeJs(cleanStr));
      parseExprCache.set(cleanStr, ast);
      return ast;
    } catch (e) {
      logger.error(`Expression parsing error for: \"${cleanStr}\"`, e);
      return null;
    }
  }

  /**
   * @param {HtmlAstNode[]} children
   * @returns {Record<string, any>}
   */
  _processSlots(children) {
    /** @type {Record<string, any>} */
    const slots = {};
    const defaultChildren = [];

    for (const child of children) {
      if (
        child.type === 'element' &&
        /** @type {ElementNode} */ (child).tagName === 'template'
      ) {
        const slotAttr = /** @type {ElementNode} */ (child).attributes.find(
          (/**@type {{name: string}}*/ a) => a.name.startsWith('#'),
        );
        if (slotAttr) {
          const slotName = slotAttr.name.substring(1) || 'default';
          slots[slotName] = this._transformChildren(child.children || []);
          continue;
        }
      }
      if (
        child.type === 'text' &&
        !(/** @type {TextNode} */ (child).content.trim())
      ) {
        continue;
      }
      defaultChildren.push(child);
    }

    if (defaultChildren.length > 0) {
      slots.default = this._transformChildren(defaultChildren);
    }

    return slots;
  }
  /**
   * @param {HtmlAstNode} node
   * @returns {any}
   */
  _transformNode(node) {
    switch (node.type) {
      case 'root':
        return {
          type: NODE_TYPES.ROOT,
          children: this._transformChildren(node.children || []),
        };
      case 'element':
        return this._transformElement(/** @type {ElementNode} */ (node));
      case 'text':
        return this._transformText(node);
      case 'comment':
        return {
          type: NODE_TYPES.COMMENT,
          value: /** @type {CommentNode} */ (node).content,
        };
      case 'ifBlock':
      case 'eachBlock':
        return this._transformBlock(node);
      default:
        return null;
    }
  }

  /**
   * @param {HtmlAstNode} node
   * @returns {any}
   */
  _transformText(node) {
    const text = /** @type {TextNode} */ (node).content;
    if (!text.includes('{{')) {
      return { type: NODE_TYPES.TEXT, value: text };
    }
    const mustacheRegex = /{{([^}]+)}}/g;
    const parts = [];
    let lastIndex = 0;
    let match;

    mustacheRegex.lastIndex = 0;
    while ((match = mustacheRegex.exec(text))) {
      if (match.index > lastIndex) {
        parts.push({
          type: NODE_TYPES.TEXT,
          value: text.substring(lastIndex, match.index),
        });
      }
      const expression = match[1]?.trim();
      if (expression) {
        parts.push({
          type: NODE_TYPES.INTERPOLATION,
          expression: this._parseExpr(expression),
        });
      }
      lastIndex = match.index + match[0].length;
    }

    if (lastIndex < text.length) {
      parts.push({ type: NODE_TYPES.TEXT, value: text.substring(lastIndex) });
    }

    return { type: NODE_TYPES.DYNAMIC_TEXT, children: parts };
  }

  /**
   * @param {HtmlAstNode[]} children
   * @returns {any[]}
   */
  _transformChildren(children) {
    const transformed = [];
    let i = 0;
    while (i < children.length) {
      const child = children[i];
      if (!child) {
        i++;
        continue;
      }
      if (child.type === 'ifBlock') {
        /** @type {{condition: JsAstNode | null, node: any}[]} */
        const branches = [];
        /** @type {HtmlAstNode | undefined} */
        let current = child;
        let nextIndex = i + 1;
        while (current) {
          if (current.type === 'ifBlock' || current.type === 'elseIfBlock') {
            branches.push({
              condition: this._parseExpr(
                /** @type {IfBlockNode | ElseIfBlockNode} */ (current).test,
              ),
              node: {
                type: NODE_TYPES.FRAGMENT,
                children: this._transformChildren(current.children || []),
              },
            });
          } else if (current.type === 'elseBlock') {
            branches.push({
              condition: this._parseExpr('true'),
              node: {
                type: NODE_TYPES.FRAGMENT,
                children: this._transformChildren(current.children || []),
              },
            });
          }

          const next = children[nextIndex];
          if (
            next &&
            (next.type === 'elseIfBlock' || next.type === 'elseBlock')
          ) {
            current = next;
            nextIndex++;
          } else {
            current = undefined;
          }
        }
        transformed.push({ type: NODE_TYPES.IF, branches });
        i = nextIndex;
        continue;
      }

      const transformedNode = this._transformNode(child);
      if (transformedNode) {
        transformed.push(transformedNode);
      }
      i++;
    }
    return transformed;
  }

  /**
   * @param {any} block
   * @returns {any}
   */
  _transformBlock(block) {
    if (block.type === 'eachBlock') {
      let itemStr = String(/** @type {EachBlockNode} */ (block).item).trim();
      let keyExpr = /** @type {EachBlockNode} */ (block).key;

      if (!keyExpr && itemStr.endsWith(')') && !itemStr.startsWith('(')) {
        const parenIndex = itemStr.lastIndexOf('(');
        if (parenIndex !== -1) {
          keyExpr = itemStr.substring(parenIndex + 1, itemStr.length - 1);
          itemStr = itemStr.substring(0, parenIndex).trim();
        }
      }

      const match = itemStr.match(/^\(?\s*(\w+)(?:\s*,\s*(\w+))?\s*\)?$/);

      if (!match) {
        logger.error('Invalid each block item syntax:', itemStr);
        return null;
      }

      const valueMatch = match[1];
      const keyMatch = match[2];

      if (!valueMatch) return null;

      return {
        type: NODE_TYPES.FOR,
        source: this._parseExpr(
          /** @type {EachBlockNode} */ (block).expression,
        ),
        value: valueMatch,
        key: keyMatch,
        keyName: this._parseExpr(keyExpr),
        children: this._transformChildren(block.children),
      };
    }
    return null;
  }

  /**
   * @param {ElementNode} el
   * @returns {any}
   */
  _transformElement(el) {
    if (el.tagName === 'slot') {
      const nameAttr = el.attributes.find(
        (/**@type {{name: string}}*/ a) => a.name === 'name',
      );
      return {
        type: NODE_TYPES.SLOT,
        name: nameAttr ? String(nameAttr.value) : 'default',
        children: this._transformChildren(el.children),
      };
    }

    return this._transformNativeElement(el);
  }

  /**
   * @param {ElementNode} el
   * @returns {any}
   */
  _transformNativeElement(el) {
    if (el.tagName === 'component') {
      const isAttr = el.attributes.find(
        (/**@type {{name: string}}*/ a) => a.name === ':is' || a.name === 'is',
      );
      if (isAttr && typeof isAttr.value === 'string') {
        return {
          type: NODE_TYPES.COMPONENT,
          tagName: this._parseExpr(isAttr.value),
          isDynamic: true,
          properties: this._processAttributes(
            el.attributes.filter(
              (/**@type {{name: string}}*/ a) =>
                a.name !== ':is' && a.name !== 'is',
            ),
          ),
          slots: this._processSlots(el.children),
        };
      }
    }

    const tagName = el.tagName;
    const registeredCompKey = this.componentNameMap.get(tagName.toLowerCase());
    const isComponent = !!registeredCompKey;

    if (isComponent) {
      return {
        type: NODE_TYPES.COMPONENT,
        tagName: registeredCompKey,
        properties: this._processAttributes(el.attributes),
        slots: this._processSlots(el.children),
      };
    } else {
      return {
        type: NODE_TYPES.ELEMENT,
        tagName: tagName,
        properties: this._processAttributes(el.attributes),
        children: this._transformChildren(el.children),
      };
    }
  }

  /**
   * @param {AttributeToken[]} attrs
   * @returns {any[]}
   */
  _processAttributes(attrs) {
    const properties = [];
    /** @type {Set<number>} */
    const consumedIndices = new Set();

    for (let i = 0; i < attrs.length; i++) {
      if (consumedIndices.has(i)) continue;

      const attr = attrs[i];
      if (!attr) continue;
      let name = attr.name;
      let value = attr.value;

      if (name === '@ref' && typeof value === 'string') {
        properties.push({
          type: ATTR_TYPES.DIRECTIVE,
          name: 'ref',
          expression: this._parseExpr(value),
        });
        continue;
      }

      if (name.startsWith('@') && !name.includes('.')) {
        let j = i + 1;
        while (
          j < attrs.length &&
          (attrs[j]?.name === 'prevent' || attrs[j]?.name === 'stop')
        ) {
          const modifierAttr = attrs[j];
          if (modifierAttr) {
            name += `.${modifierAttr.name}`;
            if (modifierAttr.value) {
              value = modifierAttr.value ?? value;
            }
            consumedIndices.add(j);
          }
          j++;
        }
      }

      if (name.startsWith('bind:') && typeof value === 'string') {
        const propToBind = name.split(':')[1];
        if (!propToBind) {
          continue;
        }

        properties.push({
          type: ATTR_TYPES.DIRECTIVE,
          name: propToBind.includes('-') ? propToBind : camelize(propToBind),
          expression: this._parseExpr(value),
        });

        const eventName = propToBind === 'value' ? 'onInput' : 'onChange';
        const valueAccessor = propToBind === 'value' ? 'value' : 'checked';

        properties.push({
          type: ATTR_TYPES.EVENT_HANDLER,
          name: eventName,
          expression: this._parseExpr(
            `${value} = $event.target.${valueAccessor}`,
          ),
        });
        continue;
      }

      if (name.startsWith('@') && typeof value === 'string') {
        const [eventName, ...modifiers] = name.slice(1).split('.');
        if (eventName) {
          const pascalEventName =
            eventName.charAt(0).toUpperCase() + eventName.slice(1);
          const prop = {
            type: ATTR_TYPES.EVENT_HANDLER,
            name: `on${pascalEventName}`,
            expression: this._parseExpr(value),
            modifiers: new Set(modifiers),
          };
          properties.push(prop);
        }
      } else if (name.startsWith(':') && typeof value === 'string') {
        const propName = name.substring(1);
        properties.push({
          type: ATTR_TYPES.DIRECTIVE,
          name: propName.includes('-') ? propName : camelize(propName),
          expression: this._parseExpr(value),
        });
      } else if (!name.startsWith('w-') && !name.startsWith('#')) {
        properties.push({ type: ATTR_TYPES.STATIC, name, value });
      }
    }
    return properties;
  }
}

/**
 * @internal
 * In-memory cache for compiled render functions.
 * @type {Map<string, (_ctx: object) => VNode | null>}
 */
export const compileCache = new Map();

/**
 * The main compile function. Takes a component definition and returns a render function.
 * Caches the result based on the component's name.
 * @param {Component} componentDef The component definition object.
 * @param {ComponentOptions | null} [options] Compiler options, such as global components.
 * @returns {(_ctx: object) => VNode | null} The compiled render function.
 */
export function compile(componentDef, options = null) {
  if (compileCache.has(componentDef.name)) {
    const cachedFn = compileCache.get(componentDef.name);
    logger.info(
      `Using cached render function for component: ${componentDef.name}`,
    );
    if (cachedFn) return cachedFn;
  }

  /** @type {(_ctx: object) => VNode | null} */
  let renderFn;
  if (typeof componentDef.render === 'function') {
    logger.info('Using provided render function.');
    renderFn = componentDef.render;
  } else {
    let templateContent = componentDef.template;
    if (typeof templateContent === 'function') {
      logger.info('Executing dynamic template function.');
      /**
       * A tagged template literal helper function.
       * @param {TemplateStringsArray} strings
       * @param {...any} values
       * @returns {string}
       */
      const html = (strings, ...values) =>
        strings.raw.reduce(
          (
            /** @type {string} */ acc,
            /** @type {string} */ str,
            /** @type {number} */ i,
          ) => acc + str + (values[i] || ''),
          '',
        );
      templateContent = /** @type {(h: typeof html) => string} */ (
        templateContent
      )(html);
    }

    if (typeof templateContent !== 'string') {
      logger.error('Component missing template', {
        componentName: componentDef.name,
      });
      renderFn = () => VDOM.h(VDOM.Comment, {}, 'Component missing template');
    } else {
      const finalComponentDef = { ...componentDef, template: templateContent };
      const compiler = new Compiler(finalComponentDef, options);
      const transformedAst = compiler._transformNode(
        compiler.parseHtml(finalComponentDef.template),
      );
      const { fn, source } = generateRenderFn(transformedAst);

      devtools?.__WEBS_DEVELOPER__?.events.emit('component:compiled', {
        name: finalComponentDef.name,
        template: finalComponentDef.template,
        source: source,
      });
      renderFn = fn;
    }
  }

  compileCache.set(componentDef.name, renderFn);
  return renderFn;
}

---------- END: renderer/compiler.js ----------

---------- START: renderer/expression-evaluator.js ----------
/**
 * @file Type definitions for the expression evaluator.
 */

/**
 * @typedef {object} JsToken
 * @property {string} type - The type of the token (e.g., 'IDENTIFIER', 'NUMBER', 'OPERATOR').
 * @property {any} value - The raw value of the token.
 */

/**
 * @typedef {object} AstNode
 * @property {string} type - The type of the AST node (e.g., 'Literal', 'Identifier').
 */

/** @typedef {AstNode & { value: any }} LiteralNode */
/** @typedef {AstNode & { name: string }} IdentifierNode */
/** @typedef {AstNode & { quasis: {type: 'TemplateElement', value: {raw: string}, tail: boolean}[], expressions: AstNode[] }} TemplateLiteralNode */
/** @typedef {AstNode & { properties: {type: 'Property', key: AstNode, value: AstNode}[] }} ObjectExpressionNode */
/** @typedef {AstNode & { elements: AstNode[] }} ArrayExpressionNode */
/** @typedef {AstNode & { operator: string, left: AstNode, right: AstNode }} BinaryExpressionNode */
/** @typedef {AstNode & { operator: string, argument: AstNode }} UnaryExpressionNode */
/** @typedef {AstNode & { object: AstNode, property: IdentifierNode, optional: boolean }} MemberExpressionNode */
/** @typedef {AstNode & { object: AstNode, property: AstNode, optional: boolean, computed: true }} ComputedMemberExpressionNode */
/** @typedef {AstNode & { callee: AstNode, arguments: AstNode[], optional: boolean }} CallExpressionNode */
/** @typedef {AstNode & { test: AstNode, consequent: AstNode, alternate: AstNode }} ConditionalExpressionNode */
/** @typedef {AstNode & { left: AstNode, right: AstNode }} AssignmentExpressionNode */
/** @typedef {AstNode & { params: AstNode[], body: AstNode, expressions?: AstNode[] }} ArrowFunctionExpressionNode */
/** @typedef {AstNode & {}} EmptyParenthesesNode */

/**
 * @file A secure, non-evaluating JavaScript expression tokenizer and parser, designed for safely executing template logic.
 */

/** @type {Map<string, JsToken[]>} */
const jsTokenCache = new Map();

/** @type {Record<string, string>} */
const JS_ESCAPE_MAP = { n: '\n', t: '\t', r: '\r' };

/** @type {Record<string, string>} */
const JS_KEYWORDS = {
  true: 'BOOLEAN',
  false: 'BOOLEAN',
  null: 'NULL',
  undefined: 'UNDEFINED',
};

/** @param {string | undefined} c */
const jsIsWhitespace = (c) =>
  c === ' ' || c === '\n' || c === '\t' || c === '\r';
/** @param {string | undefined} c */
const isDigit = (c) => c !== undefined && c >= '0' && c <= '9';
/** @param {string | undefined} c */
const isIdentStart = (c) =>
  c !== undefined &&
  ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '$' || c === '_');
/** @param {string | undefined} c */
const isIdentPart = (c) => isIdentStart(c) || isDigit(c);

/**
 * Tokenizes a JavaScript expression string into an array of tokens.
 * Caches results for performance.
 * @param {string} expression - The JavaScript expression to tokenize.
 * @returns {JsToken[]} An array of tokens.
 */
export function tokenizeJs(expression) {
  if (jsTokenCache.has(expression)) {
    const cached = jsTokenCache.get(expression);
    if (cached) return cached;
  }

  const tokens = [];
  let i = 0;
  while (i < expression.length) {
    let char = expression[i];

    if (jsIsWhitespace(char)) {
      i++;
      continue;
    }

    if (char === '`') {
      i++;
      tokens.push({ type: 'BACKTICK', value: '`' });
      let currentQuasi = '';
      while (i < expression.length && expression[i] !== '`') {
        if (expression[i] === '$' && expression[i + 1] === '{') {
          if (currentQuasi) {
            tokens.push({ type: 'TEMPLATE_STRING', value: currentQuasi });
            currentQuasi = '';
          }
          i += 2;
          tokens.push({ type: 'TEMPLATE_EXPR_START', value: '${' });
          let braceCount = 1;
          const exprStart = i;
          while (i < expression.length && braceCount > 0) {
            const c = expression[i];
            if (c === '{') braceCount++;
            else if (c === '}') braceCount--;
            if (braceCount > 0) i++;
          }
          if (braceCount !== 0)
            throw new Error('Unmatched braces in template literal');
          const innerExpression = expression.substring(exprStart, i);
          tokens.push(...tokenizeJs(innerExpression || ''));
          tokens.push({ type: 'RBRACE', value: '}' });
          i++;
        } else {
          if (expression[i] === '\\') {
            const nextChar = expression[i + 1];
            currentQuasi += nextChar ? `\\${nextChar}` : `\\`;
            i += 2;
          } else {
            currentQuasi += expression[i];
            i++;
          }
        }
      }
      if (currentQuasi) {
        tokens.push({ type: 'TEMPLATE_STRING', value: currentQuasi });
      }
      if (i >= expression.length || expression[i] !== '`') {
        throw new Error('Unterminated template literal');
      }
      tokens.push({ type: 'BACKTICK', value: '`' });
      i++;
      continue;
    }

    if (isIdentStart(char)) {
      let ident = char;
      let nextChar = expression[++i];
      while (nextChar && isIdentPart(nextChar)) {
        ident += nextChar;
        nextChar = expression[++i];
      }
      //@ts-ignore
      const keywordType = JS_KEYWORDS[ident];
      tokens.push({ type: keywordType || 'IDENTIFIER', value: ident });
      continue;
    }

    if (isDigit(char)) {
      let numStr = char;
      let nextChar = expression[++i];
      while (nextChar && (isDigit(nextChar) || nextChar === '.')) {
        numStr += nextChar;
        nextChar = expression[++i];
      }
      //@ts-ignore
      tokens.push({ type: 'NUMBER', value: parseFloat(numStr) });
      continue;
    }

    if (char === "'" || char === '"') {
      const quote = char;
      let value = '';
      i++;
      while (i < expression.length && expression[i] !== quote) {
        let c = expression[i++];
        if (c === '\\' && i < expression.length) {
          const nextChar = expression[i];
          if (nextChar) {
            const escaped = JS_ESCAPE_MAP[nextChar];
            value += escaped !== undefined ? escaped : nextChar;
          }
          i++;
        } else {
          value += c;
        }
      }
      i++;
      tokens.push({ type: 'STRING', value });
      continue;
    }

    const twoCharOp = expression.slice(i, i + 2);
    const threeCharOp = expression.slice(i, i + 3);

    if (threeCharOp === '===' || threeCharOp === '!==') {
      tokens.push({ type: 'OPERATOR', value: threeCharOp });
      i += 3;
      continue;
    }
    if (
      [
        '==',
        '!=',
        '<=',
        '>=',
        '&&',
        '||',
        '??',
        '?.',
        '=>',
        '++',
        '--',
      ].includes(twoCharOp)
    ) {
      tokens.push({
        type: twoCharOp === '=>' ? 'ARROW' : 'OPERATOR',
        value: twoCharOp,
      });
      i += 2;
      continue;
    }

    if (char && '()[]{},.:'.includes(char)) {
      /** @type {Record<string, string>} */
      const typeMap = {
        '(': 'LPAREN',
        ')': 'RPAREN',
        '[': 'LBRACKET',
        ']': 'RBRACKET',
        '{': 'LBRACE',
        '}': 'RBRACE',
        ',': 'COMMA',
        '.': 'DOT',
        ':': 'COLON',
      };
      const type = typeMap[char];
      if (type) {
        tokens.push({ type, value: char });
      }
      i++;
      continue;
    }

    if (char && '+-*/%<>&|!?='.includes(char)) {
      tokens.push({ type: char === '=' ? 'EQUALS' : 'OPERATOR', value: char });
      i++;
      continue;
    }

    throw new Error(
      `Tokenizer Error: Unrecognized character '${char}' at position ${i}`,
    );
  }

  jsTokenCache.set(expression, tokens);
  return tokens;
}

/**
 * Parses an array of JavaScript tokens into an Abstract Syntax Tree (AST).
 * @param {JsToken[]} tokens - The array of tokens from tokenizeJs.
 * @returns {AstNode} The root node of the generated AST.
 */
export function parseJs(tokens) {
  let i = 0;
  const peek = () => tokens[i];
  const consume = () => tokens[i++];

  /** @type {() => AstNode} */
  let parseAssignment;

  /** @returns {TemplateLiteralNode} */
  const parseTemplateLiteral = () => {
    consume();
    /** @type {{type: 'TemplateElement', value: {raw: string}, tail: boolean}[]} */
    const quasis = [];
    /** @type {AstNode[]} */
    const expressions = [];

    while (peek()?.type !== 'BACKTICK') {
      if (peek()?.type === 'TEMPLATE_STRING') {
        quasis.push({
          type: 'TemplateElement',
          value: { raw: consume()?.value ?? '' },
          tail: false,
        });
      }
      if (peek()?.type === 'TEMPLATE_EXPR_START') {
        consume();
        expressions.push(parseAssignment());
        if (peek()?.type !== 'RBRACE')
          throw new Error("Expected '}' after template expression");
        consume();
      }
    }

    if (quasis.length === expressions.length) {
      quasis.push({ type: 'TemplateElement', value: { raw: '' }, tail: true });
    } else if (quasis.length > 0) {
      const lastQuasi = quasis[quasis.length - 1];
      if (lastQuasi) {
        lastQuasi.tail = true;
      }
    }

    if (!peek() || peek()?.type !== 'BACKTICK')
      throw new Error('Unterminated template literal');
    consume();

    return { type: 'TemplateLiteral', quasis, expressions };
  };

  /** @returns {AstNode} */
  const parsePrimary = () => {
    const token = peek();
    if (!token) throw new Error('Unexpected end of expression.');
    switch (token.type) {
      case 'NUMBER':
      case 'STRING':
        return /** @type {LiteralNode} */ ({
          type: 'Literal',
          value: consume()?.value ?? null,
        });
      case 'BOOLEAN':
        return /** @type {LiteralNode} */ ({
          type: 'Literal',
          value: consume()?.value === 'true',
        });
      case 'NULL':
      case 'UNDEFINED':
        consume();
        return /** @type {LiteralNode} */ ({ type: 'Literal', value: null });
      case 'IDENTIFIER':
        return /** @type {IdentifierNode} */ ({
          type: 'Identifier',
          name: consume()?.value ?? '',
        });
      case 'LPAREN': {
        consume();
        if (peek()?.type === 'RPAREN') {
          consume();
          return /** @type {EmptyParenthesesNode} */ ({
            type: 'EmptyParentheses',
          });
        }
        const expr = parseAssignment();
        if (peek()?.type !== 'RPAREN') throw new Error("Expected ')'");
        consume();
        return expr;
      }
      case 'LBRACE':
        return parseObjectLiteral();
      case 'LBRACKET':
        return parseArrayLiteral();
      case 'BACKTICK':
        return parseTemplateLiteral();
      default:
        throw new Error(
          `Parser Error: Unexpected token ${token.type} with value ${token.value}`,
        );
    }
  };

  /** @returns {ObjectExpressionNode} */
  const parseObjectLiteral = () => {
    consume();
    /** @type {{type: 'Property', key: AstNode, value: AstNode}[]} */
    const properties = [];
    if (peek()?.type !== 'RBRACE') {
      do {
        const key = parsePrimary();
        if (key.type !== 'Identifier' && key.type !== 'Literal') {
          throw new Error('Invalid property key in object literal.');
        }
        if (peek()?.type !== 'COLON')
          throw new Error("Expected ':' after property key.");
        consume();
        const value = parseAssignment();
        properties.push({ type: 'Property', key, value });
      } while (peek()?.type === 'COMMA' && consume());
    }
    if (peek()?.type !== 'RBRACE')
      throw new Error("Expected '}' to close object literal.");
    consume();
    return { type: 'ObjectExpression', properties };
  };

  /** @returns {ArrayExpressionNode} */
  const parseArrayLiteral = () => {
    consume();
    const elements = [];
    if (peek()?.type !== 'RBRACKET') {
      do {
        elements.push(parseAssignment());
      } while (peek()?.type === 'COMMA' && consume());
    }
    if (peek()?.type !== 'RBRACKET')
      throw new Error("Expected ']' to close array literal.");
    consume();
    return { type: 'ArrayExpression', elements };
  };

  /** @returns {AstNode} */
  const parseAccessors = () => {
    let node = parsePrimary();
    while (peek()) {
      const currentToken = peek();
      if (!currentToken) break;
      if (currentToken.value === '.' || currentToken.value === '?.') {
        const optional = consume()?.value === '?.';
        const prop = consume();
        if (!prop || prop.type !== 'IDENTIFIER')
          throw new Error("Expected identifier after '.'");
        node = /** @type {MemberExpressionNode} */ ({
          type: 'MemberExpression',
          object: node,
          property: { type: 'Identifier', name: prop.value ?? '' },
          optional: optional ?? false,
        });
      } else if (currentToken.type === 'LBRACKET') {
        consume();
        const prop = parseAssignment();
        if (peek()?.type !== 'RBRACKET') throw new Error("Expected ']'");
        consume();
        node = /** @type {ComputedMemberExpressionNode} */ ({
          type: 'ComputedMemberExpression',
          object: node,
          property: prop,
          optional: false,
          computed: true,
        });
      } else if (currentToken.type === 'LPAREN') {
        consume();
        const args = [];
        if (peek()?.type !== 'RPAREN') {
          do {
            args.push(parseAssignment());
          } while (peek()?.type === 'COMMA' && consume());
        }
        if (peek()?.type !== 'RPAREN') throw new Error("Expected ')'");
        consume();
        const isOptional =
          node.type === 'MemberExpression' &&
          /** @type {MemberExpressionNode} */ (node).optional;
        node = /** @type {CallExpressionNode} */ ({
          type: 'CallExpression',
          callee: node,
          arguments: args,
          optional: isOptional,
        });
      } else {
        break;
      }
    }
    return node;
  };

  /** @returns {AstNode} */
  const parseUnary = () => {
    const currentToken = peek();
    if (
      currentToken?.type === 'OPERATOR' &&
      (currentToken.value === '!' || currentToken.value === '-')
    ) {
      const op = consume()?.value;
      if (typeof op !== 'string') {
        throw new Error('Expected unary operator');
      }
      return /** @type {UnaryExpressionNode} */ ({
        type: 'UnaryExpression',
        operator: op,
        argument: parseUnary(),
      });
    }
    return parseAccessors();
  };

  /**
   * @param {() => AstNode} nextParser
   * @param {string[]} operators
   * @returns {() => AstNode}
   */
  const buildBinaryParser = (nextParser, operators) => () => {
    let left = nextParser();
    let currentToken = peek();
    while (
      currentToken &&
      typeof currentToken.value === 'string' &&
      operators.includes(currentToken.value)
    ) {
      const op = consume()?.value;
      if (typeof op !== 'string') {
        throw new Error('Expected binary operator');
      }
      const right = nextParser();
      left = /** @type {BinaryExpressionNode} */ ({
        type: 'BinaryExpression',
        operator: op,
        left,
        right,
      });
      currentToken = peek();
    }
    return left;
  };

  const parseMultiplicative = buildBinaryParser(parseUnary, ['*', '/', '%']);
  const parseAdditive = buildBinaryParser(parseMultiplicative, ['+', '-']);
  const parseComparison = buildBinaryParser(parseAdditive, [
    '<',
    '>',
    '<=',
    '>=',
  ]);
  const parseEquality = buildBinaryParser(parseComparison, [
    '==',
    '!=',
    '===',
    '!==',
  ]);
  const parseLogicalAnd = buildBinaryParser(parseEquality, ['&&']);
  const parseLogicalOr = buildBinaryParser(parseLogicalAnd, ['||']);
  const parseNullishCoalescing = buildBinaryParser(parseLogicalOr, ['??']);

  /** @returns {AstNode} */
  const parseConditional = () => {
    const test = parseNullishCoalescing();
    if (peek()?.value === '?') {
      consume();
      const consequent = parseAssignment();
      if (peek()?.type !== 'COLON')
        throw new Error("Expected ':' for ternary operator.");
      consume();
      const alternate = parseAssignment();
      return /** @type {ConditionalExpressionNode} */ ({
        type: 'ConditionalExpression',
        test,
        consequent,
        alternate,
      });
    }
    return test;
  };

  /** @returns {AstNode} */
  const parseArrow = () => {
    const left = parseConditional();
    if (peek()?.type === 'ARROW') {
      consume();
      /** @type {AstNode[]} */
      const params =
        left.type === 'Identifier'
          ? [left]
          : left.type === 'EmptyParentheses'
            ? []
            : /** @type {ArrowFunctionExpressionNode} */ (left).expressions ||
              [];
      if (!Array.isArray(params))
        throw new Error('Invalid arrow function parameters.');
      return /** @type {ArrowFunctionExpressionNode} */ ({
        type: 'ArrowFunctionExpression',
        params,
        body: parseAssignment(),
      });
    }
    return left;
  };

  parseAssignment = () => {
    const left = parseArrow();
    if (peek()?.type === 'EQUALS') {
      consume();
      if (
        left.type !== 'Identifier' &&
        left.type !== 'MemberExpression' &&
        left.type !== 'ComputedMemberExpression'
      ) {
        throw new Error('Invalid left-hand side in assignment expression.');
      }
      return /** @type {AssignmentExpressionNode} */ ({
        type: 'AssignmentExpression',
        left,
        right: parseAssignment(),
      });
    }
    return left;
  };

  const ast = parseAssignment();

  if (i < tokens.length) {
    const token = peek();
    if (token) {
      throw new Error(
        `Parser Error: Unexpected token '${token.value}' at end of expression.`,
      );
    }
  }

  return ast;
}

---------- END: renderer/expression-evaluator.js ----------

---------- START: developer/logger.js ----------
/**
 * @file Manages logging functionality with configurable levels.
 */

/**
 * The available logging levels.
 * @typedef {'debug' | 'info' | 'warn' | 'error' | 'silent'} LogLevel
 */

/**
 * A logger instance with methods for different log levels.
 * @typedef {object} Logger
 * @property {(...args: any[]) => void} debug - Logs a debug message.
 * @property {(...args: any[]) => void} info - Logs an info message.
 * @property {(...args: any[]) => void} log - Logs an info message (alias for info).
 * @property {(...args: any[]) => void} warn - Logs a warning message.
 * @property {(...args: any[]) => void} error - Logs an error message.
 */

/**
 * @internal
 * @type {Record<LogLevel, number>}
 * Maps log levels to their severity number.
 */
const LOG_LEVELS = {
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  silent: 5,
};

/**
 * @internal
 * @type {LogLevel}
 * The current logging level name.
 */
let currentLogLevelName =
  (typeof process !== 'undefined' &&
    /** @type {LogLevel} */ (process.env.LOG_LEVEL)) ||
  'info';

/**
 * @internal
 * @type {number}
 * The current logging level severity.
 */
let currentLogLevel = LOG_LEVELS[currentLogLevelName];

/**
 * Sets the global logging level for all created loggers.
 * @param {LogLevel} level - The new logging level to set.
 */
export function setLogLevel(level) {
  if (LOG_LEVELS[level]) {
    currentLogLevel = LOG_LEVELS[level];
    currentLogLevelName = level;
  }
}

/**
 * Creates a new logger instance with a specified prefix.
 * @param {string} prefix - The prefix to prepend to all log messages from this logger.
 * @returns {Logger} A logger object with different log levels.
 */
export function createLogger(prefix) {
  /**
   * @internal
   * @param {number} level - The severity level of the message.
   * @param {'log' | 'warn' | 'error'} consoleMethod - The console method to use.
   * @param {...any} args - The arguments to log.
   */
  const doLog = (level, consoleMethod, ...args) => {
    if (level >= currentLogLevel) {
      console[consoleMethod](prefix, ...args);
    }
  };

  return {
    /** @param {...any} args */
    debug: (...args) => doLog(LOG_LEVELS.debug, 'log', ...args),
    /** @param {...any} args */
    info: (...args) => doLog(LOG_LEVELS.info, 'log', ...args),
    /** @param {...any} args */
    log: (...args) => doLog(LOG_LEVELS.info, 'log', ...args),
    /** @param {...any} args */
    warn: (...args) => doLog(LOG_LEVELS.warn, 'warn', ...args),
    /** @param {...any} args */
    error: (...args) => doLog(LOG_LEVELS.error, 'error', ...args),
  };
}

---------- END: developer/logger.js ----------

---------- START: developer/profiler.js ----------
#!/usr/bin/env bun

import { relative, join, resolve, basename } from 'node:path';
import { readdir, stat, writeFile } from 'node:fs/promises';
import { Glob } from 'bun';
import * as readline from 'node:readline';
import { AI } from '../ai/ai.server.js';
import {
  config as defaultConfig,
  aiConfig as defaultAiConfig,
} from '../server/server-config.js';
import { $ } from 'bun';

/**
 * @file Contains type definitions for the profiler and analysis tools.
 */

/**
 * Represents a node in the project's file structure tree.
 * @typedef {object} FileTreeNode
 * @property {string} name - The name of the file or directory.
 * @property {string} path - The absolute path to the file or directory.
 * @property {FileTreeNode[]} [children] - An array of child nodes if it's a directory.
 */

/**
 * The result object from running the test suite.
 * @typedef {object} TestAnalysis
 * @property {number} exitCode - The exit code of the test process.
 * @property {number} passed - The number of passed tests.
 * @property {number} failed - The number of failed tests.
 * @property {string} output - The standard output from the test runner.
 * @property {string} errorOutput - The standard error output from the test runner.
 */

/**
 * The result object from running the TypeScript compiler for type analysis.
 * @typedef {object} TypeAnalysis
 * @property {number} totalFilesWithErrors - The number of files containing type errors.
 * @property {number} totalErrors - The total number of type errors found.
 * @property {Record<string, string[]>} errorsByFile - An object mapping file paths to an array of error messages.
 * @property {number} exitCode - The exit code of the TypeScript compiler process.
 */

const colors = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
};

/**
 * @param {keyof typeof colors} color
 * @param {string | number} text
 * @returns {string}
 */
const c = (color, text) => `${colors[color]}${text}${colors.reset}`;
/** @param {string} str */
const stripAnsi = (str) => str.replace(/\x1b\[[0-9;]*m/g, '');

const log = {
  /** @param {string} label */
  cardLine: (label, value = '') => {
    console.log(`${label}  ${c('bold', String(value))}`);
  },
  /** @param {string} message */
  error: (message) => {
    const formatted = ` ${c('bold', c('red', '✖'))} ${c('red', message)} `;
    console.log(formatted);
  },
};

const EMBED_LOCK_FILE = '.webs-embed.lock.json';

/**
 * Builds a file tree from the source for project structure display.
 * @param {string} dirPath
 * @returns {Promise<FileTreeNode | null>}
 */
async function buildProjectTree(dirPath) {
  try {
    const stats = await stat(dirPath);
    const name = dirPath.split('/').pop() || '';
    /** @type {FileTreeNode} */
    const node = { name, path: dirPath, children: [] };
    if (!stats.isDirectory()) {
      delete node.children;
      return node;
    }
    const dirents = await readdir(dirPath, { withFileTypes: true });
    for (const dirent of dirents) {
      const childPath = join(dirPath, dirent.name);
      const childNode = await buildProjectTree(childPath);
      if (childNode) node.children?.push(childNode);
    }
    node.children?.sort((a, b) => {
      if (a.children && !b.children) return -1;
      if (!a.children && b.children) return 1;
      return a.name.localeCompare(b.name);
    });
    return node;
  } catch {
    return null;
  }
}

/**
 * @param {FileTreeNode} node
 * @param {string} [prefix]
 * @param {boolean} [isLast]
 * @returns {string[]}
 */
function collectTreeStringLines(node, prefix = '', isLast = true) {
  const lines = [];
  const connector = isLast ? '└─' : '├─';
  const linePrefix = `${prefix}${connector} `;
  lines.push(`${linePrefix}${node.name}`);
  if (node.children) {
    const newPrefix = prefix + (isLast ? '   ' : '│  ');
    for (const [index, child] of node.children.entries()) {
      lines.push(
        ...collectTreeStringLines(
          child,
          newPrefix,
          index === node.children.length - 1,
        ),
      );
    }
  }
  return lines;
}

/**
 * Generates a plain text report of the project structure.
 * @param {FileTreeNode | null} tree
 * @returns {string}
 */
function generateTreeReport(tree) {
  if (!tree || !tree.children || !tree.children.length) {
    return 'Project Structure: No files found.\n';
  }
  let report = 'Project Structure:\n';
  const header = ` ./${tree.name}`;
  const lines = [];
  for (const [index, child] of tree.children.entries()) {
    lines.push(
      ...collectTreeStringLines(child, '', index === tree.children.length - 1),
    );
  }
  report += [header, ...lines].join('\n');
  report += '\n';
  return report;
}

/**
 * @param {string} targetDir
 * @returns {Promise<TestAnalysis>}
 */
async function runTests(targetDir) {
  const proc = Bun.spawn(['bun', 'test', targetDir], {
    stderr: 'pipe',
    stdout: 'pipe',
  });
  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;

  const cleanOutput = stripAnsi(stdout);
  let passed = 0;
  let failed = 0;

  const passMatches = cleanOutput.match(/(\d+)\s+pass/g);
  const failMatches = cleanOutput.match(/(\d+)\s+fail/g);

  if (passMatches) {
    const lastPass = passMatches[passMatches.length - 1];
    const passCountStr = lastPass?.split(' ')[0];
    if (passCountStr) passed = parseInt(passCountStr, 10);
  }

  if (failMatches) {
    const lastFail = failMatches[failMatches.length - 1];
    const failCountStr = lastFail?.split(' ')[0];
    if (failCountStr) failed = parseInt(failCountStr, 10);
  }

  return { exitCode, passed, failed, output: stdout, errorOutput: stderr };
}

/**
 * @param {string} targetDir
 * @returns {Promise<TypeAnalysis>}
 */
async function checkTypes(targetDir) {
  const proc = Bun.spawn(['bun', 'tsc', '--noEmit', '--pretty', 'false'], {
    cwd: targetDir === 'lib' ? process.cwd() : targetDir,
    stderr: 'pipe',
    stdout: 'pipe',
  });
  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;
  if (stderr && !stdout.trim()) {
    log.error('Error executing the TypeScript compiler:');
    console.error(stderr);
    process.exit(1);
  }

  /** @type {Record<string, string[]>} */
  const errorsByFile = {};
  const errorRegex = /^(.*?)\((\d+),(\d+)\):\s+error\s+TS\d+:\s+(.*)$/gm;
  let match;
  while ((match = errorRegex.exec(stdout)) !== null) {
    const [, filePath, line, column, message] = match;
    if (filePath) {
      const relativePath = relative(process.cwd(), join(targetDir, filePath));
      if (!errorsByFile[relativePath]) errorsByFile[relativePath] = [];
      errorsByFile[relativePath]?.push(
        `L${line}:C${column} - ${(message || '').trim()}`,
      );
    }
  }

  const totalErrors = Object.values(errorsByFile).flat().length;
  const totalFilesWithErrors = Object.keys(errorsByFile).length;

  return { totalFilesWithErrors, totalErrors, errorsByFile, exitCode };
}

/**
 * @param {string} targetDir
 * @param {string[]} [additionalFiles]
 * @param {string[]} [excludedPatterns]
 * @returns {Promise<Record<string, string>>}
 */
async function getInlineSource(
  targetDir,
  additionalFiles = [],
  excludedPatterns = [],
) {
  const inputPath = resolve(process.cwd(), targetDir);
  const glob = new Glob('**/*.{js,mjs,cjs,jsx,ts,mts,cts,tsx,webs}');
  /** @type {Record<string, string>} */
  const sourceData = {};

  const scannedFiles = await Array.fromAsync(
    glob.scan({ cwd: inputPath, absolute: true, dot: true, onlyFiles: true }),
  );

  const excludeGlobs = excludedPatterns.map((pattern) => {
    if (!pattern.includes('/') && !pattern.includes('\\')) {
      return new Glob(`**/${pattern}`);
    }
    return new Glob(pattern);
  });

  const filteredFiles = scannedFiles.filter((filePath) => {
    const relativePath = relative(inputPath, filePath);
    for (const glob of excludeGlobs) {
      if (glob.match(relativePath)) {
        return false;
      }
    }
    return true;
  });

  for (const filePath of filteredFiles) {
    const relativePath = relative(inputPath, filePath);
    const file = Bun.file(filePath);
    if (file.size > 0) {
      sourceData[relativePath] = await file.text();
    }
  }

  for (const filePath of additionalFiles) {
    const absolutePath = resolve(process.cwd(), filePath);
    try {
      const file = Bun.file(absolutePath);
      if ((await file.exists()) && file.size > 0) {
        const displayPath = relative(process.cwd(), absolutePath);
        sourceData[displayPath] = await file.text();
      } else {
        console.log(
          c('yellow', `  - Skipping: ${filePath} (not found or empty)`),
        );
      }
    } catch (e) {
      const message = e instanceof Error ? e.message : String(e);
      log.error(`Error reading file ${filePath}: ${message}`);
    }
  }

  return sourceData;
}

/**
 * @param {string} targetDir
 * @returns {Promise<Record<string, { mtimeMs: number, size: number }>>}
 */
async function readLockfile(targetDir) {
  const lockfilePath = resolve(targetDir, EMBED_LOCK_FILE);
  try {
    const file = Bun.file(lockfilePath);
    if (await file.exists()) {
      return await file.json();
    }
    return {};
  } catch (error) {
    log.error('Error reading lockfile, proceeding without it.');
    console.error(error);
    return {};
  }
}

/**
 * @param {string} targetDir
 * @param {Record<string, { mtimeMs: number, size: number }>} fileStats
 */
async function writeLockfile(targetDir, fileStats) {
  const lockfilePath = resolve(targetDir, EMBED_LOCK_FILE);
  try {
    await Bun.write(lockfilePath, JSON.stringify(fileStats, null, 2));
  } catch (error) {
    log.error('Error writing lockfile.');
    console.error(error);
  }
}

/**
 * @param {TestAnalysis} analysis
 * @returns {string}
 */
function generateTestReport(analysis) {
  let report = 'Test Runner:\n';
  const { exitCode, passed, failed, output, errorOutput } = analysis;

  if (exitCode === 0 && failed === 0) {
    report += 'Status: OK\n';
  } else {
    report += `Status: ${failed > 0 ? 'Failed' : 'Error'}\n`;
  }
  report += `Summary: ${passed} test(s) passed, ${failed} test(s) failed.\n`;
  if (output) report += `\n--- TEST OUTPUT ---\n${output}\n`;
  if (errorOutput) {
    report += `\n--- STDERR ---\n${errorOutput}\n`;
  }
  return report;
}

/**
 * @param {TypeAnalysis} analysis
 * @returns {string}
 */
function generateTypeAnalysisReport(analysis) {
  const { exitCode, totalErrors, totalFilesWithErrors } = analysis;
  let report = 'Type Analysis:\n';
  if (exitCode === 0) {
    report += 'Status: OK\n';
    report += 'Total Errors: 0\n';
    return report;
  }

  report += `Status: ${totalErrors} error(s) found in ${totalFilesWithErrors} file(s)\n`;
  return report;
}

/**
 * @param {TypeAnalysis} analysis
 * @returns {string}
 */
function generateVerboseTypeAnalysisReport(analysis) {
  const { exitCode, totalErrors, totalFilesWithErrors, errorsByFile } =
    analysis;
  let report = 'Type Analysis:\n';
  if (exitCode === 0) {
    report += 'Status: OK\n';
    report += 'Total Errors: 0\n';
    return report;
  }

  report += `Status: ${totalErrors} error(s) found in ${totalFilesWithErrors} file(s)\n\n`;
  for (const [file, errors] of Object.entries(errorsByFile)) {
    report += `--- ${file} ---\n`;
    report += errors.join('\n') + '\n\n';
  }
  return report;
}

/**
 * @template T
 * @param {string} title
 * @param {() => Promise<T>} task
 * @returns {Promise<{result: T, duration: string}>}
 */
async function runTaskWithLoader(title, task) {
  let lastLineLength = 0;
  const startTime = performance.now();
  console.log('');

  const spinnerFrames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
  let frameIndex = 0;

  const interval = setInterval(() => {
    const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
    const timer = c('dim', `(${elapsed}s)`);
    const frame = spinnerFrames[frameIndex];
    if (frame) {
      const spinner = c('magenta', frame);
      const line = `\r ${spinner} ${title} ${timer}`;
      process.stdout.write(line.padEnd(lastLineLength));
      lastLineLength = stripAnsi(line).length;
    }
    frameIndex = (frameIndex + 1) % spinnerFrames.length;
  }, 80);

  try {
    const result = await task();
    clearInterval(interval);
    const duration = ((performance.now() - startTime) / 1000).toFixed(2);
    const timer = c('dim', `(${duration}s)`);
    const successLine = `\r${c('green', '✓')} ${title} ${timer}\n`;
    process.stdout.write(successLine.padEnd(lastLineLength + 1));
    return { result, duration };
  } catch (e) {
    clearInterval(interval);
    const duration = ((performance.now() - startTime) / 1000).toFixed(2);
    const timer = c('dim', `(${duration}s)`);
    const failLine = `\r${c('red', '✖')} ${title} ${timer}\n`;
    process.stdout.write(failLine.padEnd(lastLineLength + 1));
    throw e;
  }
}

/**
 * Generates a comprehensive lockfile with analysis and source code.
 * @param {string} targetDir
 * @param {string[]} [sectionsToInclude] - Optional array of sections to include: 'tree', 'types', 'tests', 'files'.
 * @param {string[]} [filesToInclude] - Optional array of additional files to include.
 * @param {string[]} [patternsToExclude]
 */
export async function createLockfile(
  targetDir,
  sectionsToInclude = [],
  filesToInclude = [],
  patternsToExclude = [],
) {
  const allSections = ['tree', 'types', 'tests', 'files'];
  const shouldIncludeAll =
    sectionsToInclude.length === 0 &&
    filesToInclude.length === 0 &&
    patternsToExclude.length === 0;

  let sections = shouldIncludeAll ? allSections : sectionsToInclude;

  if (filesToInclude.length > 0 && !sections.includes('files')) {
    sections.push('files');
  }

  const shouldRun = (/** @type {string} */ section) =>
    sections.includes(section);

  console.log(
    c('bold', `\nGenerating analysis lockfile for '${targetDir}'...`),
  );
  if (!shouldIncludeAll) {
    console.log(c('dim', `Including sections: ${sections.join(', ')}`));
    if (patternsToExclude.length > 0) {
      console.log(
        c('dim', `Excluding patterns: ${patternsToExclude.join(', ')}`),
      );
    }
  }

  const parts = [];

  if (shouldRun('tree')) {
    const { result: tree } = await runTaskWithLoader(
      'Building project tree',
      () => buildProjectTree(targetDir),
    );
    const treeReport = generateTreeReport(tree);
    let content = '========== PROJECT STRUCTURE ==========\n';
    content += stripAnsi(treeReport).replace('Project Structure:\n', '');
    parts.push(content);
  }

  if (shouldRun('types')) {
    const { result: typeAnalysis } = await runTaskWithLoader(
      'Checking Types',
      () => checkTypes(targetDir),
    );
    const typeReport = generateVerboseTypeAnalysisReport(typeAnalysis);
    let content = '========== TYPE ANALYSIS ==========\n';
    content += stripAnsi(typeReport).replace('Type Analysis:\n', '');
    parts.push(content);
  }

  if (shouldRun('tests')) {
    const { result: testAnalysis } = await runTaskWithLoader(
      'Running Tests',
      () => runTests(targetDir),
    );
    const testReport = generateTestReport(testAnalysis);
    let content = '========== TEST RUNNER ==========\n';
    content += stripAnsi(testReport).replace('Test Runner:\n', '');
    parts.push(content);
  }

  if (shouldRun('files')) {
    const { result: sourceFiles } = await runTaskWithLoader(
      'Collecting source files',
      () => getInlineSource(targetDir, filesToInclude, patternsToExclude),
    );
    let content = '========== SOURCE FILES ==========\n';
    for (const [path, sourceContent] of Object.entries(sourceFiles)) {
      content += `\n---------- START: ${path} ----------\n`;
      content += sourceContent;
      content += `\n---------- END: ${path} ----------\n`;
    }
    parts.push(content);
  }

  if (parts.length === 0) {
    console.log(
      c('yellow', 'No sections were included. Lockfile not created.'),
    );
    return;
  }

  const lockfileContent = parts.join('\n');
  const outputPath = resolve(targetDir, 'webs.lock.txt');
  await writeFile(outputPath, lockfileContent);

  console.log(
    c('green', `\n✓ Analysis complete. Lockfile saved to: ${outputPath}`),
  );
}

/**
 * @param {string} targetDir
 */
export async function startAiSession(targetDir) {
  const aiConfig = {
    ...defaultAiConfig,
    db: {
      ...defaultAiConfig.db,
      path: resolve(targetDir, '.webs/ai.db'),
    },
    worker: {
      path: resolve(defaultConfig.LIB_DIR, 'ai/ai.worker.js'),
    },
  };

  const ai = new AI(aiConfig);
  await ai.init();

  const source = await getInlineSource(targetDir);
  const tree = await buildProjectTree(targetDir);

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: c('cyan', 'webs> '),
  });

  console.log(
    c('bold', `\nWelcome to the Webs AI Profiler for '${targetDir}'.`),
  );
  console.log(c('dim', "Type 'help' for a list of commands.\n"));

  /** @type {{ [key: string]: (args: string[]) => void | Promise<void> }} */
  const commands = {
    help() {
      console.log('\nAvailable commands:');
      console.log(
        `  ${c('bold', 'tree')}          - Show the project structure tree.`,
      );
      console.log(
        `  ${c('bold', 'cat <file>')}    - Show the content of a source file.`,
      );
      console.log(
        `  ${c(
          'bold',
          'embed',
        )}          - Embed source files into the vector DB.`,
      );
      console.log(
        `  ${c('bold', 'query <terms>')}  - Query the embedded source files.`,
      );
      console.log(
        `  ${c(
          'bold',
          'chat <question>',
        )} - Chat with the AI about the codebase.`,
      );
      console.log(`  ${c('bold', 'exit | quit')}   - Exit the profiler.\n`);
    },
    exit() {
      rl.close();
    },
    quit() {
      rl.close();
    },
    tree() {
      console.log(generateTreeReport(tree));
    },
    /** @param {string[]} args */
    cat(args) {
      const filePath = args[0];
      if (!filePath) {
        log.error('Usage: cat <file_path>');
        return;
      }
      if (source[filePath]) {
        console.log(`\n--- Source for ${c('yellow', filePath)} ---\n`);
        console.log(source[filePath]);
        console.log(`\n--- End of Source ---\n`);
      } else {
        log.error(`File not found in source map: ${filePath}`);
      }
    },
    embed: async () => {
      const embedTask = async () => {
        const prevFileStats = await readLockfile(targetDir);
        /** @type {Record<string, { mtimeMs: number, size: number }>} */
        const currentFileStats = {};
        /** @type {{path: string, content: string}[]} */
        const filesToEmbed = [];

        for (const [path, content] of Object.entries(source)) {
          const absolutePath = resolve(targetDir, path);
          try {
            const fileStats = await stat(absolutePath);
            const currentMtime = fileStats.mtimeMs;
            const currentSize = fileStats.size;

            currentFileStats[path] = {
              mtimeMs: currentMtime,
              size: currentSize,
            };

            const prevStats = prevFileStats[path];
            if (
              !prevStats ||
              prevStats.mtimeMs !== currentMtime ||
              prevStats.size !== currentSize
            ) {
              filesToEmbed.push({ path, content });
            }
          } catch (e) {
            continue;
          }
        }

        if (filesToEmbed.length === 0) {
          console.log(
            c('green', '  All files are up-to-date. No embedding needed.'),
          );
          return { successCount: 0, failedCount: 0 };
        }

        let successCount = 0;
        let failedCount = 0;
        for (const file of filesToEmbed) {
          const success = await ai.indexFile(file, {});
          if (success) successCount++;
          else failedCount++;
        }
        await writeLockfile(targetDir, currentFileStats);
        return { successCount, failedCount };
      };

      try {
        const { result, duration } = await runTaskWithLoader(
          'Embedding source files',
          embedTask,
        );
        console.log(
          c(
            'green',
            `  Successfully embedded ${result.successCount} file(s) in ${duration}s.`,
          ),
        );
        if (result.failedCount > 0)
          console.log(c('yellow', `  Skipped ${result.failedCount} file(s).`));
      } catch (e) {
        log.error('An error occurred during embedding.');
      }
    },
    /** @param {string[]} args */
    query: async (args) => {
      const queryText = args.join(' ');
      if (!queryText) {
        log.error('Usage: query <search terms>');
        return;
      }
      const { result: results } = await runTaskWithLoader(
        `Searching for "${queryText}"`,
        () => ai.search(queryText, 5),
      );
      if (!results || results.length === 0) {
        console.log('  No results found.');
      } else {
        console.log(c('bold', `\n  Top ${results.length} results:`));
        results.forEach((res, i) => {
          console.log(
            `\n  ${i + 1}. ${c(
              'yellow',
              res.metadata.filePath,
            )} ${c('dim', `(score: ${res.score.toFixed(4)})`)}`,
          );
          console.log(c('dim', `    > ${res.text.split('\n')[0]}...`));
        });
        console.log('');
      }
    },
    /** @param {string[]} args */
    chat: async (args) => {
      const queryText = args.join(' ');
      if (!queryText) {
        log.error('Usage: chat <question>');
        return;
      }
      console.log(c('magenta', '\n...'));
      const stream = await ai.chat([{ role: 'user', content: queryText }]);
      const reader = stream.getReader();
      process.stdout.write(c('bold', 'AI: '));
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          process.stdout.write('\n\n');
          break;
        }
        process.stdout.write(value);
      }
    },
  };

  rl.on('line', async (line) => {
    const [command, ...args] = line.trim().split(/\s+/);
    const cmdFunc = command ? commands[command] : null;

    if (cmdFunc) {
      await cmdFunc(args);
    } else if (command) {
      log.error(
        `Unknown command: '${command}'. Type 'help' for available commands.`,
      );
    }
    rl.prompt();
  }).on('close', () => {
    ai.shutdown();
    console.log(c('bold', '\nExiting profiler.'));
    process.exit(0);
  });

  rl.prompt();
}

/**
 * @param {string} targetDir
 */
export async function runAnalysis(targetDir) {
  const { result: testAnalysis } = await runTaskWithLoader(
    'Running Tests',
    () => runTests(targetDir),
  );
  const { result: typeAnalysis } = await runTaskWithLoader(
    'Checking Types',
    () => checkTypes(targetDir),
  );

  console.log('\n--- Analysis Complete ---\n');
  console.log(c('bold', 'Type Analysis:'));
  console.log(
    generateTypeAnalysisReport(typeAnalysis).split('\n').slice(1).join('\n'),
  );
  console.log(c('bold', '\nTest Analysis:'));
  console.log(generateTestReport(testAnalysis).split('\n').slice(1).join('\n'));
}

/**
 * @param {object} inspectionData
 * @param {Record<string, import('../server/router.js').RouteDefinition>} inspectionData.appRoutes
 * @param {Record<string, import('../ai/ai.server.js').AgentDefinition>} inspectionData.agentRoutes
 * @param {string[]} inspectionData.sourceEntrypoints
 * @param {import('../server/server-config.js').Config} inspectionData.config
 * @param {Record<string, string>} inspectionData.sourceToComponentMap
 */
export async function generateInspectionReport({
  appRoutes,
  agentRoutes,
  sourceEntrypoints,
  config,
  sourceToComponentMap,
}) {
  console.log(
    c(
      'bold',
      `\nInspecting Webs project at '${relative(process.cwd(), config.CWD)}'`,
    ),
  );

  console.log(c('bold', '\nPages & API Routes'));
  console.log(c('dim', '──────────────────'));

  const sortedRoutes = Object.entries(appRoutes).sort(([pathA], [pathB]) =>
    pathA.localeCompare(pathB),
  );

  for (const [path, def] of sortedRoutes) {
    const methods = ['GET', ...Object.keys(def.handlers)].map((m) =>
      m.toUpperCase(),
    );
    if (Object.keys(def.wsHandlers).length > 0) {
      methods.push('WSS');
    }
    const methodStr = methods.map((m) => c('cyan', `[${m}]`)).join(' ');

    const componentName = def.componentName;
    const sourcePath = Object.entries(sourceToComponentMap).find(
      ([, name]) =>
        name === componentName ||
        `layout/${name.replace(/\//g, '_')}` === componentName,
    )?.[0];

    console.log(` ${methodStr} ${path}`);
    if (sourcePath) {
      console.log(c('dim', `        └─ component: ${sourcePath}`));
    }
  }

  console.log(c('bold', '\nRegistered Components'));
  console.log(c('dim', '───────────────────'));
  const guiComponents = [];
  const appComponents = [];

  for (const fullPath of sourceEntrypoints) {
    const relPath = relative(config.SRC_DIR, fullPath);
    if (relPath.endsWith('.agent.webs') || basename(relPath) === 'layout.webs')
      continue;

    if (relPath.startsWith('gui/')) {
      guiComponents.push({
        name: basename(relPath, '.webs'),
        path: `src/${relPath}`,
      });
    } else if (relPath.startsWith('app/')) {
      appComponents.push({
        name: relPath.replace('.webs', '').replace('app/', ''),
        path: `src/${relPath}`,
      });
    }
  }

  guiComponents.sort((a, b) => a.name.localeCompare(b.name));
  appComponents.sort((a, b) => a.name.localeCompare(b.name));

  for (const { name, path } of guiComponents) {
    console.log(` • ${name} ${c('dim', `(from: ${path})`)}`);
  }
  for (const { name, path } of appComponents) {
    console.log(` • ${name} ${c('dim', `(from: ${path})`)}`);
  }

  if (Object.keys(agentRoutes).length > 0) {
    console.log(c('bold', '\nAI Agents'));
    console.log(c('dim', '─────────'));
    for (const [name, def] of Object.entries(agentRoutes)) {
      console.log(` • ${name.replace('app/', '')}`);
      if (def.model) {
        console.log(c('dim', `   └─ model: ${def.model}`));
      }
      if (def.tools && def.tools.length > 0) {
        const toolNames = def.tools.map((t) => t.function.name).join(', ');
        console.log(c('dim', `   └─ tools: [${toolNames}]`));
      }
    }
  }
  console.log('');
}

/**
 * @param {string} pattern
 * @param {string} path
 * @param {string | undefined} filePattern
 */
export async function runGrep(pattern, path, filePattern) {
  const args = ['-r', '-n', '-I', '--color=always', pattern, path];
  if (filePattern) {
    args.splice(4, 0, `--include=${filePattern}`);
  }

  const proc = Bun.spawn(['grep', ...args], {
    stdout: 'pipe',
    stderr: 'pipe',
  });

  const reader = proc.stdout.getReader();
  const decoder = new TextDecoder();

  const highlight = (/** @type {string} */ line) => {
    return line.replace(
      new RegExp(pattern, 'g'),
      (/** @type {string} */ match) => c('red', c('bold', match)),
    );
  };

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value);
    const lines = chunk.split('\n');
    for (const line of lines) {
      if (!line) continue;
      const [filePath, lineNum, ...rest] = line.split(':');
      const content = rest.join(':');
      if (filePath && lineNum) {
        process.stdout.write(
          `${c('yellow', filePath)}:${c('cyan', lineNum)}: ${highlight(
            content,
          )}\n`,
        );
      }
    }
  }

  const stderr = await new Response(proc.stderr).text();
  if (stderr) {
    console.error(c('red', `grep error:\n${stderr}`));
  }
}

/**
 * @param {number} port
 * @param {string} targetDir
 */
export async function startInteractiveShell(port, targetDir) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: c('cyan', 'webs> '),
  });

  console.log(c('bold', `\nConnected to dev server on port ${port}.`));
  console.log(c('dim', "Type 'help' for a list of commands.\n"));

  /**
   * @param {string} output
   */
  const printResponse = (output) => {
    const [headerPart, ...bodyParts] = output.split('\r\n\r\n');
    const body = bodyParts.join('\r\n\r\n');
    const headers = headerPart?.split('\r\n') || [];
    const statusLine = headers.shift();

    if (statusLine) {
      const statusMatch = statusLine.match(/HTTP\/\d\.\d (\d+) (.*)/);
      if (statusMatch) {
        const code = parseInt(statusMatch[1] || '0', 10);
        const statusText = statusMatch[2];
        const color =
          code >= 200 && code < 300 ? 'green' : code >= 400 ? 'red' : 'yellow';
        console.log(c('bold', `Status: ${c(color, `${code} ${statusText}`)}`));
      }
    }

    console.log(c('bold', 'Headers:'));
    console.log(c('dim', headers.join('\n')));

    console.log(c('bold', '\nBody:'));
    try {
      console.log(JSON.stringify(JSON.parse(body), null, 2));
    } catch {
      console.log(body);
    }
  };

  /** @type {{ [key: string]: (args: string[]) => void | Promise<void> }} */
  const commands = {
    help() {
      console.log('\nAvailable commands:');
      console.log(
        `  ${c(
          'bold',
          'GET|POST|PUT|PATCH|DELETE <path> [body]',
        )} - Make an HTTP request.`,
      );
      console.log(
        `  ${c(
          'bold',
          'grep <pattern> [path] [--include <glob>]',
        )}   - Search for a pattern in files.`,
      );
      console.log(
        `  ${c(
          'bold',
          'test [path]',
        )}                               - Run tests for the project.`,
      );
      console.log(
        `  ${c('bold', 'exit | quit')}                                - Exit the shell.\n`,
      );
    },
    exit() {
      rl.close();
    },
    quit() {
      rl.close();
    },
    /** @param {string[]} args */
    async test(args) {
      const testPath = args[0] || targetDir;
      console.log(`Running tests for '${testPath}'...`);
      const { output, errorOutput } = await runTests(testPath);
      console.log(output);
      if (errorOutput) console.error(errorOutput);
    },
    /** @param {string[]} args */
    async grep(args) {
      const pattern = args[0];
      const path = args[1] || targetDir;
      const includeIndex = args.indexOf('--include');
      const filePattern =
        includeIndex !== -1 ? args[includeIndex + 1] : undefined;
      if (!pattern) {
        log.error('Usage: grep <pattern> [path] [--include <glob>]');
        return;
      }
      await runGrep(pattern, path, filePattern);
    },
  };

  /**
   * @param {string} method
   */
  const createRequestHandler =
    (method) => async (/** @type {string[]} */ args) => {
      const path = args[0];
      if (!path) {
        log.error(`Usage: ${method} <path> [body]`);
        return;
      }
      const body = args.slice(1).join(' ');
      const headers =
        method !== 'GET' ? `-H "Content-Type: application/json"` : '';
      const data = body ? `-d '${$.escape(body)}'` : '';
      const command = `curl -s -i -X ${method} http://localhost:${port}${path} ${headers} ${data}`;
      const { stdout, stderr, exitCode } = await $`${{
        raw: command,
      }}`.nothrow();

      if (exitCode !== 0) {
        log.error(`Request failed with exit code ${exitCode}`);
        console.error(stderr.toString());
      } else {
        printResponse(stdout.toString());
      }
    };

  commands.get = createRequestHandler('GET');
  commands.post = createRequestHandler('POST');
  commands.put = createRequestHandler('PUT');
  commands.patch = createRequestHandler('PATCH');
  commands.delete = createRequestHandler('DELETE');

  rl.on('line', async (line) => {
    const [command, ...args] = line.trim().split(/\s+/);
    const cmdFunc = command ? commands[command.toLowerCase()] : null;

    if (cmdFunc) {
      await cmdFunc(args);
    } else if (command) {
      log.error(`Unknown command: '${command}'. Type 'help' for commands.`);
    }
    rl.prompt();
  }).on('close', () => {
    console.log(c('bold', '\nExiting shell.'));
    process.exit(0);
  });

  rl.prompt();
}

---------- END: developer/profiler.js ----------

---------- START: developer/developer.js ----------
/**
 * @file Initializes the global developer tools interface.
 * This module creates the `window.__WEBS_DEVELOPER__` object,
 * providing a bridge for external devtools to inspect and interact with the application instance.
 */

import { createLogger } from './logger.js';
/**
 * @typedef {import('../core/core.js').App} App
 */

/**
 * @typedef {object} DevToolsEvents
 * @property {(event: string, callback: Function) => void} on - Registers an event listener.
 * @property {(event: string, data: any) => void} emit - Emits an event to all listeners.
 * @property {(event: string, callback: Function) => void} off - Removes a specific event listener.
 */

const logger = createLogger('[DevTools]');
/**
 * @internal
 * @type {App | null}
 */
let appInstance = null;
/**
 * @internal
 * @type {Map<string, Array<Function>>}
 */
const listeners = new Map();

/**
 * @internal
 * @type {DevToolsEvents}
 */
const events = {
  on(event, callback) {
    if (!listeners.has(event)) {
      listeners.set(event, []);
    }
    const eventListeners = listeners.get(event);
    if (eventListeners) {
      eventListeners.push(callback);
    }
  },

  emit(event, data) {
    listeners.get(event)?.forEach((cb) => cb(data));
  },

  off(event, callback) {
    const eventListeners = listeners.get(event);
    if (eventListeners) {
      const index = eventListeners.indexOf(callback);
      if (index > -1) {
        eventListeners.splice(index, 1);
      }
    }
  },
};

/**
 * Initializes the developer tools global hook.
 * This function should be called when the application is bootstrapping on the client.
 */
export function initDevTools() {
  if (typeof window === 'undefined') {
    return;
  }

  logger.log('Initializing global __WEBS_DEVEVOPER__');

  /**
   * @global
   * @namespace __WEBS_DEVELOPER__
   * @property {(app: App) => void} registerApp - Registers the main application instance.
   * @property {() => App | null} getApp - Retrieves the registered application instance.
   * @property {DevToolsEvents} events - An event emitter for devtools communication.
   */
  // @ts-ignore
  window.__WEBS_DEVELOPER__ = {
    /** @param {App} app */
    registerApp(app) {
      logger.log('Application instance registered with devtools.');
      appInstance = app;
      events.emit('app:init', app);
    },

    getApp() {
      return appInstance;
    },

    events,
  };
}

---------- END: developer/developer.js ----------
