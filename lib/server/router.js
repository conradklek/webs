import { getUserFromSession, createSession } from './authentication.js';
import { createFileSystemForUser } from './fs.server.js';
import { renderToString } from '../engine/ssr.js';
import { handleApiRequest } from './api.js';
import { stat, exists } from 'fs/promises';
import { basename, join } from 'path';
import { h } from '../engine/vdom.js';
import { createLogger } from '../shared/logger.js';

/**
 * @file This is the core request handler for the server. It's responsible for routing incoming
 * requests to the appropriate handler, whether it's serving a static file, executing an API
 * endpoint, handling a server-side action, or rendering a page component.
 */

/**
 * @typedef {import('bun:sqlite').Database} BunDatabase
 * @typedef {import('./ai.server.js').AI} AI
 * @typedef {import('./server-config.js').Config} Config
 * @typedef {import('./ai.server.js').AgentDefinition} AgentDefinition
 */

/**
 * Defines the structure of the asset manifest generated by the build process.
 * This manifest tells the server where to find the bundled JavaScript, CSS, and service worker files.
 * @typedef {object} ServerManifest
 * @property {string | undefined} js - The path to the main client-side JavaScript bundle.
 * @property {string | undefined} css - The path to the main CSS bundle.
 * @property {string | undefined} sw - The path to the generated service worker file.
 */

/**
 * Represents the definition of a server-side route, which is generated from a page component file.
 * This object links a URL path to its rendering and data-handling logic.
 * @typedef {object} RouteDefinition
 * @property {any} component - The compiled component object to be rendered for this route.
 * @property {string} componentName - The unique, file-path-derived name of the component (e.g., 'app/posts/index').
 * @property {Record<string, Function>} actions - Server-side functions exported from the component that can be called from the client (e.g., `prefetch`, form actions).
 * @property {Record<string, Function>} handlers - HTTP method handlers (e.g., `post`, `patch`) for handling API-like requests directly on the component's route.
 * @property {Record<string, Function>} wsHandlers - WebSocket lifecycle handlers (`onOpen`, `onMessage`, etc.) for real-time communication on this route.
 * @property {any} [cc] - Compiled native C functions for this route.
 */

/**
 * A comprehensive context object containing all necessary server-side resources and configuration.
 * This object is assembled once at server startup and passed to the main fetch handler.
 * @typedef {object} ServerContext
 * @property {BunDatabase} db - The singleton database instance.
 * @property {AI} ai - The singleton AI service instance.
 * @property {any} dbConfig - The database schema configuration.
 * @property {ServerManifest} manifest - The asset manifest from the build process.
 * @property {Record<string, RouteDefinition>} appRoutes - A map of URL patterns to their corresponding `RouteDefinition`.
 * @property {Record<string, AgentDefinition>} agentRoutes - A map of AI agent names to their definitions.
 * @property {Config} config - The global server configuration object.
 * @property {boolean} isProd - A flag indicating if the server is running in production mode.
 * @property {string} SYNC_TOPIC - The name of the WebSocket topic for data synchronization.
 * @property {string} actionsPath - The path to the dynamically generated server actions file.
 * @property {any} globalComponents - A map of globally registered UI components.
 * @property {Record<string, string>} sourceToComponentMap - A development-only map from source file paths to their component names.
 * @property {Record<string, Function>} syncActions - A map of generated functions for handling database synchronization.
 * @property {string[]} sourceEntrypoints - A list of all discovered `.webs` source files.
 * @property {object | null} [frameworkNativeModules] - Compiled native modules for internal framework use.
 */

/**
 * @internal
 * The context required for handling a data-only request (client-side navigation).
 * @typedef {object} DataRequestContext
 * @property {ServerManifest} manifest - The asset manifest.
 * @property {Record<string, string>} sourceToComponentMap - A map from source file paths to component names.
 * @property {object | null} [frameworkNativeModules]
 */

/**
 * @internal
 * The context required for handling a full page request (SSR).
 * @typedef {object} PageRequestContext
 * @property {ServerManifest} manifest - The asset manifest.
 * @property {any} globalComponents - A map of globally registered UI components.
 * @property {Record<string, string>} sourceToComponentMap - A map from source file paths to component names.
 * @property {object | null} [frameworkNativeModules]
 */

/**
 * The context for the prefetch function.
 * @typedef {object} PrefetchContext
 * @property {BunDatabase} db
 * @property {any} user
 * @property {any} params
 * @property {import('./fs.server.js').ServerFsApi | null} fs
 * @property {object | null | undefined} frameworkNativeModules
 */

const logger = createLogger('[Router]');
/** @type {Map<string, { gzippedBuffer: Buffer, contentType: string }>} */
const gzipCache = new Map();

/**
 * @param {Request} req
 * @param {string} filePath
 */
async function serveStaticFile(req, filePath) {
  const acceptsGzip = req.headers.get('Accept-Encoding')?.includes('gzip');
  const file = Bun.file(filePath);

  if (acceptsGzip) {
    if (gzipCache.has(filePath)) {
      const cached = gzipCache.get(filePath);
      if (cached) {
        const { gzippedBuffer, contentType } = cached;
        logger.debug(`Serving gzipped file from cache: ${filePath}`);
        return new Response(
          /** @type {BodyInit} */ (/** @type {unknown} */ (gzippedBuffer)),
          {
            headers: {
              'Content-Encoding': 'gzip',
              'Content-Type': contentType,
            },
          },
        );
      }
    }

    logger.debug(`Gzipping and serving file: ${filePath}`);
    const buffer = await file.arrayBuffer();
    const gzippedBuffer = Bun.gzipSync(new Uint8Array(buffer));
    const contentType = file.type;

    gzipCache.set(filePath, {
      gzippedBuffer: /** @type {Buffer} */ (
        /** @type {unknown} */ (gzippedBuffer)
      ),
      contentType,
    });

    return new Response(
      /** @type {BodyInit} */ (/** @type {unknown} */ (gzippedBuffer)),
      {
        headers: {
          'Content-Encoding': 'gzip',
          'Content-Type': contentType,
        },
      },
    );
  }

  logger.debug(`Serving uncompressed file: ${filePath}`);
  return new Response(file);
}

/**
 * @param {{appHtml: string, websState: any, manifest: ServerManifest, title: string}} params
 */
function renderHtmlShell({ appHtml, websState, manifest, title }) {
  const cssPath = manifest.css ? `/${basename(manifest.css)}` : '';
  const jsPath = manifest.js ? `/${basename(manifest.js)}` : '';

  logger.debug('Rendering HTML shell for', title);
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${title}</title>
    ${cssPath ? `<link rel="stylesheet" href="${cssPath}">` : ''}
</head>
<body>
    <div id="root">${appHtml}</div>
    <script>window.__WEBS_STATE__ = ${JSON.stringify(websState)};</script>
    <script type="module" src="${jsPath}"></script>
</body>
</html>`;
}

/**
 * @param {RouteDefinition} routeDefinition
 * @param {PrefetchContext} context
 */
async function executePrefetch(routeDefinition, context) {
  logger.debug(
    `Executing prefetch for component '${routeDefinition.componentName}'...`,
  );
  if (!routeDefinition.actions?.prefetch) {
    logger.debug('No prefetch action found.');
    return {};
  }
  try {
    const fullContext = {
      ...context,
      cc: routeDefinition.cc,
      native: context.frameworkNativeModules,
    };
    const result = await routeDefinition.actions.prefetch(fullContext);
    logger.debug('Prefetch action completed successfully.');
    return result;
  } catch (err) {
    logger.error(`Prefetch Error for "${routeDefinition.componentName}":`, err);
    return { error: 'Failed to load data on the server.' };
  }
}

/**
 * @param {Request & {db: BunDatabase, user: any, params: any}} req
 * @param {RouteDefinition} routeDefinition
 * @param {DataRequestContext} context
 */
async function handleDataRequest(req, routeDefinition, context) {
  logger.info(`Handling data request for route '${req.url}'`);
  const { db, user, params } = req;
  const { manifest, sourceToComponentMap, frameworkNativeModules } = context;
  const fs = user ? createFileSystemForUser(user.id) : null;

  const componentState = await executePrefetch(routeDefinition, {
    db,
    user,
    params,
    fs,
    frameworkNativeModules,
  });

  const websState = {
    user,
    params,
    componentState,
    componentName: routeDefinition.componentName,
    title: routeDefinition.component.name || 'Webs App',
    swPath: manifest.sw ? `/${basename(manifest.sw)}` : null,
    sourceToComponentMap,
  };
  logger.debug('Sending JSON response for data request.');
  return new Response(JSON.stringify(websState), {
    headers: { 'Content-Type': 'application/json;charset=utf-8' },
  });
}

/**
 * @param {Request & {db: BunDatabase, user: any, params: any}} req
 * @param {RouteDefinition} routeDefinition
 * @param {PageRequestContext} context
 */
async function handlePageRequest(req, routeDefinition, context) {
  logger.info(`Handling page request for route '${req.url}'`);
  const {
    manifest,
    globalComponents,
    sourceToComponentMap,
    frameworkNativeModules,
  } = context;
  const { db, user, params } = req;
  const fs = user ? createFileSystemForUser(user.id) : null;

  const initialState = await executePrefetch(routeDefinition, {
    db,
    user,
    params,
    fs,
    frameworkNativeModules,
  });

  const { pathname } = new URL(req.url);
  const props = {
    user,
    params,
    initialState,
    path: pathname,
    cc: routeDefinition.cc,
  };

  const vnode = h(routeDefinition.component, props);
  vnode.appContext = {
    components: globalComponents || {},
    provides: {},
    patch: () => {},
    hydrate: () => null,
    params: params || {},
  };

  logger.debug('Starting SSR...');
  const { html: appHtml, componentState } = await renderToString(vnode);
  logger.debug('SSR complete.');

  const websState = {
    user,
    params,
    componentState: componentState || initialState,
    componentName: routeDefinition.componentName,
    swPath: manifest.sw ? `/${basename(manifest.sw)}` : null,
    sourceToComponentMap,
  };

  const fullHtml = renderHtmlShell({
    appHtml,
    websState,
    manifest,
    title: routeDefinition.component.name || 'Webs App',
  });
  logger.debug('Sending full HTML page response.');
  return new Response(fullHtml, {
    headers: { 'Content-Type': 'text/html;charset=utf-8' },
  });
}

/**
 * @param {BunDatabase} db
 * @param {boolean} isProd
 */
const authMiddleware =
  (db, isProd) =>
  (/** @type {Request & {db?: BunDatabase, user?: any}} */ req) => {
    req.db = db;
    const cookie = req.headers.get('cookie');
    const sessionId = cookie?.match(/session_id=([^;]+)/)?.[1];
    let user = sessionId ? getUserFromSession(db, sessionId) : null;

    if (!isProd && !user) {
      const anonUser = db
        .query('SELECT id, username, email FROM users WHERE username = ?')
        .get('anon');
      if (anonUser) {
        const newSessionId = createSession(
          db,
          /** @type {{id: number}} */ (anonUser).id,
        );
        user = anonUser;
        req.headers.set('X-Set-Dev-Session', newSessionId);
      }
    }
    req.user = user;
  };

/**
 * @param {ServerContext} context
 */
export function createFetchHandler(context) {
  const {
    db,
    manifest,
    appRoutes,
    globalComponents,
    config,
    isProd,
    sourceToComponentMap,
    frameworkNativeModules,
  } = context;
  const { OUTDIR, SRC_DIR } = config;

  const attachContext = authMiddleware(db, isProd);
  const sortedAppRoutePaths = Object.keys(appRoutes || {});

  /**
   * @param {Request} req
   * @param {import('bun').Server} server
   */
  return async function fetch(req, server) {
    const url = new URL(req.url);
    const { pathname } = url;
    logger.info(`Received request for: ${pathname}`);

    if (pathname.includes('..')) {
      logger.warn('Path traversal attempt detected.');
      return new Response('Forbidden', { status: 403 });
    }

    const potentialFilePath = join(OUTDIR, pathname.substring(1));
    if (
      (await exists(potentialFilePath)) &&
      (await stat(potentialFilePath)).isFile()
    ) {
      return serveStaticFile(req, potentialFilePath);
    }

    if (!isProd) {
      const potentialSrcPath = join(SRC_DIR, pathname.substring(1));
      if (
        (await exists(potentialSrcPath)) &&
        (await stat(potentialSrcPath)).isFile()
      ) {
        return serveStaticFile(req, potentialSrcPath);
      }
    }
    const extendedReq =
      /** @type {Request & { db: any, user: any, params: any }} */ (req);
    attachContext(extendedReq);

    if (pathname.startsWith('/api/')) {
      const apiResponse = await handleApiRequest(extendedReq, server, context);
      if (apiResponse) return apiResponse;
    }

    if (req.headers.get('upgrade') === 'websocket') {
      if (pathname === '/api/sync') {
        if (extendedReq.user) {
          return server.upgrade(req, {
            data: { isSyncChannel: true, user: extendedReq.user },
          })
            ? undefined
            : new Response('Unauthorized', { status: 401 });
        }
      }
    }

    const actionMatch = pathname.match(/^\/__actions__\/(.+?)\/(.+?)$/);
    if (actionMatch) {
      if (!extendedReq.user)
        return new Response('Unauthorized', { status: 401 });
      const [, componentName, actionName] = actionMatch;
      if (!componentName || !actionName) {
        return new Response('Action not found', { status: 404 });
      }
      const routeDef = Object.values(appRoutes).find(
        (r) =>
          (r.componentName === componentName ||
            r.component.name === componentName) &&
          r.actions &&
          actionName in r.actions,
      );
      const action = routeDef?.actions?.[actionName];

      if (typeof action !== 'function')
        return new Response('Action not found', { status: 404 });

      try {
        const args = await req.json();
        const result = await action(
          {
            req,
            db,
            fs: createFileSystemForUser(extendedReq.user.id),
            user: extendedReq.user,
            cc: routeDef?.cc,
            native: frameworkNativeModules,
          },
          ...args,
        );
        return result instanceof Response ? result : Response.json(result);
      } catch (e) {
        logger.error('Error executing action:', e);
        return new Response('Internal Server Error', { status: 500 });
      }
    }

    for (const path of sortedAppRoutePaths) {
      const routeDefinition = appRoutes[path];
      /** @type {string[]} */
      const paramNames = [];
      let pathRegexStr = path.replace(/:(\w+)(\*)?/g, (_, name, isCatchAll) => {
        paramNames.push(name);
        return isCatchAll ? '(.*)' : '([^/]+)';
      });

      if (path.endsWith('*')) {
        const lastSlashIndex = pathRegexStr.lastIndexOf('/');
        if (lastSlashIndex !== -1) {
          pathRegexStr =
            pathRegexStr.substring(0, lastSlashIndex) +
            '(?:\\' +
            pathRegexStr.substring(lastSlashIndex) +
            ')?';
        }
      }

      const regex = new RegExp(`^${pathRegexStr}$`);
      const match = pathname.match(regex);

      if (match && routeDefinition) {
        logger.info(`Matched request to route: '${path}'`);
        extendedReq.params = paramNames.reduce((acc, name, i) => {
          let value = match[i + 1] || '';
          if (value === undefined && path.endsWith('*')) {
            value = '';
          }
          if (
            path.endsWith('*') &&
            name === paramNames[paramNames.length - 1]
          ) {
            value = value.startsWith('/') ? value.substring(1) : value;
          }
          /** @type {any} */ (acc)[name] = value;
          return acc;
        }, {});

        if (req.headers.get('upgrade') === 'websocket') {
          if (
            routeDefinition.wsHandlers &&
            Object.keys(routeDefinition.wsHandlers).length > 0
          ) {
            logger.info(`Upgrading to WebSocket for route: ${path}`);
            const success = server.upgrade(req, {
              data: {
                user: extendedReq.user,
                params: extendedReq.params,
                wsHandlers: routeDefinition.wsHandlers,
              },
            });
            return success
              ? undefined
              : new Response('WebSocket upgrade failed', { status: 500 });
          }
        }

        const requestMethod = req.method.toLowerCase();
        if (requestMethod !== 'get') {
          if (!extendedReq.user) {
            return new Response('Unauthorized', { status: 401 });
          }

          const handler = routeDefinition.handlers?.[requestMethod];

          if (handler && typeof handler === 'function') {
            try {
              const result = await handler({
                req: extendedReq,
                db,
                user: extendedReq.user,
                params: extendedReq.params,
                fs: createFileSystemForUser(extendedReq.user.id),
                cc: routeDefinition.cc,
                native: frameworkNativeModules,
              });

              if (result instanceof Response) {
                return result;
              }
              if (result !== undefined) {
                return Response.json(result);
              }
              return new Response(null, { status: 204 });
            } catch (e) {
              const error = /** @type {Error} */ (e);
              logger.error(
                `Error executing '${requestMethod}' handler for route '${path}':`,
                error,
              );
              return new Response(error.message || 'Internal Server Error', {
                status: 500,
              });
            }
          } else {
            return new Response('Method Not Allowed', { status: 405 });
          }
        }

        const response = req.headers.get('X-Webs-Navigate')
          ? await handleDataRequest(extendedReq, routeDefinition, {
              manifest,
              sourceToComponentMap,
              frameworkNativeModules,
            })
          : await handlePageRequest(extendedReq, routeDefinition, {
              manifest,
              globalComponents,
              sourceToComponentMap,
              frameworkNativeModules,
            });

        const devSessionId = req.headers.get('X-Set-Dev-Session');
        if (devSessionId) {
          response.headers.append(
            'Set-Cookie',
            `session_id=${devSessionId}; HttpOnly; Path=/; SameSite=Strict; Max-Age=604800`,
          );
        }
        return response;
      }
    }

    logger.info('No route matched, returning 404.');
    return new Response('Not Found', { status: 404 });
  };
}
