<script>
  import {
    onReady,
    onUnmounted,
    computed,
    state,
    session,
    fs,
  } from '@conradklek/webs';

  export default {
    actions: {
      async prefetch({ fs, params, user }) {
        if (!user) {
          return { error: 'You must be logged in to view files.' };
        }
        try {
          const items = await fs.ls(params.path || '.', { access: 'private' });
          return { items: items || [] };
        } catch (error) {
          return { error: 'Could not load directory contents.' };
        }
      },
    },
    props: {
      initialState: Object,
      params: Object,
    },

    setup(props) {
      const currentPath = computed(() => props.params.path || '');
      const items = fs(currentPath.value).use(props.initialState?.items || []);
      const uploadStatus = state('');
      const newItemName = state('');

      const breadcrumbs = computed(() => {
        const path = props.params.path || '';
        const segments = path.split('/').filter(Boolean);
        const crumbs = [{ name: 'fs', path: `/${props.params.username}/fs` }];
        let pathAccumulator = `/${props.params.username}/fs`;
        for (const segment of segments) {
          pathAccumulator += `/${segment}`;
          crumbs.push({ name: segment, path: pathAccumulator });
        }
        return crumbs;
      });

      const parentDirectoryLink = computed(() => {
        const path = props.params.path || '';
        if (!path) return null;

        const segments = path.split('/');
        segments.pop();
        const parentPath = segments.join('/');

        return `/${props.params.username}/fs/${parentPath}`;
      });

      const sortedItems = computed(() => {
        return [...(items.data || [])].sort((a, b) => {
          if (a.isDirectory && !b.isDirectory) return -1;
          if (!a.isDirectory && b.isDirectory) return 1;
          return a.name.localeCompare(b.name);
        });
      });

      async function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        uploadStatus.value = `Uploading ${file.name}...`;
        const targetPath = `${currentPath.value ? currentPath.value + '/' : ''}${file.name}`;

        try {
          await fs(targetPath).write(file, { access: 'private' });
          uploadStatus.value = `Successfully uploaded ${file.name}!`;
        } catch (error) {
          uploadStatus.value = `Error: ${error.message}`;
        }
        event.target.value = '';
      }

      async function handleCreateItem() {
        const name = newItemName.value.trim();
        if (!name || name.includes('..') || name.includes('\\')) {
          return;
        }

        const isDir = name.endsWith('/');
        const cleanName = isDir ? name.slice(0, -1) : name;
        if (!cleanName) return;

        const basePath = currentPath.value || '';
        const newPath = `${basePath ? basePath + '/' : ''}${cleanName}`;

        try {
          if (isDir) {
            await fs(`${newPath}/.placeholder`).write('', {
              access: 'private',
            });
          } else {
            await fs(newPath).write('', { access: 'private' });
          }
          newItemName.value = '';
        } catch (error) {
          /* bug */
        }
      }

      async function handleDeleteItem(path) {
        await fs(path).rm({ access: 'private' });
      }

      onReady(() => {
        items.hydrate(props.initialState?.items);
      });

      return {
        items,
        sortedItems,
        currentPath,
        breadcrumbs,
        params: props.params,
        handleFileUpload,
        uploadStatus,
        newItemName,
        handleCreateItem,
        parentDirectoryLink,
        handleDeleteItem,
        error: props.initialState?.error,
      };
    },
  };
</script>

<template>
  <div class="flex flex-col gap-4">
    <breadcrumb>
      <breadcrumb-list>
        {#each breadcrumbs as (crumb, index) (crumb.path)}
        <breadcrumb-item>
          {#if index < breadcrumbs.length - 1}
          <breadcrumb-link :href="crumb.path">{{ crumb.name }}</breadcrumb-link>
          {:else}
          <breadcrumb-active>{{ crumb.name }}</breadcrumb-active>
          {/if}
        </breadcrumb-item>
        {#if index < breadcrumbs.length - 1}
        <breadcrumb-separator />
        {/if} {/each}
      </breadcrumb-list>
    </breadcrumb>

    {#if error}
    <div class="p-4 bg-red-100 text-red-700 rounded-lg">
      <strong>Error:</strong> {{ error }}
    </div>
    {:else}
    <div class="mt-4">
      <div class="mb-4 space-y-4">
        <form @submit.prevent="handleCreateItem" class="flex gap-2">
          <input
            bind:value="newItemName"
            type="text"
            placeholder="new-directory/ or new-file.txt"
            class="input"
          />
          <button
            type="submit"
            class="btn btn-size-lg btn-default"
            :disabled="!newItemName.trim()"
          >
            Create
          </button>
        </form>
        <div>
          <label
            for="file-upload"
            class="btn btn-size-lg btn-default cursor-pointer"
          >
            Upload File
          </label>
          <input
            id="file-upload"
            type="file"
            class="hidden"
            @change="handleFileUpload"
          />
          {#if uploadStatus}
          <p class="text-sm text-muted-foreground mt-2">{{ uploadStatus }}</p>
          {/if}
        </div>
      </div>
      <ul class="space-y-2">
        {#if parentDirectoryLink}
        <li class="font-mono">
          <a :href="parentDirectoryLink" class="link">../</a>
        </li>
        {/if} {#if sortedItems && sortedItems.length > 0} {#each sortedItems as
        item (item.path)}
        <li class="font-mono flex justify-between items-center group">
          <div class="flex-1">
            {#if item.isDirectory}
            <a :href="'/' + params.username + '/fs/' + item.path" class="link"
              >{{ item.name }}/</a
            >
            {:else}
            <a
              :href="'/' + params.username + '/editor/' + item.path"
              class="link"
              >{{ item.name }}</a
            >
            {/if}
          </div>
          <button
            @click="handleDeleteItem(item.path)"
            class="link text-red-500 hover:text-red-700 opacity-0 group-hover:opacity-100 transition-opacity"
            aria-label="Delete item"
          >
            Delete
          </button>
        </li>
        {/each} {:else if !items.isLoading}
        <li class="text-muted-foreground">This directory is empty.</li>
        {/if}
      </ul>
    </div>
    {/if}
  </div>
</template>
